; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	inflate_copyright
CONST	SEGMENT
inflate_copyright DB ' inflate 1.2.5 Copyright 1995-2010 Mark Adler ', 00H
	ORG $+1
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	049H
	DW	0c3H
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
CONST	ENDS
PUBLIC	inflate_table
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_table DD imagerel $LN162
	DD	imagerel $LN162+298
	DD	imagerel $unwind$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflate_table DD imagerel $LN162+298
	DD	imagerel $LN162+1143
	DD	imagerel $chain$0$inflate_table
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflate_table DD imagerel $LN162+1143
	DD	imagerel $LN162+1161
	DD	imagerel $chain$1$inflate_table
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflate_table DD 021H
	DD	imagerel $LN162
	DD	imagerel $LN162+298
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflate_table DD 020521H
	DD	0ff405H
	DD	imagerel $LN162
	DD	imagerel $LN162+298
	DD	imagerel $unwind$inflate_table
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_table DD 082201H
	DD	0e018f222H
	DD	0c014d016H
	DD	060117012H
	DD	0500f3010H
xdata	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inftrees.c
;	COMDAT inflate_table
_TEXT	SEGMENT
sym$2$ = 0
end$1$ = 4
used$1$ = 8
mask$1$ = 12
base$1$ = 24
extra$1$ = 32
count$ = 40
offs$ = 72
type$ = 192
lens$ = 200
here$ = 208
codes$ = 208
table$ = 216
bits$ = 224
work$ = 232
inflate_table PROC					; COMDAT

; 39   : {

$LN162:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	55		 push	 rbp
  0000f	53		 push	 rbx
  00010	56		 push	 rsi
  00011	57		 push	 rdi
  00012	41 54		 push	 r12
  00014	41 55		 push	 r13
  00016	41 56		 push	 r14
  00018	48 8b ec	 mov	 rbp, rsp
  0001b	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code here;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     int end;                    /* use base and extra for symbol > end */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 73, 195};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)
; 108  :         count[len] = 0;

  00022	45 33 f6	 xor	 r14d, r14d
  00025	41 8b d8	 mov	 ebx, r8d
  00028	8b f1		 mov	 esi, ecx
  0002a	48 8d 7d a8	 lea	 rdi, QWORD PTR count$[rbp-128]
  0002e	b9 10 00 00 00	 mov	 ecx, 16
  00033	41 0f b7 c6	 movzx	 eax, r14w
  00037	4c 8b c2	 mov	 r8, rdx
  0003a	66 f3 ab	 rep stosw

; 109  :     for (sym = 0; sym < codes; sym++)

  0003d	85 db		 test	 ebx, ebx
  0003f	74 24		 je	 SHORT $LN63@inflate_ta
  00041	48 8b fa	 mov	 rdi, rdx
  00044	44 8b c3	 mov	 r8d, ebx
  00047	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL65@inflate_ta:

; 110  :         count[lens[sym]]++;

  00050	0f b7 07	 movzx	 eax, WORD PTR [rdi]
  00053	48 8d 7f 02	 lea	 rdi, QWORD PTR [rdi+2]
  00057	66 ff 44 45 a8	 inc	 WORD PTR count$[rbp+rax*2-128]
  0005c	49 ff c8	 dec	 r8
  0005f	75 ef		 jne	 SHORT $LL65@inflate_ta
  00061	4c 8b 45 48	 mov	 r8, QWORD PTR lens$[rbp-128]
$LN63@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  00065	48 8b 55 60	 mov	 rdx, QWORD PTR bits$[rbp-128]

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00069	41 ba 0f 00 00
	00		 mov	 r10d, 15
  0006f	41 83 cc ff	 or	 r12d, -1		; ffffffffH
  00073	44 8b 2a	 mov	 r13d, DWORD PTR [rdx]
  00076	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL62@inflate_ta:

; 115  :         if (count[max] != 0) break;

  00080	41 8b c2	 mov	 eax, r10d
  00083	66 44 39 74 45
	a8		 cmp	 WORD PTR count$[rbp+rax*2-128], r14w
  00089	75 09		 jne	 SHORT $LN85@inflate_ta

; 114  :     for (max = MAXBITS; max >= 1; max--)

  0008b	45 03 d4	 add	 r10d, r12d
  0008e	41 83 fa 01	 cmp	 r10d, 1
  00092	73 ec		 jae	 SHORT $LL62@inflate_ta
$LN85@inflate_ta:

; 116  :     if (root > max) root = max;

  00094	45 3b ea	 cmp	 r13d, r10d
  00097	45 0f 47 ea	 cmova	 r13d, r10d

; 117  :     if (max == 0) {                     /* no symbols to code at all */

  0009b	45 85 d2	 test	 r10d, r10d
  0009e	75 29		 jne	 SHORT $LN57@inflate_ta

; 118  :         here.op = (unsigned char)64;    /* invalid code marker */
; 119  :         here.bits = (unsigned char)1;
; 120  :         here.val = (unsigned short)0;
; 121  :         *(*table)++ = here;             /* make a table to force an error */

  000a0	49 8b 09	 mov	 rcx, QWORD PTR [r9]
  000a3	c7 45 50 40 01
	00 00		 mov	 DWORD PTR here$[rbp-128], 320 ; 00000140H
  000aa	8b 45 50	 mov	 eax, DWORD PTR here$[rbp-128]
  000ad	89 01		 mov	 DWORD PTR [rcx], eax
  000af	49 83 01 04	 add	 QWORD PTR [r9], 4
  000b3	49 8b 09	 mov	 rcx, QWORD PTR [r9]

; 122  :         *(*table)++ = here;

  000b6	89 01		 mov	 DWORD PTR [rcx], eax
  000b8	49 83 01 04	 add	 QWORD PTR [r9], 4

; 123  :         *bits = 1;

  000bc	c7 02 01 00 00
	00		 mov	 DWORD PTR [rdx], 1

; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  000c2	33 c0		 xor	 eax, eax
  000c4	e9 ae 03 00 00	 jmp	 $LN69@inflate_ta
$LN57@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000c9	41 bb 01 00 00
	00		 mov	 r11d, 1
  000cf	45 3b d3	 cmp	 r10d, r11d
  000d2	76 16		 jbe	 SHORT $LN144@inflate_ta
  000d4	48 8d 45 aa	 lea	 rax, QWORD PTR count$[rbp-126]
$LL56@inflate_ta:

; 127  :         if (count[min] != 0) break;

  000d8	66 44 39 30	 cmp	 WORD PTR [rax], r14w
  000dc	75 0c		 jne	 SHORT $LN144@inflate_ta

; 125  :     }
; 126  :     for (min = 1; min < max; min++)

  000de	41 ff c3	 inc	 r11d
  000e1	48 83 c0 02	 add	 rax, 2
  000e5	45 3b da	 cmp	 r11d, r10d
  000e8	72 ee		 jb	 SHORT $LL56@inflate_ta
$LN144@inflate_ta:

; 128  :     if (root < min) root = min;

  000ea	45 3b eb	 cmp	 r13d, r11d

; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  000ed	bf 01 00 00 00	 mov	 edi, 1
  000f2	45 0f 42 eb	 cmovb	 r13d, r11d

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  000f6	8b d7		 mov	 edx, edi
  000f8	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL51@inflate_ta:

; 133  :         left <<= 1;
; 134  :         left -= count[len];

  00100	8b c2		 mov	 eax, edx
  00102	03 ff		 add	 edi, edi
  00104	0f b7 4c 45 a8	 movzx	 ecx, WORD PTR count$[rbp+rax*2-128]
  00109	2b f9		 sub	 edi, ecx

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  0010b	78 15		 js	 SHORT $LN46@inflate_ta

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  0010d	ff c2		 inc	 edx
  0010f	83 fa 0f	 cmp	 edx, 15
  00112	76 ec		 jbe	 SHORT $LL51@inflate_ta

; 136  :     }
; 137  :     if (left > 0 && (type == CODES || max != 1))

  00114	85 ff		 test	 edi, edi
  00116	7e 12		 jle	 SHORT $LN47@inflate_ta
  00118	85 f6		 test	 esi, esi
  0011a	74 06		 je	 SHORT $LN46@inflate_ta
  0011c	41 83 fa 01	 cmp	 r10d, 1
  00120	74 08		 je	 SHORT $LN47@inflate_ta
$LN46@inflate_ta:

; 138  :         return -1;                      /* incomplete set */

  00122	83 c8 ff	 or	 eax, -1
  00125	e9 4d 03 00 00	 jmp	 $LN69@inflate_ta
$LN47@inflate_ta:
  0012a	4c 89 7c 24 78	 mov	 QWORD PTR [rsp+120], r15

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  0012f	66 44 89 75 ca	 mov	 WORD PTR offs$[rbp-126], r14w

; 142  :     for (len = 1; len < MAXBITS; len++)

  00134	49 8b ce	 mov	 rcx, r14
  00137	ba 0e 00 00 00	 mov	 edx, 14
  0013c	0f 1f 40 00	 npad	 4
$LL45@inflate_ta:

; 143  :         offs[len + 1] = offs[len] + count[len];

  00140	0f b7 44 0d aa	 movzx	 eax, WORD PTR count$[rbp+rcx-126]
  00145	48 8d 49 02	 lea	 rcx, QWORD PTR [rcx+2]
  00149	66 03 44 0d c8	 add	 ax, WORD PTR offs$[rbp+rcx-128]
  0014e	66 89 44 0d ca	 mov	 WORD PTR offs$[rbp+rcx-126], ax
  00153	48 ff ca	 dec	 rdx
  00156	75 e8		 jne	 SHORT $LL45@inflate_ta

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  00158	41 8b fe	 mov	 edi, r14d
  0015b	85 db		 test	 ebx, ebx
  0015d	74 2e		 je	 SHORT $LN40@inflate_ta
  0015f	49 8b d0	 mov	 rdx, r8
  00162	4c 8b 45 68	 mov	 r8, QWORD PTR work$[rbp-128]
$LL42@inflate_ta:

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  00166	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  00169	66 85 c0	 test	 ax, ax
  0016c	74 15		 je	 SHORT $LN41@inflate_ta
  0016e	0f b7 c0	 movzx	 eax, ax
  00171	0f b7 4c 45 c8	 movzx	 ecx, WORD PTR offs$[rbp+rax*2-128]
  00176	66 41 89 3c 48	 mov	 WORD PTR [r8+rcx*2], di
  0017b	0f b7 02	 movzx	 eax, WORD PTR [rdx]
  0017e	66 ff 44 45 c8	 inc	 WORD PTR offs$[rbp+rax*2-128]
$LN41@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  00183	ff c7		 inc	 edi
  00185	48 83 c2 02	 add	 rdx, 2
  00189	3b fb		 cmp	 edi, ebx
  0018b	72 d9		 jb	 SHORT $LL42@inflate_ta
$LN40@inflate_ta:

; 195  :         extra = dext;
; 196  :         end = -1;

  0018d	4c 8b 4d 68	 mov	 r9, QWORD PTR work$[rbp-128]
  00191	8b ce		 mov	 ecx, esi
  00193	85 f6		 test	 esi, esi
  00195	74 48		 je	 SHORT $LN36@inflate_ta

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked for LENS and DIST tables against
; 170  :        the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
; 171  :        the initial root table size constants.  See the comments in inftrees.h
; 172  :        for more information.
; 173  : 
; 174  :        sym increments through all symbols, and the loop terminates when
; 175  :        all codes of length max, i.e. all codes, have been processed.  This
; 176  :        routine permits incomplete codes, so another loop after this one fills
; 177  :        in the rest of the decoding tables with invalid code markers.
; 178  :      */
; 179  : 
; 180  :     /* set up for code type */
; 181  :     switch (type) {

  00197	ff c9		 dec	 ecx
  00199	74 1b		 je	 SHORT $LN35@inflate_ta

; 193  :     default:            /* DISTS */
; 194  :         base = dbase;

  0019b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dbase@?1??inflate_table@@9@9

; 195  :         extra = dext;
; 196  :         end = -1;

  001a2	83 ca ff	 or	 edx, -1
  001a5	48 89 45 98	 mov	 QWORD PTR base$1$[rbp-128], rax
  001a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dext@?1??inflate_table@@9@9
  001b0	48 89 45 a0	 mov	 QWORD PTR extra$1$[rbp-128], rax
  001b4	eb 36		 jmp	 SHORT $LN156@inflate_ta
$LN35@inflate_ta:

; 185  :         break;
; 186  :     case LENS:
; 187  :         base = lbase;
; 188  :         base -= 257;

  001b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lbase@?1??inflate_table@@9@9

; 189  :         extra = lext;
; 190  :         extra -= 257;
; 191  :         end = 256;

  001bd	ba 00 01 00 00	 mov	 edx, 256		; 00000100H
  001c2	48 2d 02 02 00
	00		 sub	 rax, 514		; 00000202H
  001c8	48 89 45 98	 mov	 QWORD PTR base$1$[rbp-128], rax
  001cc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lext@?1??inflate_table@@9@9
  001d3	48 2d 02 02 00
	00		 sub	 rax, 514		; 00000202H
  001d9	48 89 45 a0	 mov	 QWORD PTR extra$1$[rbp-128], rax

; 192  :         break;

  001dd	eb 0d		 jmp	 SHORT $LN156@inflate_ta
$LN36@inflate_ta:

; 182  :     case CODES:
; 183  :         base = extra = work;    /* dummy value--not used */

  001df	4c 89 4d a0	 mov	 QWORD PTR extra$1$[rbp-128], r9
  001e3	4c 89 4d 98	 mov	 QWORD PTR base$1$[rbp-128], r9

; 184  :         end = 19;

  001e7	ba 13 00 00 00	 mov	 edx, 19
$LN156@inflate_ta:

; 197  :     }
; 198  : 
; 199  :     /* initialize state for loop */
; 200  :     huff = 0;                   /* starting code */
; 201  :     sym = 0;                    /* starting code symbol */
; 202  :     len = min;                  /* starting code length */
; 203  :     next = *table;              /* current table to fill in */

  001ec	48 8b 5d 58	 mov	 rbx, QWORD PTR table$[rbp-128]
  001f0	41 8b fe	 mov	 edi, r14d
  001f3	44 89 75 80	 mov	 DWORD PTR sym$2$[rbp-128], r14d
  001f7	4c 8b 3b	 mov	 r15, QWORD PTR [rbx]

; 204  :     curr = root;                /* current table index bits */
; 205  :     drop = 0;                   /* current bits to drop from code for index */

  001fa	41 8b f6	 mov	 esi, r14d

; 206  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */
; 207  :     used = 1U << root;          /* use root table entries */

  001fd	41 8b cd	 mov	 ecx, r13d
  00200	41 be 01 00 00
	00		 mov	 r14d, 1
  00206	89 55 84	 mov	 DWORD PTR end$1$[rbp-128], edx
  00209	41 d3 e6	 shl	 r14d, cl
  0020c	44 89 75 88	 mov	 DWORD PTR used$1$[rbp-128], r14d

; 208  :     mask = used - 1;            /* mask for comparing low */

  00210	41 8d 46 ff	 lea	 eax, DWORD PTR [r14-1]
  00214	89 45 8c	 mov	 DWORD PTR mask$1$[rbp-128], eax

; 209  : 
; 210  :     /* check available table space */
; 211  :     if ((type == LENS && used >= ENOUGH_LENS) ||
; 212  :         (type == DISTS && used >= ENOUGH_DISTS))

  00217	8b 45 40	 mov	 eax, DWORD PTR type$[rbp-128]
  0021a	83 f8 01	 cmp	 eax, 1
  0021d	75 09		 jne	 SHORT $LN31@inflate_ta
  0021f	41 81 fe 54 03
	00 00		 cmp	 r14d, 852		; 00000354H
  00226	eb 0c		 jmp	 SHORT $LN160@inflate_ta
$LN31@inflate_ta:
  00228	83 f8 02	 cmp	 eax, 2
  0022b	75 0d		 jne	 SHORT $LN138@inflate_ta
  0022d	41 81 fe 50 02
	00 00		 cmp	 r14d, 592		; 00000250H
$LN160@inflate_ta:
  00234	0f 83 33 02 00
	00		 jae	 $LN9@inflate_ta
$LN138@inflate_ta:
  0023a	8b ce		 mov	 ecx, esi
  0023c	eb 06		 jmp	 SHORT $LL30@inflate_ta
  0023e	66 90		 npad	 2
$LL147@inflate_ta:
  00240	48 8b 5d 58	 mov	 rbx, QWORD PTR table$[rbp-128]
$LL30@inflate_ta:

; 213  :         return 1;
; 214  : 
; 215  :     /* process all codes and make table entries */
; 216  :     for (;;) {
; 217  :         /* create table entry */
; 218  :         here.bits = (unsigned char)(len - drop);

  00244	41 0f b6 c3	 movzx	 eax, r11b
  00248	40 2a c6	 sub	 al, sil
  0024b	88 45 51	 mov	 BYTE PTR here$[rbp-127], al

; 219  :         if ((int)(work[sym]) < end) {

  0024e	8b c1		 mov	 eax, ecx
  00250	41 0f b7 0c 41	 movzx	 ecx, WORD PTR [r9+rax*2]
  00255	3b ca		 cmp	 ecx, edx
  00257	7d 0a		 jge	 SHORT $LN157@inflate_ta

; 220  :             here.op = (unsigned char)0;

  00259	c6 45 50 00	 mov	 BYTE PTR here$[rbp-128], 0

; 221  :             here.val = work[sym];

  0025d	66 89 4d 52	 mov	 WORD PTR here$[rbp-126], cx
  00261	eb 24		 jmp	 SHORT $LN25@inflate_ta
$LN157@inflate_ta:

; 222  :         }
; 223  :         else if ((int)(work[sym]) > end) {

  00263	7e 18		 jle	 SHORT $LN26@inflate_ta

; 224  :             here.op = (unsigned char)(extra[work[sym]]);

  00265	48 8b 45 a0	 mov	 rax, QWORD PTR extra$1$[rbp-128]
  00269	48 03 c9	 add	 rcx, rcx
  0026c	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00270	88 45 50	 mov	 BYTE PTR here$[rbp-128], al

; 225  :             here.val = base[work[sym]];

  00273	48 8b 45 98	 mov	 rax, QWORD PTR base$1$[rbp-128]
  00277	0f b7 04 01	 movzx	 eax, WORD PTR [rcx+rax]

; 226  :         }
; 227  :         else {

  0027b	eb 06		 jmp	 SHORT $LN158@inflate_ta
$LN26@inflate_ta:

; 228  :             here.op = (unsigned char)(32 + 64);         /* end of block */

  0027d	c6 45 50 60	 mov	 BYTE PTR here$[rbp-128], 96 ; 00000060H

; 229  :             here.val = 0;

  00281	33 c0		 xor	 eax, eax
$LN158@inflate_ta:
  00283	66 89 45 52	 mov	 WORD PTR here$[rbp-126], ax
$LN25@inflate_ta:

; 230  :         }
; 231  : 
; 232  :         /* replicate for those indices with low len bits equal to huff */
; 233  :         incr = 1U << (len - drop);

  00287	8b 45 50	 mov	 eax, DWORD PTR here$[rbp-128]
  0028a	41 8b cb	 mov	 ecx, r11d
  0028d	41 b9 01 00 00
	00		 mov	 r9d, 1
  00293	2b ce		 sub	 ecx, esi
  00295	8b d7		 mov	 edx, edi

; 234  :         fill = 1U << curr;

  00297	45 8b c6	 mov	 r8d, r14d
  0029a	41 d3 e1	 shl	 r9d, cl
  0029d	8b ce		 mov	 ecx, esi
  0029f	d3 ea		 shr	 edx, cl
  002a1	41 03 d6	 add	 edx, r14d
$LL24@inflate_ta:

; 235  :         min = fill;                 /* save offset to next table */
; 236  :         do {
; 237  :             fill -= incr;

  002a4	41 2b d1	 sub	 edx, r9d

; 238  :             next[(huff >> drop) + fill] = here;

  002a7	41 89 04 97	 mov	 DWORD PTR [r15+rdx*4], eax
  002ab	45 2b c1	 sub	 r8d, r9d

; 239  :         } while (fill != 0);

  002ae	75 f4		 jne	 SHORT $LL24@inflate_ta

; 240  : 
; 241  :         /* backwards increment the len-bit code huff */
; 242  :         incr = 1U << (len - 1);

  002b0	41 8d 4b ff	 lea	 ecx, DWORD PTR [r11-1]
  002b4	ba 01 00 00 00	 mov	 edx, 1
  002b9	d3 e2		 shl	 edx, cl

; 243  :         while (huff & incr)

  002bb	85 d7		 test	 edx, edi
  002bd	74 07		 je	 SHORT $LN20@inflate_ta
  002bf	90		 npad	 1
$LL21@inflate_ta:

; 244  :             incr >>= 1;

  002c0	d1 ea		 shr	 edx, 1
  002c2	85 d7		 test	 edx, edi
  002c4	75 fa		 jne	 SHORT $LL21@inflate_ta
$LN20@inflate_ta:

; 245  :         if (incr != 0) {

  002c6	85 d2		 test	 edx, edx
  002c8	74 0b		 je	 SHORT $LN19@inflate_ta

; 246  :             huff &= incr - 1;

  002ca	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  002cd	23 f8		 and	 edi, eax

; 247  :             huff += incr;

  002cf	03 fa		 add	 edi, edx

; 248  :         }
; 249  :         else

  002d1	33 d2		 xor	 edx, edx
  002d3	eb 04		 jmp	 SHORT $LN18@inflate_ta
$LN19@inflate_ta:

; 250  :             huff = 0;

  002d5	33 d2		 xor	 edx, edx
  002d7	8b fa		 mov	 edi, edx
$LN18@inflate_ta:

; 251  : 
; 252  :         /* go to next symbol, update count, len */
; 253  :         sym++;

  002d9	8b 4d 80	 mov	 ecx, DWORD PTR sym$2$[rbp-128]

; 254  :         if (--(count[len]) == 0) {

  002dc	41 8b c3	 mov	 eax, r11d
  002df	41 b8 ff ff 00
	00		 mov	 r8d, 65535		; 0000ffffH
  002e5	ff c1		 inc	 ecx
  002e7	66 44 01 44 45
	a8		 add	 WORD PTR count$[rbp+rax*2-128], r8w
  002ed	89 4d 80	 mov	 DWORD PTR sym$2$[rbp-128], ecx
  002f0	75 20		 jne	 SHORT $LN148@inflate_ta

; 255  :             if (len == max) break;

  002f2	45 3b da	 cmp	 r11d, r10d
  002f5	0f 84 f7 00 00
	00		 je	 $LN89@inflate_ta

; 256  :             len = lens[work[sym]];

  002fb	4c 8b 4d 68	 mov	 r9, QWORD PTR work$[rbp-128]
  002ff	48 8b 45 48	 mov	 rax, QWORD PTR lens$[rbp-128]
  00303	41 0f b7 0c 49	 movzx	 ecx, WORD PTR [r9+rcx*2]
  00308	44 0f b7 1c 48	 movzx	 r11d, WORD PTR [rax+rcx*2]
  0030d	8b 4d 80	 mov	 ecx, DWORD PTR sym$2$[rbp-128]
  00310	eb 04		 jmp	 SHORT $LN17@inflate_ta
$LN148@inflate_ta:
  00312	4c 8b 4d 68	 mov	 r9, QWORD PTR work$[rbp-128]
$LN17@inflate_ta:

; 257  :         }
; 258  : 
; 259  :         /* create new sub-table if needed */
; 260  :         if (len > root && (huff & mask) != low) {

  00316	8b 55 84	 mov	 edx, DWORD PTR end$1$[rbp-128]
  00319	45 3b dd	 cmp	 r11d, r13d
  0031c	0f 86 22 ff ff
	ff		 jbe	 $LL30@inflate_ta
  00322	8b 5d 8c	 mov	 ebx, DWORD PTR mask$1$[rbp-128]
  00325	23 df		 and	 ebx, edi
  00327	41 3b dc	 cmp	 ebx, r12d
  0032a	0f 84 10 ff ff
	ff		 je	 $LL147@inflate_ta

; 261  :             /* if first time, transition to sub-tables */
; 262  :             if (drop == 0)

  00330	85 f6		 test	 esi, esi

; 263  :                 drop = root;
; 264  : 
; 265  :             /* increment past last table */
; 266  :             next += min;            /* here min is 1 << curr */
; 267  : 
; 268  :             /* determine length of next table */
; 269  :             curr = len - drop;

  00332	45 8b cb	 mov	 r9d, r11d

; 270  :             left = (int)(1 << curr);

  00335	ba 01 00 00 00	 mov	 edx, 1
  0033a	41 0f 44 f5	 cmove	 esi, r13d
  0033e	41 8b c6	 mov	 eax, r14d
  00341	44 2b ce	 sub	 r9d, esi
  00344	4d 8d 3c 87	 lea	 r15, QWORD PTR [r15+rax*4]

; 271  :             while (curr + drop < max) {

  00348	46 8d 04 0e	 lea	 r8d, DWORD PTR [rsi+r9]
  0034c	41 8b c9	 mov	 ecx, r9d
  0034f	d3 e2		 shl	 edx, cl
  00351	45 3b c2	 cmp	 r8d, r10d
  00354	73 23		 jae	 SHORT $LN145@inflate_ta
  00356	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL13@inflate_ta:

; 272  :                 left -= count[curr + drop];

  00360	42 0f b7 4c 45
	a8		 movzx	 ecx, WORD PTR count$[rbp+r8*2-128]
  00366	2b d1		 sub	 edx, ecx

; 273  :                 if (left <= 0) break;

  00368	85 d2		 test	 edx, edx
  0036a	7e 0d		 jle	 SHORT $LN145@inflate_ta

; 274  :                 curr++;

  0036c	41 ff c0	 inc	 r8d
  0036f	41 ff c1	 inc	 r9d

; 275  :                 left <<= 1;

  00372	03 d2		 add	 edx, edx
  00374	45 3b c2	 cmp	 r8d, r10d
  00377	72 e7		 jb	 SHORT $LL13@inflate_ta
$LN145@inflate_ta:

; 276  :             }
; 277  : 
; 278  :             /* check for enough space */
; 279  :             used += 1U << curr;

  00379	44 8b 45 88	 mov	 r8d, DWORD PTR used$1$[rbp-128]

; 280  :             if ((type == LENS && used >= ENOUGH_LENS) ||
; 281  :                 (type == DISTS && used >= ENOUGH_DISTS))

  0037d	8b 45 40	 mov	 eax, DWORD PTR type$[rbp-128]
  00380	41 8b c9	 mov	 ecx, r9d
  00383	41 be 01 00 00
	00		 mov	 r14d, 1
  00389	41 d3 e6	 shl	 r14d, cl
  0038c	45 03 c6	 add	 r8d, r14d
  0038f	44 89 45 88	 mov	 DWORD PTR used$1$[rbp-128], r8d
  00393	83 f8 01	 cmp	 eax, 1
  00396	75 09		 jne	 SHORT $LN8@inflate_ta
  00398	41 81 f8 54 03
	00 00		 cmp	 r8d, 852		; 00000354H
  0039f	eb 0c		 jmp	 SHORT $LN159@inflate_ta
$LN8@inflate_ta:
  003a1	83 f8 02	 cmp	 eax, 2
  003a4	75 0d		 jne	 SHORT $LN10@inflate_ta
  003a6	41 81 f8 50 02
	00 00		 cmp	 r8d, 592		; 00000250H
$LN159@inflate_ta:
  003ad	0f 83 ba 00 00
	00		 jae	 $LN9@inflate_ta
$LN10@inflate_ta:

; 283  : 
; 284  :             /* point entry in root table to sub-table */
; 285  :             low = huff & mask;
; 286  :             (*table)[low].op = (unsigned char)curr;

  003b3	48 8d 14 9d 00
	00 00 00	 lea	 rdx, QWORD PTR [rbx*4]
  003bb	44 8b e3	 mov	 r12d, ebx
  003be	48 8b 5d 58	 mov	 rbx, QWORD PTR table$[rbp-128]
  003c2	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  003c5	44 88 0c 02	 mov	 BYTE PTR [rdx+rax], r9b

; 287  :             (*table)[low].bits = (unsigned char)root;

  003c9	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 288  :             (*table)[low].val = (unsigned short)(next - *table);
; 289  :         }
; 290  :     }

  003cc	4c 8b 4d 68	 mov	 r9, QWORD PTR work$[rbp-128]
  003d0	44 88 6c 02 01	 mov	 BYTE PTR [rdx+rax+1], r13b
  003d5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  003d8	49 8b c7	 mov	 rax, r15
  003db	48 2b c1	 sub	 rax, rcx
  003de	48 c1 f8 02	 sar	 rax, 2
  003e2	66 89 44 0a 02	 mov	 WORD PTR [rdx+rcx+2], ax
  003e7	8b 55 84	 mov	 edx, DWORD PTR end$1$[rbp-128]
  003ea	8b 4d 80	 mov	 ecx, DWORD PTR sym$2$[rbp-128]
  003ed	e9 52 fe ff ff	 jmp	 $LL30@inflate_ta
$LN89@inflate_ta:

; 291  : 
; 292  :     /*
; 293  :        Fill in rest of table for incomplete codes.  This loop is similar to the
; 294  :        loop above in incrementing huff for table indices.  It is assumed that
; 295  :        len is equal to curr + drop, so there is no loop needed to increment
; 296  :        through high index bits.  When the current sub-table is filled, the loop
; 297  :        drops back to the root table to fill in any remaining entries there.
; 298  :      */
; 299  :     here.op = (unsigned char)64;                /* invalid code marker */
; 300  :     here.bits = (unsigned char)(len - drop);

  003f2	41 0f b6 c3	 movzx	 eax, r11b
  003f6	c6 45 50 40	 mov	 BYTE PTR here$[rbp-128], 64 ; 00000040H

; 301  :     here.val = (unsigned short)0;

  003fa	66 89 55 52	 mov	 WORD PTR here$[rbp-126], dx
  003fe	40 2a c6	 sub	 al, sil
  00401	88 45 51	 mov	 BYTE PTR here$[rbp-127], al

; 302  :     while (huff != 0) {

  00404	85 ff		 test	 edi, edi
  00406	74 50		 je	 SHORT $LN146@inflate_ta
$LL7@inflate_ta:

; 303  :         /* when done with sub-table, drop back to root table */
; 304  :         if (drop != 0 && (huff & mask) != low) {

  00408	85 f6		 test	 esi, esi
  0040a	74 16		 je	 SHORT $LN5@inflate_ta
  0040c	8b 45 8c	 mov	 eax, DWORD PTR mask$1$[rbp-128]
  0040f	23 c7		 and	 eax, edi
  00411	41 3b c4	 cmp	 eax, r12d
  00414	74 0c		 je	 SHORT $LN5@inflate_ta

; 305  :             drop = 0;
; 306  :             len = root;
; 307  :             next = *table;

  00416	4c 8b 3b	 mov	 r15, QWORD PTR [rbx]
  00419	8b f2		 mov	 esi, edx
  0041b	45 8b dd	 mov	 r11d, r13d

; 308  :             here.bits = (unsigned char)len;

  0041e	44 88 6d 51	 mov	 BYTE PTR here$[rbp-127], r13b
$LN5@inflate_ta:

; 309  :         }
; 310  : 
; 311  :         /* put invalid code marker in table */
; 312  :         next[huff >> drop] = here;

  00422	8b 45 50	 mov	 eax, DWORD PTR here$[rbp-128]
  00425	8b ce		 mov	 ecx, esi
  00427	8b d7		 mov	 edx, edi
  00429	48 d3 ea	 shr	 rdx, cl

; 313  : 
; 314  :         /* backwards increment the len-bit code huff */
; 315  :         incr = 1U << (len - 1);

  0042c	41 8d 4b ff	 lea	 ecx, DWORD PTR [r11-1]
  00430	41 89 04 97	 mov	 DWORD PTR [r15+rdx*4], eax
  00434	b8 01 00 00 00	 mov	 eax, 1
  00439	d3 e0		 shl	 eax, cl

; 316  :         while (huff & incr)

  0043b	85 c7		 test	 eax, edi
  0043d	74 07		 je	 SHORT $LN3@inflate_ta
  0043f	90		 npad	 1
$LL4@inflate_ta:

; 317  :             incr >>= 1;

  00440	d1 e8		 shr	 eax, 1
  00442	85 c7		 test	 eax, edi
  00444	75 fa		 jne	 SHORT $LL4@inflate_ta
$LN3@inflate_ta:

; 318  :         if (incr != 0) {

  00446	85 c0		 test	 eax, eax
  00448	74 0e		 je	 SHORT $LN146@inflate_ta

; 319  :             huff &= incr - 1;

  0044a	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  0044d	ba 00 00 00 00	 mov	 edx, 0
  00452	23 f9		 and	 edi, ecx

; 320  :             huff += incr;

  00454	03 f8		 add	 edi, eax
  00456	75 b0		 jne	 SHORT $LL7@inflate_ta
$LN146@inflate_ta:

; 321  :         }
; 322  :         else
; 323  :             huff = 0;
; 324  :     }
; 325  : 
; 326  :     /* set return parameters */
; 327  :     *table += used;

  00458	8b 45 88	 mov	 eax, DWORD PTR used$1$[rbp-128]
  0045b	48 c1 e0 02	 shl	 rax, 2
  0045f	48 01 03	 add	 QWORD PTR [rbx], rax

; 328  :     *bits = root;

  00462	48 8b 45 60	 mov	 rax, QWORD PTR bits$[rbp-128]
  00466	44 89 28	 mov	 DWORD PTR [rax], r13d

; 329  :     return 0;

  00469	33 c0		 xor	 eax, eax
  0046b	eb 05		 jmp	 SHORT $LN155@inflate_ta
$LN9@inflate_ta:

; 282  :                 return 1;

  0046d	b8 01 00 00 00	 mov	 eax, 1
$LN155@inflate_ta:
  00472	4c 8b 7c 24 78	 mov	 r15, QWORD PTR [rsp+120]
$LN69@inflate_ta:

; 330  : }

  00477	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0047e	41 5e		 pop	 r14
  00480	41 5d		 pop	 r13
  00482	41 5c		 pop	 r12
  00484	5f		 pop	 rdi
  00485	5e		 pop	 rsi
  00486	5b		 pop	 rbx
  00487	5d		 pop	 rbp
  00488	c3		 ret	 0
inflate_table ENDP
_TEXT	ENDS
END
