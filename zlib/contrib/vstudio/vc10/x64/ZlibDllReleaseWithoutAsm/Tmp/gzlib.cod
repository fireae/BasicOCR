; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	gzdopen
PUBLIC	gzbuffer
PUBLIC	gzrewind
PUBLIC	gzeof
PUBLIC	gzerror
PUBLIC	gzclearerr
PUBLIC	gzopen
PUBLIC	gzseek
PUBLIC	gztell
PUBLIC	gzoffset
PUBLIC	gzopen64
PUBLIC	gzseek64
PUBLIC	gztell64
PUBLIC	gzoffset64
PUBLIC	gz_error
PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
EXTRN	__imp_sprintf:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_lseek:PROC
EXTRN	__imp_open:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzdopen DD imagerel $LN6
	DD	imagerel $LN6+125
	DD	imagerel $unwind$gzdopen
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzrewind DD imagerel $LN8
	DD	imagerel $LN8+73
	DD	imagerel $unwind$gzrewind
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzseek64 DD imagerel $LN26
	DD	imagerel $LN26+83
	DD	imagerel $unwind$gzseek64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gzseek64 DD imagerel $LN26+83
	DD	imagerel $LN26+185
	DD	imagerel $chain$0$gzseek64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$gzseek64 DD imagerel $LN26+185
	DD	imagerel $LN26+234
	DD	imagerel $chain$2$gzseek64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$gzseek64 DD imagerel $LN26+234
	DD	imagerel $LN26+311
	DD	imagerel $chain$4$gzseek64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzoffset64 DD imagerel $LN9
	DD	imagerel $LN9+76
	DD	imagerel $unwind$gzoffset64
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_error DD imagerel $LN22
	DD	imagerel $LN22+320
	DD	imagerel $unwind$gz_error
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_reset DD imagerel gz_reset
	DD	imagerel gz_reset+67
	DD	imagerel $unwind$gz_reset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_open DD imagerel gz_open
	DD	imagerel gz_open+55
	DD	imagerel $unwind$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gz_open DD imagerel gz_open+55
	DD	imagerel gz_open+404
	DD	imagerel $chain$0$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gz_open DD imagerel gz_open+404
	DD	imagerel gz_open+425
	DD	imagerel $chain$1$gz_open
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$gz_open DD imagerel gz_open+425
	DD	imagerel gz_open+613
	DD	imagerel $chain$2$gz_open
pdata	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@ DB 'out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@ DB '<fd:%d>', 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$gz_open DD 020021H
	DD	06e400H
	DD	imagerel gz_open
	DD	imagerel gz_open+55
	DD	imagerel $unwind$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gz_open DD 021H
	DD	imagerel gz_open
	DD	imagerel gz_open+55
	DD	imagerel $unwind$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gz_open DD 020521H
	DD	06e405H
	DD	imagerel gz_open
	DD	imagerel gz_open+55
	DD	imagerel $unwind$gz_open
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_open DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_reset DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_error DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzoffset64 DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$gzseek64 DD 020021H
	DD	066400H
	DD	imagerel $LN26
	DD	imagerel $LN26+83
	DD	imagerel $unwind$gzseek64
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$gzseek64 DD 020021H
	DD	066400H
	DD	imagerel $LN26
	DD	imagerel $LN26+83
	DD	imagerel $unwind$gzseek64
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gzseek64 DD 020521H
	DD	066405H
	DD	imagerel $LN26
	DD	imagerel $LN26+83
	DD	imagerel $unwind$gzseek64
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzseek64 DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzrewind DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzdopen DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gz_open
_TEXT	SEGMENT
path$ = 48
fd$ = 56
mode$ = 64
gz_open	PROC						; COMDAT

; 91   : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	48 8b f1	 mov	 rsi, rcx

; 92   :     gz_statep state;
; 93   : 
; 94   :     /* allocate gzFile structure to return */
; 95   :     state = malloc(sizeof(gz_state));

  00017	b9 c8 00 00 00	 mov	 ecx, 200		; 000000c8H
  0001c	49 8b f8	 mov	 rdi, r8
  0001f	8b ea		 mov	 ebp, edx
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00027	48 8b d8	 mov	 rbx, rax

; 96   :     if (state == NULL)

  0002a	48 85 c0	 test	 rax, rax
  0002d	0f 84 61 01 00
	00		 je	 $LN24@gz_open
$LN23@gz_open:

; 97   :         return NULL;
; 98   :     state->size = 0;            /* no buffers allocated yet */
; 99   :     state->want = GZBUFSIZE;    /* requested buffer size */
; 100  :     state->msg = NULL;          /* no error message yet */
; 101  : 
; 102  :     /* interpret mode */
; 103  :     state->mode = GZ_NONE;
; 104  :     state->level = Z_DEFAULT_COMPRESSION;

  00033	48 83 ca ff	 or	 rdx, -1
  00037	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14
  0003c	45 33 f6	 xor	 r14d, r14d
  0003f	44 89 70 14	 mov	 DWORD PTR [rax+20], r14d
  00043	4c 89 70 68	 mov	 QWORD PTR [rax+104], r14
  00047	44 89 30	 mov	 DWORD PTR [rax], r14d

; 105  :     state->strategy = Z_DEFAULT_STRATEGY;

  0004a	44 89 70 54	 mov	 DWORD PTR [rax+84], r14d
  0004e	c7 40 18 00 20
	00 00		 mov	 DWORD PTR [rax+24], 8192 ; 00002000H
  00055	89 50 50	 mov	 DWORD PTR [rax+80], edx

; 106  :     while (*mode) {

  00058	0f b6 0f	 movzx	 ecx, BYTE PTR [rdi]
  0005b	84 c9		 test	 cl, cl
  0005d	0f 84 21 01 00
	00		 je	 $LN36@gz_open
  00063	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:__ImageBase
  0006a	66 0f 1f 44 00
	00		 npad	 6
$LL22@gz_open:
  00070	8d 41 d0	 lea	 eax, DWORD PTR [rcx-48]
  00073	3c 09		 cmp	 al, 9

; 107  :         if (*mode >= '0' && *mode <= '9')
; 108  :             state->level = *mode - '0';

  00075	0f be c1	 movsx	 eax, cl
  00078	77 08		 ja	 SHORT $LN20@gz_open
  0007a	83 e8 30	 sub	 eax, 48			; 00000030H
  0007d	89 43 50	 mov	 DWORD PTR [rbx+80], eax

; 109  :         else

  00080	eb 5a		 jmp	 SHORT $LN7@gz_open
$LN20@gz_open:

; 110  :             switch (*mode) {

  00082	83 c0 d5	 add	 eax, -43		; ffffffffffffffd5H
  00085	83 f8 4c	 cmp	 eax, 76			; 0000004cH
  00088	77 52		 ja	 SHORT $LN7@gz_open
  0008a	48 98		 cdqe
  0008c	41 0f b6 84 00
	00 00 00 00	 movzx	 eax, BYTE PTR $LN39@gz_open[r8+rax]
  00095	41 8b 8c 80 00
	00 00 00	 mov	 ecx, DWORD PTR $LN40@gz_open[r8+rax*4]
  0009d	49 03 c8	 add	 rcx, r8
  000a0	ff e1		 jmp	 rcx
$LN16@gz_open:

; 111  :             case 'r':
; 112  :                 state->mode = GZ_READ;

  000a2	c7 03 4f 1c 00
	00		 mov	 DWORD PTR [rbx], 7247	; 00001c4fH

; 113  :                 break;

  000a8	eb 32		 jmp	 SHORT $LN7@gz_open
$LN15@gz_open:

; 114  : #ifndef NO_GZCOMPRESS
; 115  :             case 'w':
; 116  :                 state->mode = GZ_WRITE;

  000aa	c7 03 b1 79 00
	00		 mov	 DWORD PTR [rbx], 31153	; 000079b1H

; 117  :                 break;

  000b0	eb 2a		 jmp	 SHORT $LN7@gz_open
$LN14@gz_open:

; 118  :             case 'a':
; 119  :                 state->mode = GZ_APPEND;

  000b2	c7 03 01 00 00
	00		 mov	 DWORD PTR [rbx], 1

; 120  :                 break;

  000b8	eb 22		 jmp	 SHORT $LN7@gz_open
$LN11@gz_open:

; 121  : #endif
; 122  :             case '+':       /* can't read and write at the same time */
; 123  :                 free(state);
; 124  :                 return NULL;
; 125  :             case 'b':       /* ignore -- will request binary anyway */
; 126  :                 break;
; 127  :             case 'f':
; 128  :                 state->strategy = Z_FILTERED;

  000ba	c7 43 54 01 00
	00 00		 mov	 DWORD PTR [rbx+84], 1

; 129  :                 break;

  000c1	eb 19		 jmp	 SHORT $LN7@gz_open
$LN10@gz_open:

; 130  :             case 'h':
; 131  :                 state->strategy = Z_HUFFMAN_ONLY;

  000c3	c7 43 54 02 00
	00 00		 mov	 DWORD PTR [rbx+84], 2

; 132  :                 break;

  000ca	eb 10		 jmp	 SHORT $LN7@gz_open
$LN9@gz_open:

; 133  :             case 'R':
; 134  :                 state->strategy = Z_RLE;

  000cc	c7 43 54 03 00
	00 00		 mov	 DWORD PTR [rbx+84], 3

; 135  :                 break;

  000d3	eb 07		 jmp	 SHORT $LN7@gz_open
$LN8@gz_open:

; 136  :             case 'F':
; 137  :                 state->strategy = Z_FIXED;

  000d5	c7 43 54 04 00
	00 00		 mov	 DWORD PTR [rbx+84], 4
$LN7@gz_open:

; 106  :     while (*mode) {

  000dc	0f b6 4f 01	 movzx	 ecx, BYTE PTR [rdi+1]

; 138  :             default:        /* could consider as an error, but just ignore */
; 139  :                 ;
; 140  :             }
; 141  :         mode++;

  000e0	48 ff c7	 inc	 rdi
  000e3	84 c9		 test	 cl, cl
  000e5	75 89		 jne	 SHORT $LL22@gz_open

; 142  :     }
; 143  : 
; 144  :     /* must provide an "r", "w", or "a" */
; 145  :     if (state->mode == GZ_NONE) {

  000e7	44 39 33	 cmp	 DWORD PTR [rbx], r14d
  000ea	0f 84 94 00 00
	00		 je	 $LN36@gz_open
$LL38@gz_open:

; 148  :     }
; 149  : 
; 150  :     /* save the path name for error messages */
; 151  :     state->path = malloc(strlen(path) + 1);

  000f0	44 38 74 16 01	 cmp	 BYTE PTR [rsi+rdx+1], r14b
  000f5	48 8d 52 01	 lea	 rdx, QWORD PTR [rdx+1]
  000f9	75 f5		 jne	 SHORT $LL38@gz_open
  000fb	48 8d 4a 01	 lea	 rcx, QWORD PTR [rdx+1]
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00105	48 8b c8	 mov	 rcx, rax
  00108	48 89 43 08	 mov	 QWORD PTR [rbx+8], rax

; 152  :     if (state->path == NULL) {

  0010c	48 85 c0	 test	 rax, rax
  0010f	74 73		 je	 SHORT $LN36@gz_open

; 153  :         free(state);
; 154  :         return NULL;
; 155  :     }
; 156  :     strcpy(state->path, path);

  00111	48 8b d6	 mov	 rdx, rsi
  00114	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL26@gz_open:
  00120	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00123	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]
  00127	48 8d 52 01	 lea	 rdx, QWORD PTR [rdx+1]
  0012b	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  0012e	84 c0		 test	 al, al
  00130	75 ee		 jne	 SHORT $LL26@gz_open

; 157  : 
; 158  :     /* open the file with the appropriate mode (or just use fd) */
; 159  :     state->fd = fd != -1 ? fd :
; 160  :         open(path,
; 161  : #ifdef O_LARGEFILE
; 162  :             O_LARGEFILE |
; 163  : #endif
; 164  : #ifdef O_BINARY
; 165  :             O_BINARY |
; 166  : #endif
; 167  :             (state->mode == GZ_READ ?
; 168  :                 O_RDONLY :
; 169  :                 (O_WRONLY | O_CREAT | (
; 170  :                     state->mode == GZ_WRITE ?
; 171  :                         O_TRUNC :
; 172  :                         O_APPEND))),
; 173  :             0666);

  00132	83 fd ff	 cmp	 ebp, -1
  00135	75 3b		 jne	 SHORT $LN30@gz_open
  00137	8b 03		 mov	 eax, DWORD PTR [rbx]
  00139	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0013e	75 05		 jne	 SHORT $LN27@gz_open
  00140	41 8b d6	 mov	 edx, r14d
  00143	eb 18		 jmp	 SHORT $LN28@gz_open
$LN27@gz_open:
  00145	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  0014a	ba 08 00 00 00	 mov	 edx, 8
  0014f	b9 00 02 00 00	 mov	 ecx, 512		; 00000200H
  00154	0f 44 d1	 cmove	 edx, ecx
  00157	81 ca 01 01 00
	00		 or	 edx, 257		; 00000101H
$LN28@gz_open:
  0015d	0f ba ea 0f	 bts	 edx, 15
  00161	41 b8 b6 01 00
	00		 mov	 r8d, 438		; 000001b6H
  00167	48 8b ce	 mov	 rcx, rsi
  0016a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_open
  00170	8b e8		 mov	 ebp, eax
$LN30@gz_open:
  00172	89 6b 04	 mov	 DWORD PTR [rbx+4], ebp

; 174  :     if (state->fd == -1) {

  00175	83 fd ff	 cmp	 ebp, -1
  00178	75 2f		 jne	 SHORT $LN4@gz_open

; 175  :         free(state->path);

  0017a	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0017e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN36@gz_open:

; 146  :         free(state);

  00184	48 8b cb	 mov	 rcx, rbx
  00187	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 147  :         return NULL;

  0018d	33 c0		 xor	 eax, eax
$LN42@gz_open:
  0018f	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]
$LN24@gz_open:

; 193  : }

  00194	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00199	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0019e	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  001a3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001a7	5f		 pop	 rdi
  001a8	c3		 ret	 0
$LN4@gz_open:

; 176  :         free(state);
; 177  :         return NULL;
; 178  :     }
; 179  :     if (state->mode == GZ_APPEND)

  001a9	8b 03		 mov	 eax, DWORD PTR [rbx]
  001ab	83 f8 01	 cmp	 eax, 1
  001ae	75 13		 jne	 SHORT $LN3@gz_open

; 186  :     }
; 187  : 
; 188  :     /* initialize stream */
; 189  :     gz_reset(state);

  001b0	48 8b cb	 mov	 rcx, rbx
  001b3	c7 03 b1 79 00
	00		 mov	 DWORD PTR [rbx], 31153	; 000079b1H
  001b9	e8 00 00 00 00	 call	 gz_reset

; 190  : 
; 191  :     /* return stream */
; 192  :     return (gzFile)state;

  001be	48 8b c3	 mov	 rax, rbx
  001c1	eb cc		 jmp	 SHORT $LN42@gz_open
$LN3@gz_open:

; 180  :         state->mode = GZ_WRITE;         /* simplify later checks */
; 181  : 
; 182  :     /* save the current position for rewinding (only if reading) */
; 183  :     if (state->mode == GZ_READ) {

  001c3	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  001c8	75 1a		 jne	 SHORT $LN1@gz_open

; 184  :         state->start = LSEEK(state->fd, 0, SEEK_CUR);

  001ca	33 d2		 xor	 edx, edx
  001cc	8b cd		 mov	 ecx, ebp
  001ce	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  001d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_lseek
  001d8	89 43 40	 mov	 DWORD PTR [rbx+64], eax

; 185  :         if (state->start == -1) state->start = 0;

  001db	83 f8 ff	 cmp	 eax, -1
  001de	75 04		 jne	 SHORT $LN1@gz_open
  001e0	44 89 73 40	 mov	 DWORD PTR [rbx+64], r14d
$LN1@gz_open:

; 186  :     }
; 187  : 
; 188  :     /* initialize stream */
; 189  :     gz_reset(state);

  001e4	48 8b cb	 mov	 rcx, rbx
  001e7	e8 00 00 00 00	 call	 gz_reset

; 190  : 
; 191  :     /* return stream */
; 192  :     return (gzFile)state;

  001ec	48 8b c3	 mov	 rax, rbx
  001ef	eb 9e		 jmp	 SHORT $LN42@gz_open
  001f1	0f 1f 00	 npad	 3
$LN40@gz_open:

; 193  : }

  001f4	00 00 00 00	 DD	 $LN36@gz_open
  001f8	00 00 00 00	 DD	 $LN8@gz_open
  001fc	00 00 00 00	 DD	 $LN9@gz_open
  00200	00 00 00 00	 DD	 $LN14@gz_open
  00204	00 00 00 00	 DD	 $LN11@gz_open
  00208	00 00 00 00	 DD	 $LN10@gz_open
  0020c	00 00 00 00	 DD	 $LN16@gz_open
  00210	00 00 00 00	 DD	 $LN15@gz_open
  00214	00 00 00 00	 DD	 $LN7@gz_open
$LN39@gz_open:
  00218	00		 DB	 0
  00219	08		 DB	 8
  0021a	08		 DB	 8
  0021b	08		 DB	 8
  0021c	08		 DB	 8
  0021d	08		 DB	 8
  0021e	08		 DB	 8
  0021f	08		 DB	 8
  00220	08		 DB	 8
  00221	08		 DB	 8
  00222	08		 DB	 8
  00223	08		 DB	 8
  00224	08		 DB	 8
  00225	08		 DB	 8
  00226	08		 DB	 8
  00227	08		 DB	 8
  00228	08		 DB	 8
  00229	08		 DB	 8
  0022a	08		 DB	 8
  0022b	08		 DB	 8
  0022c	08		 DB	 8
  0022d	08		 DB	 8
  0022e	08		 DB	 8
  0022f	08		 DB	 8
  00230	08		 DB	 8
  00231	08		 DB	 8
  00232	08		 DB	 8
  00233	01		 DB	 1
  00234	08		 DB	 8
  00235	08		 DB	 8
  00236	08		 DB	 8
  00237	08		 DB	 8
  00238	08		 DB	 8
  00239	08		 DB	 8
  0023a	08		 DB	 8
  0023b	08		 DB	 8
  0023c	08		 DB	 8
  0023d	08		 DB	 8
  0023e	08		 DB	 8
  0023f	02		 DB	 2
  00240	08		 DB	 8
  00241	08		 DB	 8
  00242	08		 DB	 8
  00243	08		 DB	 8
  00244	08		 DB	 8
  00245	08		 DB	 8
  00246	08		 DB	 8
  00247	08		 DB	 8
  00248	08		 DB	 8
  00249	08		 DB	 8
  0024a	08		 DB	 8
  0024b	08		 DB	 8
  0024c	08		 DB	 8
  0024d	08		 DB	 8
  0024e	03		 DB	 3
  0024f	08		 DB	 8
  00250	08		 DB	 8
  00251	08		 DB	 8
  00252	08		 DB	 8
  00253	04		 DB	 4
  00254	08		 DB	 8
  00255	05		 DB	 5
  00256	08		 DB	 8
  00257	08		 DB	 8
  00258	08		 DB	 8
  00259	08		 DB	 8
  0025a	08		 DB	 8
  0025b	08		 DB	 8
  0025c	08		 DB	 8
  0025d	08		 DB	 8
  0025e	08		 DB	 8
  0025f	06		 DB	 6
  00260	08		 DB	 8
  00261	08		 DB	 8
  00262	08		 DB	 8
  00263	08		 DB	 8
  00264	07		 DB	 7
gz_open	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gz_reset
_TEXT	SEGMENT
state$ = 48
gz_reset PROC						; COMDAT

; 73   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 74   :     if (state->mode == GZ_READ) {   /* for reading ... */

  0000a	33 ff		 xor	 edi, edi
  0000c	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [rcx], 7247	; 00001c4fH
  00012	48 8b d9	 mov	 rbx, rcx
  00015	75 0e		 jne	 SHORT $LN1@gz_reset

; 75   :         state->have = 0;            /* no output data available */

  00017	48 89 79 38	 mov	 QWORD PTR [rcx+56], rdi

; 76   :         state->eof = 0;             /* not at end of file */
; 77   :         state->how = LOOK;          /* look for gzip header */

  0001b	89 79 48	 mov	 DWORD PTR [rcx+72], edi

; 78   :         state->direct = 1;          /* default for empty file */

  0001e	c7 41 4c 01 00
	00 00		 mov	 DWORD PTR [rcx+76], 1
$LN1@gz_reset:

; 79   :     }
; 80   :     state->seek = 0;                /* no seek request pending */
; 81   :     gz_error(state, Z_OK, NULL);    /* clear error */

  00025	45 33 c0	 xor	 r8d, r8d
  00028	33 d2		 xor	 edx, edx
  0002a	89 79 5c	 mov	 DWORD PTR [rcx+92], edi
  0002d	e8 00 00 00 00	 call	 gz_error

; 82   :     state->pos = 0;                 /* no uncompressed data yet */

  00032	89 7b 10	 mov	 DWORD PTR [rbx+16], edi

; 83   :     state->strm.avail_in = 0;       /* no input data yet */

  00035	89 7b 78	 mov	 DWORD PTR [rbx+120], edi

; 84   : }

  00038	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
gz_reset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gz_error
_TEXT	SEGMENT
state$ = 48
err$ = 56
msg$ = 64
gz_error PROC						; COMDAT

; 489  : {

$LN22:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f9	 mov	 rdi, rcx

; 490  :     /* free previously allocated message and clear */
; 491  :     if (state->msg != NULL) {

  00012	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00016	49 8b f0	 mov	 rsi, r8
  00019	8b da		 mov	 ebx, edx
  0001b	48 85 c9	 test	 rcx, rcx
  0001e	74 14		 je	 SHORT $LN5@gz_error

; 492  :         if (state->err != Z_MEM_ERROR)

  00020	83 7f 60 fc	 cmp	 DWORD PTR [rdi+96], -4
  00024	74 06		 je	 SHORT $LN4@gz_error

; 493  :             free(state->msg);

  00026	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@gz_error:

; 494  :         state->msg = NULL;

  0002c	48 c7 47 68 00
	00 00 00	 mov	 QWORD PTR [rdi+104], 0
$LN5@gz_error:

; 495  :     }
; 496  : 
; 497  :     /* set error code, and if no message, then done */
; 498  :     state->err = err;

  00034	89 5f 60	 mov	 DWORD PTR [rdi+96], ebx

; 499  :     if (msg == NULL)

  00037	48 85 f6	 test	 rsi, rsi
  0003a	0f 84 f0 00 00
	00		 je	 $LN6@gz_error

; 500  :         return;
; 501  : 
; 502  :     /* for an out of memory error, save as static string */
; 503  :     if (err == Z_MEM_ERROR) {

  00040	83 fb fc	 cmp	 ebx, -4
  00043	75 14		 jne	 SHORT $LN2@gz_error

; 504  :         state->msg = (char *)msg;

  00045	48 89 77 68	 mov	 QWORD PTR [rdi+104], rsi

; 517  :     return;
; 518  : }

  00049	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
$LN2@gz_error:

; 505  :         return;
; 506  :     }
; 507  : 
; 508  :     /* construct error message with path */
; 509  :     if ((state->msg = malloc(strlen(state->path) + strlen(msg) + 3)) == NULL) {

  00059	48 8b 5f 08	 mov	 rbx, QWORD PTR [rdi+8]
  0005d	48 83 c8 ff	 or	 rax, -1
  00061	48 8b c8	 mov	 rcx, rax
$LL15@gz_error:
  00064	48 ff c1	 inc	 rcx
  00067	80 3c 0b 00	 cmp	 BYTE PTR [rbx+rcx], 0
  0006b	75 f7		 jne	 SHORT $LL15@gz_error
  0006d	0f 1f 00	 npad	 3
$LL14@gz_error:
  00070	48 ff c0	 inc	 rax
  00073	80 3c 06 00	 cmp	 BYTE PTR [rsi+rax], 0
  00077	75 f7		 jne	 SHORT $LL14@gz_error
  00079	48 83 c0 03	 add	 rax, 3
  0007d	48 03 c8	 add	 rcx, rax
  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00086	48 8b c8	 mov	 rcx, rax
  00089	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax
  0008d	48 85 c0	 test	 rax, rax
  00090	75 2e		 jne	 SHORT $LL1@gz_error

; 510  :         state->err = Z_MEM_ERROR;
; 511  :         state->msg = (char *)"out of memory";

  00092	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00099	c7 47 60 fc ff
	ff ff		 mov	 DWORD PTR [rdi+96], -4
  000a0	48 89 47 68	 mov	 QWORD PTR [rdi+104], rax

; 517  :     return;
; 518  : }

  000a4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a9	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000ae	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b2	5f		 pop	 rdi
  000b3	c3		 ret	 0
  000b4	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL1@gz_error:

; 512  :         return;
; 513  :     }
; 514  :     strcpy(state->msg, state->path);

  000c0	0f b6 03	 movzx	 eax, BYTE PTR [rbx]
  000c3	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]
  000c7	48 8d 5b 01	 lea	 rbx, QWORD PTR [rbx+1]
  000cb	88 41 ff	 mov	 BYTE PTR [rcx-1], al
  000ce	84 c0		 test	 al, al
  000d0	75 ee		 jne	 SHORT $LL1@gz_error

; 515  :     strcat(state->msg, ": ");

  000d2	48 8b 4f 68	 mov	 rcx, QWORD PTR [rdi+104]
  000d6	48 ff c9	 dec	 rcx
  000d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL13@gz_error:
  000e0	80 79 01 00	 cmp	 BYTE PTR [rcx+1], 0
  000e4	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]
  000e8	75 f6		 jne	 SHORT $LL13@gz_error
  000ea	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ??_C@_02LMMGGCAJ@?3?5?$AA@
  000f1	66 89 01	 mov	 WORD PTR [rcx], ax
  000f4	0f b6 05 02 00
	00 00		 movzx	 eax, BYTE PTR ??_C@_02LMMGGCAJ@?3?5?$AA@+2
  000fb	88 41 02	 mov	 BYTE PTR [rcx+2], al

; 516  :     strcat(state->msg, msg);

  000fe	48 8b 4f 68	 mov	 rcx, QWORD PTR [rdi+104]
  00102	48 ff c9	 dec	 rcx
$LL11@gz_error:
  00105	80 79 01 00	 cmp	 BYTE PTR [rcx+1], 0
  00109	48 8d 49 01	 lea	 rcx, QWORD PTR [rcx+1]
  0010d	75 f6		 jne	 SHORT $LL11@gz_error
  0010f	33 d2		 xor	 edx, edx
  00111	66 66 66 66 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL12@gz_error:
  00120	0f b6 04 16	 movzx	 eax, BYTE PTR [rsi+rdx]
  00124	48 8d 52 01	 lea	 rdx, QWORD PTR [rdx+1]
  00128	88 44 11 ff	 mov	 BYTE PTR [rcx+rdx-1], al
  0012c	84 c0		 test	 al, al
  0012e	75 f0		 jne	 SHORT $LL12@gz_error
$LN6@gz_error:

; 517  :     return;
; 518  : }

  00130	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00135	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0013a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0013e	5f		 pop	 rdi
  0013f	c3		 ret	 0
gz_error ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gzoffset64
_TEXT	SEGMENT
file$ = 48
gzoffset64 PROC						; COMDAT

; 392  : {

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 393  :     z_off64_t offset;
; 394  :     gz_statep state;
; 395  : 
; 396  :     /* get internal structure and check integrity */
; 397  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 09		 jne	 SHORT $LN4@gzoffset64
$LN7@gzoffset64:

; 398  :         return -1;

  0000e	83 c8 ff	 or	 eax, -1

; 409  :     return offset;
; 410  : }

  00011	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00015	5b		 pop	 rbx
  00016	c3		 ret	 0
$LN4@gzoffset64:

; 399  :     state = (gz_statep)file;
; 400  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00017	8b 01		 mov	 eax, DWORD PTR [rcx]
  00019	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0001e	74 07		 je	 SHORT $LN3@gzoffset64
  00020	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  00025	75 e7		 jne	 SHORT $LN7@gzoffset64
$LN3@gzoffset64:

; 401  :         return -1;
; 402  : 
; 403  :     /* compute and return effective offset in file */
; 404  :     offset = LSEEK(state->fd, 0, SEEK_CUR);

  00027	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  0002a	33 d2		 xor	 edx, edx
  0002c	44 8d 42 01	 lea	 r8d, QWORD PTR [rdx+1]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_lseek

; 405  :     if (offset == -1)

  00036	83 f8 ff	 cmp	 eax, -1
  00039	74 d3		 je	 SHORT $LN7@gzoffset64

; 406  :         return -1;
; 407  :     if (state->mode == GZ_READ)             /* reading */

  0003b	81 3b 4f 1c 00
	00		 cmp	 DWORD PTR [rbx], 7247	; 00001c4fH
  00041	75 03		 jne	 SHORT $LN1@gzoffset64

; 408  :         offset -= state->strm.avail_in;     /* don't count buffered input */

  00043	2b 43 78	 sub	 eax, DWORD PTR [rbx+120]
$LN1@gzoffset64:

; 409  :     return offset;
; 410  : }

  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5b		 pop	 rbx
  0004b	c3		 ret	 0
gzoffset64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gztell64
_TEXT	SEGMENT
file$ = 8
gztell64 PROC						; COMDAT

; 366  :     gz_statep state;
; 367  : 
; 368  :     /* get internal structure and check integrity */
; 369  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 04		 jne	 SHORT $LN2@gztell64
$LN7@gztell64:

; 370  :         return -1;

  00005	83 c8 ff	 or	 eax, -1

; 377  : }

  00008	c3		 ret	 0
$LN2@gztell64:

; 371  :     state = (gz_statep)file;
; 372  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00009	8b 01		 mov	 eax, DWORD PTR [rcx]
  0000b	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00010	74 07		 je	 SHORT $LN1@gztell64
  00012	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  00017	75 ec		 jne	 SHORT $LN7@gztell64
$LN1@gztell64:

; 373  :         return -1;
; 374  : 
; 375  :     /* return position */
; 376  :     return state->pos + (state->seek ? state->skip : 0);

  00019	83 79 5c 00	 cmp	 DWORD PTR [rcx+92], 0
  0001d	74 09		 je	 SHORT $LN5@gztell64
  0001f	8b 51 58	 mov	 edx, DWORD PTR [rcx+88]
  00022	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  00025	03 c2		 add	 eax, edx

; 377  : }

  00027	c3		 ret	 0
$LN5@gztell64:

; 373  :         return -1;
; 374  : 
; 375  :     /* return position */
; 376  :     return state->pos + (state->seek ? state->skip : 0);

  00028	8b 41 10	 mov	 eax, DWORD PTR [rcx+16]
  0002b	33 d2		 xor	 edx, edx
  0002d	03 c2		 add	 eax, edx

; 377  : }

  0002f	c3		 ret	 0
gztell64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gzseek64
_TEXT	SEGMENT
file$ = 48
offset$ = 56
whence$ = 64
gzseek64 PROC						; COMDAT

; 279  : {

$LN26:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b fa		 mov	 edi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 280  :     unsigned n;
; 281  :     z_off64_t ret;
; 282  :     gz_statep state;
; 283  : 
; 284  :     /* get internal structure and check integrity */
; 285  :     if (file == NULL)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	75 0e		 jne	 SHORT $LN15@gzseek64
$LN24@gzseek64:

; 286  :         return -1;

  00014	83 c8 ff	 or	 eax, -1

; 348  : }

  00017	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5f		 pop	 rdi
  00021	c3		 ret	 0
$LN15@gzseek64:

; 287  :     state = (gz_statep)file;
; 288  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00022	8b 11		 mov	 edx, DWORD PTR [rcx]
  00024	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH
  0002a	74 08		 je	 SHORT $LN14@gzseek64
  0002c	81 fa b1 79 00
	00		 cmp	 edx, 31153		; 000079b1H
  00032	75 e0		 jne	 SHORT $LN24@gzseek64
$LN14@gzseek64:

; 289  :         return -1;
; 290  : 
; 291  :     /* check that there's no error */
; 292  :     if (state->err != Z_OK)

  00034	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00038	75 da		 jne	 SHORT $LN24@gzseek64

; 293  :         return -1;
; 294  : 
; 295  :     /* can only seek from start or relative to current position */
; 296  :     if (whence != SEEK_SET && whence != SEEK_CUR)

  0003a	45 85 c0	 test	 r8d, r8d
  0003d	74 11		 je	 SHORT $LN21@gzseek64
  0003f	41 83 f8 01	 cmp	 r8d, 1
  00043	75 cf		 jne	 SHORT $LN24@gzseek64

; 302  :     else if (state->seek)

  00045	83 79 5c 00	 cmp	 DWORD PTR [rcx+92], 0
  00049	74 08		 je	 SHORT $LN9@gzseek64

; 303  :         offset += state->skip;

  0004b	03 79 58	 add	 edi, DWORD PTR [rcx+88]
  0004e	eb 03		 jmp	 SHORT $LN9@gzseek64
$LN21@gzseek64:

; 297  :         return -1;
; 298  : 
; 299  :     /* normalize offset to a SEEK_CUR specification */
; 300  :     if (whence == SEEK_SET)
; 301  :         offset -= state->pos;

  00050	2b 79 10	 sub	 edi, DWORD PTR [rcx+16]
$LN9@gzseek64:
  00053	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi

; 304  :     state->seek = 0;

  00058	33 f6		 xor	 esi, esi
  0005a	89 71 5c	 mov	 DWORD PTR [rcx+92], esi

; 305  : 
; 306  :     /* if within raw area while reading, just go there */
; 307  :     if (state->mode == GZ_READ && state->how == COPY &&
; 308  :         state->pos + offset >= state->raw) {

  0005d	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH
  00063	75 54		 jne	 SHORT $LN8@gzseek64
  00065	83 79 48 01	 cmp	 DWORD PTR [rcx+72], 1
  00069	75 4e		 jne	 SHORT $LN8@gzseek64
  0006b	8b 49 10	 mov	 ecx, DWORD PTR [rcx+16]
  0006e	03 cf		 add	 ecx, edi
  00070	3b 4b 44	 cmp	 ecx, DWORD PTR [rbx+68]
  00073	7c 44		 jl	 SHORT $LN8@gzseek64

; 309  :         ret = LSEEK(state->fd, offset - state->have, SEEK_CUR);

  00075	8b 4b 04	 mov	 ecx, DWORD PTR [rbx+4]
  00078	8b d7		 mov	 edx, edi
  0007a	44 8d 46 01	 lea	 r8d, QWORD PTR [rsi+1]
  0007e	2b 53 38	 sub	 edx, DWORD PTR [rbx+56]
  00081	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_lseek

; 310  :         if (ret == -1)

  00087	83 f8 ff	 cmp	 eax, -1
  0008a	74 4b		 je	 SHORT $LN23@gzseek64

; 311  :             return -1;
; 312  :         state->have = 0;
; 313  :         state->eof = 0;
; 314  :         state->seek = 0;
; 315  :         gz_error(state, Z_OK, NULL);

  0008c	45 33 c0	 xor	 r8d, r8d
  0008f	33 d2		 xor	 edx, edx
  00091	48 8b cb	 mov	 rcx, rbx
  00094	48 89 73 38	 mov	 QWORD PTR [rbx+56], rsi
  00098	89 73 5c	 mov	 DWORD PTR [rbx+92], esi
  0009b	e8 00 00 00 00	 call	 gz_error

; 316  :         state->strm.avail_in = 0;
; 317  :         state->pos += offset;

  000a0	01 7b 10	 add	 DWORD PTR [rbx+16], edi

; 318  :         return state->pos;

  000a3	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]
  000a6	89 73 78	 mov	 DWORD PTR [rbx+120], esi
  000a9	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 348  : }

  000ae	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000b3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b7	5f		 pop	 rdi
  000b8	c3		 ret	 0
$LN8@gzseek64:

; 319  :     }
; 320  : 
; 321  :     /* calculate skip amount, rewinding if needed for back seek when reading */
; 322  :     if (offset < 0) {

  000b9	85 ff		 test	 edi, edi
  000bb	79 2d		 jns	 SHORT $LN3@gzseek64

; 323  :         if (state->mode != GZ_READ)         /* writing -- can't go backwards */

  000bd	81 fa 4f 1c 00
	00		 cmp	 edx, 7247		; 00001c4fH
  000c3	75 12		 jne	 SHORT $LN23@gzseek64

; 324  :             return -1;
; 325  :         offset += state->pos;

  000c5	03 7b 10	 add	 edi, DWORD PTR [rbx+16]

; 326  :         if (offset < 0)                     /* before start of file! */

  000c8	78 0d		 js	 SHORT $LN23@gzseek64

; 327  :             return -1;
; 328  :         if (gzrewind(file) == -1)           /* rewind, then skip to offset */

  000ca	48 8b cb	 mov	 rcx, rbx
  000cd	e8 00 00 00 00	 call	 gzrewind
  000d2	83 f8 ff	 cmp	 eax, -1
  000d5	75 13		 jne	 SHORT $LN3@gzseek64
$LN23@gzseek64:

; 329  :             return -1;

  000d7	83 c8 ff	 or	 eax, -1
  000da	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 348  : }

  000df	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000e4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e8	5f		 pop	 rdi
  000e9	c3		 ret	 0
$LN3@gzseek64:

; 330  :     }
; 331  : 
; 332  :     /* if reading, skip what's in output buffer (one less gzgetc() check) */
; 333  :     if (state->mode == GZ_READ) {

  000ea	81 3b 4f 1c 00
	00		 cmp	 DWORD PTR [rbx], 7247	; 00001c4fH
  000f0	75 22		 jne	 SHORT $LN2@gzseek64

; 334  :         n = GT_OFF(state->have) || (z_off64_t)state->have > offset ?
; 335  :             (unsigned)offset : state->have;

  000f2	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  000f5	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  000fa	77 06		 ja	 SHORT $LN19@gzseek64
  000fc	8b c8		 mov	 ecx, eax
  000fe	3b c7		 cmp	 eax, edi
  00100	7e 02		 jle	 SHORT $LN20@gzseek64
$LN19@gzseek64:
  00102	8b cf		 mov	 ecx, edi
$LN20@gzseek64:

; 336  :         state->have -= n;
; 337  :         state->next += n;
; 338  :         state->pos += n;

  00104	01 4b 10	 add	 DWORD PTR [rbx+16], ecx
  00107	2b c1		 sub	 eax, ecx
  00109	89 43 38	 mov	 DWORD PTR [rbx+56], eax
  0010c	8b c1		 mov	 eax, ecx
  0010e	48 01 43 30	 add	 QWORD PTR [rbx+48], rax

; 339  :         offset -= n;

  00112	2b f9		 sub	 edi, ecx
$LN2@gzseek64:

; 340  :     }
; 341  : 
; 342  :     /* request skip (if not zero) */
; 343  :     if (offset) {

  00114	85 ff		 test	 edi, edi
  00116	74 0a		 je	 SHORT $LN1@gzseek64

; 344  :         state->seek = 1;

  00118	c7 43 5c 01 00
	00 00		 mov	 DWORD PTR [rbx+92], 1

; 345  :         state->skip = offset;

  0011f	89 7b 58	 mov	 DWORD PTR [rbx+88], edi
$LN1@gzseek64:

; 346  :     }
; 347  :     return state->pos + offset;

  00122	8b 43 10	 mov	 eax, DWORD PTR [rbx+16]
  00125	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 348  : }

  0012a	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0012f	03 c7		 add	 eax, edi
  00131	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00135	5f		 pop	 rdi
  00136	c3		 ret	 0
gzseek64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gzopen64
_TEXT	SEGMENT
path$ = 8
mode$ = 16
gzopen64 PROC						; COMDAT

; 208  :     return gz_open(path, -1, mode);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	83 ca ff	 or	 edx, -1
  00006	e9 00 00 00 00	 jmp	 gz_open
gzopen64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gzoffset
_TEXT	SEGMENT
file$ = 8
gzoffset PROC						; COMDAT

; 416  :     z_off64_t ret;
; 417  : 
; 418  :     ret = gzoffset64(file);

  00000	e9 00 00 00 00	 jmp	 gzoffset64
gzoffset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gztell
_TEXT	SEGMENT
file$ = 8
gztell	PROC						; COMDAT

; 383  :     z_off64_t ret;
; 384  : 
; 385  :     ret = gztell64(file);

  00000	e9 00 00 00 00	 jmp	 gztell64
gztell	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gzseek
_TEXT	SEGMENT
file$ = 8
offset$ = 16
whence$ = 24
gzseek	PROC						; COMDAT

; 356  :     z_off64_t ret;
; 357  : 
; 358  :     ret = gzseek64(file, (z_off64_t)offset, whence);

  00000	e9 00 00 00 00	 jmp	 gzseek64
gzseek	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gzopen
_TEXT	SEGMENT
path$ = 8
mode$ = 16
gzopen	PROC						; COMDAT

; 200  :     return gz_open(path, -1, mode);

  00000	4c 8b c2	 mov	 r8, rdx
  00003	83 ca ff	 or	 edx, -1
  00006	e9 00 00 00 00	 jmp	 gz_open
gzopen	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gzclearerr
_TEXT	SEGMENT
file$ = 8
gzclearerr PROC						; COMDAT

; 464  :     gz_statep state;
; 465  : 
; 466  :     /* get internal structure and check integrity */
; 467  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 2b		 je	 SHORT $LN4@gzclearerr

; 468  :         return;
; 469  :     state = (gz_statep)file;
; 470  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00005	8b 01		 mov	 eax, DWORD PTR [rcx]
  00007	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0000c	74 11		 je	 SHORT $LN6@gzclearerr
  0000e	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  00013	75 1b		 jne	 SHORT $LN4@gzclearerr

; 471  :         return;
; 472  : 
; 473  :     /* clear error and end-of-file */
; 474  :     if (state->mode == GZ_READ)
; 475  :         state->eof = 0;
; 476  :     gz_error(state, Z_OK, NULL);

  00015	45 33 c0	 xor	 r8d, r8d
  00018	33 d2		 xor	 edx, edx
  0001a	e9 00 00 00 00	 jmp	 gz_error
$LN6@gzclearerr:
  0001f	45 33 c0	 xor	 r8d, r8d
  00022	33 d2		 xor	 edx, edx
  00024	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [rcx+60], 0
  0002b	e9 00 00 00 00	 jmp	 gz_error
$LN4@gzclearerr:

; 477  : }

  00030	f3 c3		 fatret	 0
gzclearerr ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gzerror
_TEXT	SEGMENT
file$ = 8
errnum$ = 16
gzerror	PROC						; COMDAT

; 445  :     gz_statep state;
; 446  : 
; 447  :     /* get internal structure and check integrity */
; 448  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 03		 jne	 SHORT $LN3@gzerror
$LN8@gzerror:

; 449  :         return NULL;

  00005	33 c0		 xor	 eax, eax

; 458  : }

  00007	c3		 ret	 0
$LN3@gzerror:

; 450  :     state = (gz_statep)file;
; 451  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00008	8b 01		 mov	 eax, DWORD PTR [rcx]
  0000a	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0000f	74 07		 je	 SHORT $LN2@gzerror
  00011	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  00016	75 ed		 jne	 SHORT $LN8@gzerror
$LN2@gzerror:

; 452  :         return NULL;
; 453  : 
; 454  :     /* return error information */
; 455  :     if (errnum != NULL)

  00018	48 85 d2	 test	 rdx, rdx
  0001b	74 05		 je	 SHORT $LN1@gzerror

; 456  :         *errnum = state->err;

  0001d	8b 41 60	 mov	 eax, DWORD PTR [rcx+96]
  00020	89 02		 mov	 DWORD PTR [rdx], eax
$LN1@gzerror:

; 457  :     return state->msg == NULL ? "" : state->msg;

  00022	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  0002d	48 85 c9	 test	 rcx, rcx
  00030	48 0f 45 c1	 cmovne	 rax, rcx

; 458  : }

  00034	c3		 ret	 0
gzerror	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gzeof
_TEXT	SEGMENT
file$ = 8
gzeof	PROC						; COMDAT

; 426  :     gz_statep state;
; 427  : 
; 428  :     /* get internal structure and check integrity */
; 429  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 21		 je	 SHORT $LN5@gzeof

; 430  :         return 0;
; 431  :     state = (gz_statep)file;
; 432  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00005	8b 01		 mov	 eax, DWORD PTR [rcx]
  00007	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  0000c	75 18		 jne	 SHORT $LN5@gzeof

; 433  :         return 0;
; 434  : 
; 435  :     /* return end-of-file state */
; 436  :     return state->mode == GZ_READ ?
; 437  :         (state->eof && state->strm.avail_in == 0 && state->have == 0) : 0;

  0000e	83 79 3c 00	 cmp	 DWORD PTR [rcx+60], 0
  00012	74 12		 je	 SHORT $LN5@gzeof
  00014	83 79 78 00	 cmp	 DWORD PTR [rcx+120], 0
  00018	75 0c		 jne	 SHORT $LN5@gzeof
  0001a	83 79 38 00	 cmp	 DWORD PTR [rcx+56], 0
  0001e	75 06		 jne	 SHORT $LN5@gzeof
  00020	b8 01 00 00 00	 mov	 eax, 1

; 438  : }

  00025	c3		 ret	 0
$LN5@gzeof:

; 433  :         return 0;
; 434  : 
; 435  :     /* return end-of-file state */
; 436  :     return state->mode == GZ_READ ?
; 437  :         (state->eof && state->strm.avail_in == 0 && state->have == 0) : 0;

  00026	33 c0		 xor	 eax, eax

; 438  : }

  00028	c3		 ret	 0
gzeof	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gzrewind
_TEXT	SEGMENT
file$ = 48
gzrewind PROC						; COMDAT

; 255  : {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 256  :     gz_statep state;
; 257  : 
; 258  :     /* get internal structure */
; 259  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 32		 je	 SHORT $LN2@gzrewind

; 260  :         return -1;
; 261  :     state = (gz_statep)file;
; 262  : 
; 263  :     /* check that we're reading and that there's no error */
; 264  :     if (state->mode != GZ_READ || state->err != Z_OK)

  0000e	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [rcx], 7247	; 00001c4fH
  00014	75 2a		 jne	 SHORT $LN2@gzrewind
  00016	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0001a	75 24		 jne	 SHORT $LN2@gzrewind

; 266  : 
; 267  :     /* back up and start over */
; 268  :     if (LSEEK(state->fd, state->start, SEEK_SET) == -1)

  0001c	8b 51 40	 mov	 edx, DWORD PTR [rcx+64]
  0001f	8b 49 04	 mov	 ecx, DWORD PTR [rcx+4]
  00022	45 33 c0	 xor	 r8d, r8d
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_lseek
  0002b	83 f8 ff	 cmp	 eax, -1
  0002e	74 10		 je	 SHORT $LN2@gzrewind

; 269  :         return -1;
; 270  :     gz_reset(state);

  00030	48 8b cb	 mov	 rcx, rbx
  00033	e8 00 00 00 00	 call	 gz_reset

; 271  :     return 0;

  00038	33 c0		 xor	 eax, eax

; 272  : }

  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	c3		 ret	 0
$LN2@gzrewind:

; 265  :         return -1;

  00040	83 c8 ff	 or	 eax, -1

; 272  : }

  00043	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00047	5b		 pop	 rbx
  00048	c3		 ret	 0
gzrewind ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gzbuffer
_TEXT	SEGMENT
file$ = 8
size$ = 16
gzbuffer PROC						; COMDAT

; 232  :     gz_statep state;
; 233  : 
; 234  :     /* get internal structure and check integrity */
; 235  :     if (file == NULL)

  00000	48 85 c9	 test	 rcx, rcx
  00003	75 04		 jne	 SHORT $LN4@gzbuffer
$LN7@gzbuffer:

; 236  :         return -1;

  00005	83 c8 ff	 or	 eax, -1

; 250  : }

  00008	c3		 ret	 0
$LN4@gzbuffer:

; 237  :     state = (gz_statep)file;
; 238  :     if (state->mode != GZ_READ && state->mode != GZ_WRITE)

  00009	8b 01		 mov	 eax, DWORD PTR [rcx]
  0000b	3d 4f 1c 00 00	 cmp	 eax, 7247		; 00001c4fH
  00010	74 07		 je	 SHORT $LN3@gzbuffer
  00012	3d b1 79 00 00	 cmp	 eax, 31153		; 000079b1H
  00017	75 ec		 jne	 SHORT $LN7@gzbuffer
$LN3@gzbuffer:

; 239  :         return -1;
; 240  : 
; 241  :     /* make sure we haven't already allocated memory */
; 242  :     if (state->size != 0)

  00019	83 79 14 00	 cmp	 DWORD PTR [rcx+20], 0
  0001d	75 e6		 jne	 SHORT $LN7@gzbuffer

; 243  :         return -1;
; 244  : 
; 245  :     /* check and set requested size */
; 246  :     if (size == 0)

  0001f	85 d2		 test	 edx, edx
  00021	74 e2		 je	 SHORT $LN7@gzbuffer

; 247  :         return -1;
; 248  :     state->want = size;

  00023	89 51 18	 mov	 DWORD PTR [rcx+24], edx

; 249  :     return 0;

  00026	33 c0		 xor	 eax, eax

; 250  : }

  00028	c3		 ret	 0
gzbuffer ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzlib.c
;	COMDAT gzdopen
_TEXT	SEGMENT
fd$ = 48
mode$ = 56
gzdopen	PROC						; COMDAT

; 215  : {

$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f2	 mov	 rsi, rdx
  00012	8b d9		 mov	 ebx, ecx

; 216  :     char *path;         /* identifier for error messages */
; 217  :     gzFile gz;
; 218  : 
; 219  :     if (fd == -1 || (path = malloc(7 + 3 * sizeof(int))) == NULL)

  00014	83 f9 ff	 cmp	 ecx, -1
  00017	74 52		 je	 SHORT $LN1@gzdopen
  00019	b9 13 00 00 00	 mov	 ecx, 19
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00024	48 8b f8	 mov	 rdi, rax
  00027	48 85 c0	 test	 rax, rax
  0002a	74 3f		 je	 SHORT $LN1@gzdopen

; 220  :         return NULL;
; 221  :     sprintf(path, "<fd:%d>", fd);   /* for debugging */

  0002c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
  00033	44 8b c3	 mov	 r8d, ebx
  00036	48 8b c8	 mov	 rcx, rax
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 222  :     gz = gz_open(path, fd, mode);

  0003f	4c 8b c6	 mov	 r8, rsi
  00042	8b d3		 mov	 edx, ebx
  00044	48 8b cf	 mov	 rcx, rdi
  00047	e8 00 00 00 00	 call	 gz_open

; 223  :     free(path);

  0004c	48 8b cf	 mov	 rcx, rdi
  0004f	48 8b d8	 mov	 rbx, rax
  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 224  :     return gz;

  00058	48 8b c3	 mov	 rax, rbx

; 225  : }

  0005b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00060	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00065	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00069	5f		 pop	 rdi
  0006a	c3		 ret	 0
$LN1@gzdopen:
  0006b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00070	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00075	33 c0		 xor	 eax, eax
  00077	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007b	5f		 pop	 rdi
  0007c	c3		 ret	 0
gzdopen	ENDP
_TEXT	ENDS
END
