; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	adler32
PUBLIC	adler32_combine
PUBLIC	adler32_combine64
;	COMDAT pdata
pdata	SEGMENT
$pdata$adler32_combine_ DD imagerel adler32_combine_
	DD	imagerel adler32_combine_+162
	DD	imagerel $unwind$adler32_combine_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32_combine_ DD 020501H
	DD	013405H
xdata	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\adler32.c
;	COMDAT adler32_combine_
_TEXT	SEGMENT
adler1$ = 8
adler2$ = 16
len2$ = 24
adler32_combine_ PROC					; COMDAT

; 135  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	44 8b d2	 mov	 r10d, edx
  00008	44 8b d9	 mov	 r11d, ecx
  0000b	41 8b d8	 mov	 ebx, r8d

; 136  :     unsigned long sum1;
; 137  :     unsigned long sum2;
; 138  :     unsigned rem;
; 139  : 
; 140  :     /* the derivation of this formula is left as an exercise for the reader */
; 141  :     rem = (unsigned)(len2 % BASE);
; 142  :     sum1 = adler1 & 0xffff;
; 143  :     sum2 = rem * sum1;
; 144  :     MOD(sum2);
; 145  :     sum1 += (adler2 & 0xffff) + BASE - 1;
; 146  :     sum2 += ((adler1 >> 16) & 0xffff) + ((adler2 >> 16) & 0xffff) + BASE - rem;

  0000e	41 c1 eb 10	 shr	 r11d, 16
  00012	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00017	41 f7 e0	 mul	 r8d
  0001a	44 0f b7 c1	 movzx	 r8d, cx
  0001e	41 0f b7 ca	 movzx	 ecx, r10w
  00022	c1 ea 0f	 shr	 edx, 15
  00025	41 c1 ea 10	 shr	 r10d, 16
  00029	81 c1 f0 ff 00
	00		 add	 ecx, 65520		; 0000fff0H
  0002f	45 8b c8	 mov	 r9d, r8d
  00032	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00037	41 03 c8	 add	 ecx, r8d
  0003a	69 d2 f1 ff 00
	00		 imul	 edx, 65521		; 0000fff1H
  00040	2b da		 sub	 ebx, edx
  00042	44 0f af cb	 imul	 r9d, ebx
  00046	41 f7 e1	 mul	 r9d
  00049	c1 ea 0f	 shr	 edx, 15
  0004c	69 d2 f1 ff 00
	00		 imul	 edx, 65521		; 0000fff1H
  00052	44 2b da	 sub	 r11d, edx
  00055	43 8d 04 1a	 lea	 eax, DWORD PTR [r10+r11]
  00059	2b c3		 sub	 eax, ebx
  0005b	05 f1 ff 00 00	 add	 eax, 65521		; 0000fff1H
  00060	41 03 c1	 add	 eax, r9d

; 147  :     if (sum1 >= BASE) sum1 -= BASE;

  00063	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  00069	72 14		 jb	 SHORT $LN3@adler32_co
  0006b	81 c1 0f 00 ff
	ff		 add	 ecx, -65521		; ffff000fH

; 148  :     if (sum1 >= BASE) sum1 -= BASE;

  00071	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  00077	72 06		 jb	 SHORT $LN3@adler32_co
  00079	81 c1 0f 00 ff
	ff		 add	 ecx, -65521		; ffff000fH
$LN3@adler32_co:

; 149  :     if (sum2 >= (BASE << 1)) sum2 -= (BASE << 1);

  0007f	3d e2 ff 01 00	 cmp	 eax, 131042		; 0001ffe2H
  00084	72 05		 jb	 SHORT $LN2@adler32_co
  00086	05 1e 00 fe ff	 add	 eax, -131042		; fffe001eH
$LN2@adler32_co:

; 150  :     if (sum2 >= BASE) sum2 -= BASE;

  0008b	3d f1 ff 00 00	 cmp	 eax, 65521		; 0000fff1H
  00090	72 05		 jb	 SHORT $LN1@adler32_co
  00092	05 0f 00 ff ff	 add	 eax, -65521		; ffff000fH
$LN1@adler32_co:

; 151  :     return sum1 | (sum2 << 16);
; 152  : }

  00097	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0009c	c1 e0 10	 shl	 eax, 16
  0009f	0b c1		 or	 eax, ecx
  000a1	c3		 ret	 0
adler32_combine_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\adler32.c
;	COMDAT adler32_combine64
_TEXT	SEGMENT
adler1$ = 8
adler2$ = 16
len2$ = 24
adler32_combine64 PROC					; COMDAT

; 168  :     return adler32_combine_(adler1, adler2, len2);

  00000	e9 00 00 00 00	 jmp	 adler32_combine_
adler32_combine64 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\adler32.c
;	COMDAT adler32_combine
_TEXT	SEGMENT
adler1$ = 8
adler2$ = 16
len2$ = 24
adler32_combine PROC					; COMDAT

; 160  :     return adler32_combine_(adler1, adler2, len2);

  00000	e9 00 00 00 00	 jmp	 adler32_combine_
adler32_combine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\adler32.c
;	COMDAT adler32
_TEXT	SEGMENT
adler$ = 8
buf$ = 16
len$ = 24
adler32	PROC						; COMDAT

; 65   :     unsigned long sum2;
; 66   :     unsigned n;
; 67   : 
; 68   :     /* split Adler-32 into component sums */
; 69   :     sum2 = (adler >> 16) & 0xffff;

  00000	44 8b c9	 mov	 r9d, ecx
  00003	4c 8b d2	 mov	 r10, rdx

; 70   :     adler &= 0xffff;

  00006	0f b7 c9	 movzx	 ecx, cx
  00009	41 c1 e9 10	 shr	 r9d, 16

; 71   : 
; 72   :     /* in case user likes doing a byte at a time, keep it fast */
; 73   :     if (len == 1) {

  0000d	41 83 f8 01	 cmp	 r8d, 1
  00011	75 35		 jne	 SHORT $LN18@adler32

; 74   :         adler += buf[0];

  00013	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00016	03 c8		 add	 ecx, eax

; 75   :         if (adler >= BASE)

  00018	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  0001e	72 06		 jb	 SHORT $LN17@adler32

; 76   :             adler -= BASE;

  00020	81 c1 0f 00 ff
	ff		 add	 ecx, -65521		; ffff000fH
$LN17@adler32:

; 77   :         sum2 += adler;

  00026	44 03 c9	 add	 r9d, ecx

; 78   :         if (sum2 >= BASE)

  00029	41 81 f9 f1 ff
	00 00		 cmp	 r9d, 65521		; 0000fff1H
  00030	0f 82 92 02 00
	00		 jb	 $LN5@adler32

; 79   :             sum2 -= BASE;

  00036	41 81 c1 0f 00
	ff ff		 add	 r9d, -65521		; ffff000fH

; 124  :     }
; 125  : 
; 126  :     /* return recombined sums */
; 127  :     return adler | (sum2 << 16);

  0003d	41 c1 e1 10	 shl	 r9d, 16
  00041	44 0b c9	 or	 r9d, ecx
  00044	41 8b c1	 mov	 eax, r9d

; 128  : }

  00047	c3		 ret	 0
$LN18@adler32:

; 80   :         return adler | (sum2 << 16);
; 81   :     }
; 82   : 
; 83   :     /* initial Adler-32 value (deferred check for len == 1 speed) */
; 84   :     if (buf == Z_NULL)

  00048	48 85 d2	 test	 rdx, rdx
  0004b	75 04		 jne	 SHORT $LN15@adler32

; 85   :         return 1L;

  0004d	8d 42 01	 lea	 eax, QWORD PTR [rdx+1]

; 128  : }

  00050	c3		 ret	 0
$LN15@adler32:

; 86   : 
; 87   :     /* in case short lengths are provided, keep it somewhat fast */
; 88   :     if (len < 16) {

  00051	41 83 f8 10	 cmp	 r8d, 16
  00055	73 41		 jae	 SHORT $LN22@adler32

; 89   :         while (len--) {

  00057	45 85 c0	 test	 r8d, r8d
  0005a	74 16		 je	 SHORT $LN26@adler32
  0005c	0f 1f 40 00	 npad	 4
$LL13@adler32:

; 90   :             adler += *buf++;

  00060	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00064	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]
  00068	03 c8		 add	 ecx, eax

; 91   :             sum2 += adler;

  0006a	44 03 c9	 add	 r9d, ecx
  0006d	41 ff c8	 dec	 r8d
  00070	75 ee		 jne	 SHORT $LL13@adler32
$LN26@adler32:

; 92   :         }
; 93   :         if (adler >= BASE)

  00072	81 f9 f1 ff 00
	00		 cmp	 ecx, 65521		; 0000fff1H
  00078	72 06		 jb	 SHORT $LN11@adler32

; 94   :             adler -= BASE;

  0007a	81 c1 0f 00 ff
	ff		 add	 ecx, -65521		; ffff000fH
$LN11@adler32:

; 95   :         MOD4(sum2);             /* only added so many BASE's */

  00080	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00085	41 f7 e1	 mul	 r9d
  00088	c1 ea 0f	 shr	 edx, 15

; 96   :         return adler | (sum2 << 16);

  0008b	6b d2 0f	 imul	 edx, 15
  0008e	41 8d 04 11	 lea	 eax, DWORD PTR [r9+rdx]
  00092	c1 e0 10	 shl	 eax, 16
  00095	0b c1		 or	 eax, ecx

; 128  : }

  00097	c3		 ret	 0
$LN22@adler32:

; 97   :     }
; 98   : 
; 99   :     /* do length NMAX blocks -- requires just one modulo operation */
; 100  :     while (len >= NMAX) {

  00098	41 81 f8 b0 15
	00 00		 cmp	 r8d, 5552		; 000015b0H
  0009f	0f 82 05 01 00
	00		 jb	 $LN9@adler32
  000a5	b8 af a9 6e 5e	 mov	 eax, 1584310703		; 5e6ea9afH
  000aa	41 f7 e0	 mul	 r8d
  000ad	c1 ea 0b	 shr	 edx, 11
  000b0	44 8b da	 mov	 r11d, edx
  000b3	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL10@adler32:

; 101  :         len -= NMAX;

  000c0	41 81 c0 50 ea
	ff ff		 add	 r8d, -5552		; ffffea50H

; 102  :         n = NMAX / 16;          /* NMAX is divisible by 16 */

  000c7	ba 5b 01 00 00	 mov	 edx, 347		; 0000015bH
  000cc	0f 1f 40 00	 npad	 4
$LL8@adler32:

; 103  :         do {
; 104  :             DO16(buf);          /* 16 sums unrolled */

  000d0	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]

; 105  :             buf += 16;

  000d4	49 83 c2 10	 add	 r10, 16
  000d8	03 c8		 add	 ecx, eax
  000da	41 0f b6 42 f1	 movzx	 eax, BYTE PTR [r10-15]
  000df	44 03 c9	 add	 r9d, ecx
  000e2	03 c8		 add	 ecx, eax
  000e4	41 0f b6 42 f2	 movzx	 eax, BYTE PTR [r10-14]
  000e9	44 03 c9	 add	 r9d, ecx
  000ec	03 c8		 add	 ecx, eax
  000ee	41 0f b6 42 f3	 movzx	 eax, BYTE PTR [r10-13]
  000f3	44 03 c9	 add	 r9d, ecx
  000f6	03 c8		 add	 ecx, eax
  000f8	41 0f b6 42 f4	 movzx	 eax, BYTE PTR [r10-12]
  000fd	44 03 c9	 add	 r9d, ecx
  00100	03 c8		 add	 ecx, eax
  00102	41 0f b6 42 f5	 movzx	 eax, BYTE PTR [r10-11]
  00107	44 03 c9	 add	 r9d, ecx
  0010a	03 c8		 add	 ecx, eax
  0010c	41 0f b6 42 f6	 movzx	 eax, BYTE PTR [r10-10]
  00111	44 03 c9	 add	 r9d, ecx
  00114	03 c8		 add	 ecx, eax
  00116	41 0f b6 42 f7	 movzx	 eax, BYTE PTR [r10-9]
  0011b	44 03 c9	 add	 r9d, ecx
  0011e	03 c8		 add	 ecx, eax
  00120	41 0f b6 42 f8	 movzx	 eax, BYTE PTR [r10-8]
  00125	44 03 c9	 add	 r9d, ecx
  00128	03 c8		 add	 ecx, eax
  0012a	41 0f b6 42 f9	 movzx	 eax, BYTE PTR [r10-7]
  0012f	44 03 c9	 add	 r9d, ecx
  00132	03 c8		 add	 ecx, eax
  00134	41 0f b6 42 fa	 movzx	 eax, BYTE PTR [r10-6]
  00139	44 03 c9	 add	 r9d, ecx
  0013c	03 c8		 add	 ecx, eax
  0013e	41 0f b6 42 fb	 movzx	 eax, BYTE PTR [r10-5]
  00143	44 03 c9	 add	 r9d, ecx
  00146	03 c8		 add	 ecx, eax
  00148	41 0f b6 42 fc	 movzx	 eax, BYTE PTR [r10-4]
  0014d	44 03 c9	 add	 r9d, ecx
  00150	03 c8		 add	 ecx, eax
  00152	41 0f b6 42 fd	 movzx	 eax, BYTE PTR [r10-3]
  00157	44 03 c9	 add	 r9d, ecx
  0015a	03 c8		 add	 ecx, eax
  0015c	41 0f b6 42 fe	 movzx	 eax, BYTE PTR [r10-2]
  00161	44 03 c9	 add	 r9d, ecx
  00164	03 c8		 add	 ecx, eax
  00166	41 0f b6 42 ff	 movzx	 eax, BYTE PTR [r10-1]
  0016b	44 03 c9	 add	 r9d, ecx
  0016e	03 c8		 add	 ecx, eax
  00170	44 03 c9	 add	 r9d, ecx

; 106  :         } while (--n);

  00173	ff ca		 dec	 edx
  00175	0f 85 55 ff ff
	ff		 jne	 $LL8@adler32

; 107  :         MOD(adler);

  0017b	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00180	f7 e1		 mul	 ecx

; 108  :         MOD(sum2);

  00182	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  00187	c1 ea 0f	 shr	 edx, 15
  0018a	69 d2 0f 00 ff
	ff		 imul	 edx, -65521		; ffff000fH
  00190	03 ca		 add	 ecx, edx
  00192	41 f7 e1	 mul	 r9d
  00195	c1 ea 0f	 shr	 edx, 15
  00198	69 d2 0f 00 ff
	ff		 imul	 edx, -65521		; ffff000fH
  0019e	44 03 ca	 add	 r9d, edx
  001a1	49 ff cb	 dec	 r11
  001a4	0f 85 16 ff ff
	ff		 jne	 $LL10@adler32
$LN9@adler32:

; 109  :     }
; 110  : 
; 111  :     /* do remaining bytes (less than NMAX, still just one modulo) */
; 112  :     if (len) {                  /* avoid modulos if none remaining */

  001aa	45 85 c0	 test	 r8d, r8d
  001ad	0f 84 15 01 00
	00		 je	 $LN5@adler32

; 113  :         while (len >= 16) {

  001b3	41 83 f8 10	 cmp	 r8d, 16
  001b7	0f 82 c3 00 00
	00		 jb	 $LN25@adler32
  001bd	41 8b d0	 mov	 edx, r8d
  001c0	48 c1 ea 04	 shr	 rdx, 4
  001c4	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@adler32:

; 114  :             len -= 16;
; 115  :             DO16(buf);

  001d0	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  001d4	41 83 c0 f0	 add	 r8d, -16		; fffffff0H

; 116  :             buf += 16;

  001d8	49 83 c2 10	 add	 r10, 16
  001dc	03 c8		 add	 ecx, eax
  001de	41 0f b6 42 f1	 movzx	 eax, BYTE PTR [r10-15]
  001e3	44 03 c9	 add	 r9d, ecx
  001e6	03 c8		 add	 ecx, eax
  001e8	41 0f b6 42 f2	 movzx	 eax, BYTE PTR [r10-14]
  001ed	44 03 c9	 add	 r9d, ecx
  001f0	03 c8		 add	 ecx, eax
  001f2	41 0f b6 42 f3	 movzx	 eax, BYTE PTR [r10-13]
  001f7	44 03 c9	 add	 r9d, ecx
  001fa	03 c8		 add	 ecx, eax
  001fc	41 0f b6 42 f4	 movzx	 eax, BYTE PTR [r10-12]
  00201	44 03 c9	 add	 r9d, ecx
  00204	03 c8		 add	 ecx, eax
  00206	41 0f b6 42 f5	 movzx	 eax, BYTE PTR [r10-11]
  0020b	44 03 c9	 add	 r9d, ecx
  0020e	03 c8		 add	 ecx, eax
  00210	41 0f b6 42 f6	 movzx	 eax, BYTE PTR [r10-10]
  00215	44 03 c9	 add	 r9d, ecx
  00218	03 c8		 add	 ecx, eax
  0021a	41 0f b6 42 f7	 movzx	 eax, BYTE PTR [r10-9]
  0021f	44 03 c9	 add	 r9d, ecx
  00222	03 c8		 add	 ecx, eax
  00224	41 0f b6 42 f8	 movzx	 eax, BYTE PTR [r10-8]
  00229	44 03 c9	 add	 r9d, ecx
  0022c	03 c8		 add	 ecx, eax
  0022e	41 0f b6 42 f9	 movzx	 eax, BYTE PTR [r10-7]
  00233	44 03 c9	 add	 r9d, ecx
  00236	03 c8		 add	 ecx, eax
  00238	41 0f b6 42 fa	 movzx	 eax, BYTE PTR [r10-6]
  0023d	44 03 c9	 add	 r9d, ecx
  00240	03 c8		 add	 ecx, eax
  00242	41 0f b6 42 fb	 movzx	 eax, BYTE PTR [r10-5]
  00247	44 03 c9	 add	 r9d, ecx
  0024a	03 c8		 add	 ecx, eax
  0024c	41 0f b6 42 fc	 movzx	 eax, BYTE PTR [r10-4]
  00251	44 03 c9	 add	 r9d, ecx
  00254	03 c8		 add	 ecx, eax
  00256	41 0f b6 42 fd	 movzx	 eax, BYTE PTR [r10-3]
  0025b	44 03 c9	 add	 r9d, ecx
  0025e	03 c8		 add	 ecx, eax
  00260	41 0f b6 42 fe	 movzx	 eax, BYTE PTR [r10-2]
  00265	44 03 c9	 add	 r9d, ecx
  00268	03 c8		 add	 ecx, eax
  0026a	41 0f b6 42 ff	 movzx	 eax, BYTE PTR [r10-1]
  0026f	44 03 c9	 add	 r9d, ecx
  00272	03 c8		 add	 ecx, eax
  00274	44 03 c9	 add	 r9d, ecx
  00277	48 ff ca	 dec	 rdx
  0027a	0f 85 50 ff ff
	ff		 jne	 $LL4@adler32
$LN25@adler32:

; 117  :         }
; 118  :         while (len--) {

  00280	45 85 c0	 test	 r8d, r8d
  00283	74 1d		 je	 SHORT $LN30@adler32
  00285	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL2@adler32:

; 119  :             adler += *buf++;

  00290	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00294	4d 8d 52 01	 lea	 r10, QWORD PTR [r10+1]
  00298	03 c8		 add	 ecx, eax

; 120  :             sum2 += adler;

  0029a	44 03 c9	 add	 r9d, ecx
  0029d	41 ff c8	 dec	 r8d
  002a0	75 ee		 jne	 SHORT $LL2@adler32
$LN30@adler32:

; 121  :         }
; 122  :         MOD(adler);

  002a2	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  002a7	f7 e1		 mul	 ecx

; 123  :         MOD(sum2);

  002a9	b8 71 80 07 80	 mov	 eax, -2146992015	; 80078071H
  002ae	c1 ea 0f	 shr	 edx, 15
  002b1	69 d2 0f 00 ff
	ff		 imul	 edx, -65521		; ffff000fH
  002b7	03 ca		 add	 ecx, edx
  002b9	41 f7 e1	 mul	 r9d
  002bc	c1 ea 0f	 shr	 edx, 15
  002bf	69 d2 0f 00 ff
	ff		 imul	 edx, -65521		; ffff000fH
  002c5	44 03 ca	 add	 r9d, edx
$LN5@adler32:

; 124  :     }
; 125  : 
; 126  :     /* return recombined sums */
; 127  :     return adler | (sum2 << 16);

  002c8	41 c1 e1 10	 shl	 r9d, 16
  002cc	44 0b c9	 or	 r9d, ecx
  002cf	41 8b c1	 mov	 eax, r9d

; 128  : }

  002d2	c3		 ret	 0
adler32	ENDP
_TEXT	ENDS
END
