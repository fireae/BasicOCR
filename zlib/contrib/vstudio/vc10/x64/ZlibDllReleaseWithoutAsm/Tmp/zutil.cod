; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	z_errmsg
PUBLIC	??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@	; `string'
PUBLIC	??_C@_0L@FNAOCBOG@stream?5end?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0L@KIJFAKBJ@file?5error?$AA@		; `string'
PUBLIC	??_C@_0N@MKKNPMJD@stream?5error?$AA@		; `string'
PUBLIC	??_C@_0L@HAHMBNLP@data?5error?$AA@		; `string'
PUBLIC	??_C@_0BE@OGGJBMCE@insufficient?5memory?$AA@	; `string'
PUBLIC	??_C@_0N@DFPGLBGC@buffer?5error?$AA@		; `string'
PUBLIC	??_C@_0BF@CJFPCCEG@incompatible?5version?$AA@	; `string'
;	COMDAT ??_C@_0BF@CJFPCCEG@incompatible?5version?$AA@
CONST	SEGMENT
??_C@_0BF@CJFPCCEG@incompatible?5version?$AA@ DB 'incompatible version', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@DFPGLBGC@buffer?5error?$AA@
CONST	SEGMENT
??_C@_0N@DFPGLBGC@buffer?5error?$AA@ DB 'buffer error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@OGGJBMCE@insufficient?5memory?$AA@
CONST	SEGMENT
??_C@_0BE@OGGJBMCE@insufficient?5memory?$AA@ DB 'insufficient memory', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@HAHMBNLP@data?5error?$AA@
CONST	SEGMENT
??_C@_0L@HAHMBNLP@data?5error?$AA@ DB 'data error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MKKNPMJD@stream?5error?$AA@
CONST	SEGMENT
??_C@_0N@MKKNPMJD@stream?5error?$AA@ DB 'stream error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KIJFAKBJ@file?5error?$AA@
CONST	SEGMENT
??_C@_0L@KIJFAKBJ@file?5error?$AA@ DB 'file error', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@FNAOCBOG@stream?5end?$AA@
CONST	SEGMENT
??_C@_0L@FNAOCBOG@stream?5end?$AA@ DB 'stream end', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@
CONST	SEGMENT
??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@ DB 'need dictionary', 00H ; `string'
CONST	ENDS
CONST	SEGMENT
z_errmsg DQ	FLAT:??_C@_0BA@MOKMMFOD@need?5dictionary?$AA@
	DQ	FLAT:??_C@_0L@FNAOCBOG@stream?5end?$AA@
	DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
	DQ	FLAT:??_C@_0L@KIJFAKBJ@file?5error?$AA@
	DQ	FLAT:??_C@_0N@MKKNPMJD@stream?5error?$AA@
	DQ	FLAT:??_C@_0L@HAHMBNLP@data?5error?$AA@
	DQ	FLAT:??_C@_0BE@OGGJBMCE@insufficient?5memory?$AA@
	DQ	FLAT:??_C@_0N@DFPGLBGC@buffer?5error?$AA@
	DQ	FLAT:??_C@_0BF@CJFPCCEG@incompatible?5version?$AA@
	DQ	FLAT:??_C@_00CNPNBAHC@?$AA@
CONST	ENDS
PUBLIC	zlibVersion
PUBLIC	zlibCompileFlags
PUBLIC	zError
PUBLIC	zcalloc
PUBLIC	zcfree
PUBLIC	??_C@_05DFCKICEH@1?42?45?$AA@			; `string'
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
;	COMDAT ??_C@_05DFCKICEH@1?42?45?$AA@
CONST	SEGMENT
??_C@_05DFCKICEH@1?42?45?$AA@ DB '1.2.5', 00H		; `string'
CONST	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\zutil.c
;	COMDAT zcfree
_TEXT	SEGMENT
opaque$ = 8
ptr$ = 16
zcfree	PROC						; COMDAT

; 314  :     free(ptr);

  00000	48 8b ca	 mov	 rcx, rdx
  00003	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_free
zcfree	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\zutil.c
;	COMDAT zcalloc
_TEXT	SEGMENT
opaque$ = 8
items$ = 16
size$ = 24
zcalloc	PROC						; COMDAT

; 305  :     if (opaque) items += size - size; /* make compiler happy */
; 306  :     return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
; 307  :                               (voidpf)calloc(items, size);

  00000	41 0f af d0	 imul	 edx, r8d
  00004	8b ca		 mov	 ecx, edx
  00006	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_malloc
zcalloc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\zutil.c
;	COMDAT zError
_TEXT	SEGMENT
err$ = 8
zError	PROC						; COMDAT

; 136  :     return ERR_MSG(err);

  00000	48 63 d1	 movsxd	 rdx, ecx
  00003	48 8d 05 10 00
	00 00		 lea	 rax, OFFSET FLAT:z_errmsg+16
  0000a	48 c1 e2 03	 shl	 rdx, 3
  0000e	48 2b c2	 sub	 rax, rdx
  00011	48 8b 00	 mov	 rax, QWORD PTR [rax]

; 137  : }

  00014	c3		 ret	 0
zError	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\zutil.c
;	COMDAT zlibCompileFlags
_TEXT	SEGMENT
zlibCompileFlags PROC					; COMDAT

; 34   :     uLong flags;
; 35   : 
; 36   :     flags = 0;
; 37   :     switch ((int)(sizeof(uInt))) {
; 38   :     case 2:     break;
; 39   :     case 4:     flags += 1;     break;
; 40   :     case 8:     flags += 2;     break;
; 41   :     default:    flags += 3;
; 42   :     }
; 43   :     switch ((int)(sizeof(uLong))) {
; 44   :     case 2:     break;
; 45   :     case 4:     flags += 1 << 2;        break;
; 46   :     case 8:     flags += 2 << 2;        break;
; 47   :     default:    flags += 3 << 2;
; 48   :     }
; 49   :     switch ((int)(sizeof(voidpf))) {
; 50   :     case 2:     break;
; 51   :     case 4:     flags += 1 << 4;        break;
; 52   :     case 8:     flags += 2 << 4;        break;
; 53   :     default:    flags += 3 << 4;
; 54   :     }
; 55   :     switch ((int)(sizeof(z_off_t))) {
; 56   :     case 2:     break;
; 57   :     case 4:     flags += 1 << 6;        break;
; 58   :     case 8:     flags += 2 << 6;        break;
; 59   :     default:    flags += 3 << 6;
; 60   :     }
; 61   : #ifdef DEBUG
; 62   :     flags += 1 << 8;
; 63   : #endif
; 64   : #if defined(ASMV) || defined(ASMINF)
; 65   :     flags += 1 << 9;
; 66   : #endif
; 67   : #ifdef ZLIB_WINAPI
; 68   :     flags += 1 << 10;
; 69   : #endif
; 70   : #ifdef BUILDFIXED
; 71   :     flags += 1 << 12;
; 72   : #endif
; 73   : #ifdef DYNAMIC_CRC_TABLE
; 74   :     flags += 1 << 13;
; 75   : #endif
; 76   : #ifdef NO_GZCOMPRESS
; 77   :     flags += 1L << 16;
; 78   : #endif
; 79   : #ifdef NO_GZIP
; 80   :     flags += 1L << 17;
; 81   : #endif
; 82   : #ifdef PKZIP_BUG_WORKAROUND
; 83   :     flags += 1L << 20;
; 84   : #endif
; 85   : #ifdef FASTEST
; 86   :     flags += 1L << 21;
; 87   : #endif
; 88   : #ifdef STDC
; 89   : #  ifdef NO_vsnprintf
; 90   :         flags += 1L << 25;
; 91   : #    ifdef HAS_vsprintf_void
; 92   :         flags += 1L << 26;
; 93   : #    endif
; 94   : #  else
; 95   : #    ifdef HAS_vsnprintf_void
; 96   :         flags += 1L << 26;
; 97   : #    endif
; 98   : #  endif
; 99   : #else
; 100  :         flags += 1L << 24;
; 101  : #  ifdef NO_snprintf
; 102  :         flags += 1L << 25;
; 103  : #    ifdef HAS_sprintf_void
; 104  :         flags += 1L << 26;
; 105  : #    endif
; 106  : #  else
; 107  : #    ifdef HAS_snprintf_void
; 108  :         flags += 1L << 26;
; 109  : #    endif
; 110  : #  endif
; 111  : #endif
; 112  :     return flags;

  00000	b8 65 04 00 00	 mov	 eax, 1125		; 00000465H

; 113  : }

  00005	c3		 ret	 0
zlibCompileFlags ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\zutil.c
;	COMDAT zlibVersion
_TEXT	SEGMENT
zlibVersion PROC					; COMDAT

; 29   :     return ZLIB_VERSION;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05DFCKICEH@1?42?45?$AA@

; 30   : }

  00007	c3		 ret	 0
zlibVersion ENDP
_TEXT	ENDS
END
