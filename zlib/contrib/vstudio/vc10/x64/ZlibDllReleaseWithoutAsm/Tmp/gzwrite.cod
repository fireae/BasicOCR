; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	gzsetparams
PUBLIC	gzwrite
PUBLIC	gzprintf
PUBLIC	gzputs
PUBLIC	gzputc
PUBLIC	gzflush
PUBLIC	gzclose_w
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_05DFCKICEH@1?42?45?$AA@			; `string'
PUBLIC	??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ ; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ ; `string'
EXTRN	__imp__vsnprintf:PROC
EXTRN	__imp_strerror:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	deflate:PROC
EXTRN	deflateEnd:PROC
EXTRN	deflateReset:PROC
EXTRN	deflateParams:PROC
EXTRN	deflateInit2_:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_write:PROC
EXTRN	gz_error:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzsetparams DD imagerel $LN14
	DD	imagerel $LN14+192
	DD	imagerel $unwind$gzsetparams
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzwrite DD imagerel $LN31
	DD	imagerel $LN31+294
	DD	imagerel $unwind$gzwrite
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzprintf DD imagerel $LN16
	DD	imagerel $LN16+129
	DD	imagerel $unwind$gzprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gzprintf DD imagerel $LN16+129
	DD	imagerel $LN16+216
	DD	imagerel $chain$1$gzprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gzprintf DD imagerel $LN16+216
	DD	imagerel $LN16+234
	DD	imagerel $chain$3$gzprintf
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzputs DD imagerel $LN7
	DD	imagerel $LN7+50
	DD	imagerel $unwind$gzputs
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzputc DD imagerel $LN12
	DD	imagerel $LN12+171
	DD	imagerel $unwind$gzputc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzflush DD imagerel $LN12
	DD	imagerel $LN12+119
	DD	imagerel $unwind$gzflush
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzclose_w DD imagerel $LN8
	DD	imagerel $LN8+164
	DD	imagerel $unwind$gzclose_w
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_init DD imagerel gz_init
	DD	imagerel gz_init+265
	DD	imagerel $unwind$gz_init
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_comp DD imagerel gz_comp
	DD	imagerel gz_comp+276
	DD	imagerel $unwind$gz_comp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_zero DD imagerel gz_zero
	DD	imagerel gz_zero+46
	DD	imagerel $unwind$gz_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gz_zero DD imagerel gz_zero+46
	DD	imagerel gz_zero+158
	DD	imagerel $chain$1$gz_zero
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gz_zero DD imagerel gz_zero+158
	DD	imagerel gz_zero+163
	DD	imagerel $chain$3$gz_zero
pdata	ENDS
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ DB 'requested l'
	DB	'ength does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@ DB 'internal er'
	DB	'ror: deflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFCKICEH@1?42?45?$AA@
CONST	SEGMENT
??_C@_05DFCKICEH@1?42?45?$AA@ DB '1.2.5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@ DB 'out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gz_zero DD 040021H
	DD	075400H
	DD	063400H
	DD	imagerel gz_zero
	DD	imagerel gz_zero+46
	DD	imagerel $unwind$gz_zero
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gz_zero DD 040a21H
	DD	07540aH
	DD	063405H
	DD	imagerel gz_zero
	DD	imagerel gz_zero+46
	DD	imagerel $unwind$gz_zero
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_zero DD 040a01H
	DD	08640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_comp DD 083d01H
	DD	06643dH
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_init DD 081401H
	DD	0c6414H
	DD	0b5414H
	DD	0a3414H
	DD	070107214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclose_w DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzflush DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzputc DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzputs DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gzprintf DD 040021H
	DD	047400H
	DD	056400H
	DD	imagerel $LN16
	DD	imagerel $LN16+129
	DD	imagerel $unwind$gzprintf
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gzprintf DD 042421H
	DD	047424H
	DD	056405H
	DD	imagerel $LN16
	DD	imagerel $LN16+129
	DD	imagerel $unwind$gzprintf
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzprintf DD 021401H
	DD	030105214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzwrite DD 0a8d01H
	DD	09748dH
	DD	086488H
	DD	0a340eH
	DD	0f00a320eH
	DD	05006e008H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzsetparams DD 083a01H
	DD	06543aH
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzwrite.c
;	COMDAT gz_zero
_TEXT	SEGMENT
state$ = 48
len$ = 56
gz_zero	PROC						; COMDAT

; 114  : {

  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 115  :     int first;
; 116  :     unsigned n;
; 117  :     z_streamp strm = &(state->strm);
; 118  : 
; 119  :     /* consume whatever's left in the input buffer */
; 120  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  0000a	83 79 78 00	 cmp	 DWORD PTR [rcx+120], 0
  0000e	8b f2		 mov	 esi, edx
  00010	48 8b f9	 mov	 rdi, rcx
  00013	74 19		 je	 SHORT $LN5@gz_zero
  00015	33 d2		 xor	 edx, edx
  00017	e8 00 00 00 00	 call	 gz_comp
  0001c	83 f8 ff	 cmp	 eax, -1
  0001f	75 0d		 jne	 SHORT $LN5@gz_zero

; 121  :         return -1;

  00021	0b c0		 or	 eax, eax

; 140  : }

  00023	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5f		 pop	 rdi
  0002d	c3		 ret	 0
$LN5@gz_zero:
  0002e	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00033	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp

; 122  : 
; 123  :     /* compress len zeros (len guaranteed > 0) */
; 124  :     first = 1;

  00038	bd 01 00 00 00	 mov	 ebp, 1

; 125  :     while (len) {

  0003d	85 f6		 test	 esi, esi
  0003f	74 46		 je	 SHORT $LN3@gz_zero
$LL4@gz_zero:

; 126  :         n = GT_OFF(state->size) || (z_off64_t)state->size > len ?
; 127  :             (unsigned)len : state->size;

  00041	8b 5f 14	 mov	 ebx, DWORD PTR [rdi+20]
  00044	81 fb ff ff ff
	7f		 cmp	 ebx, 2147483647		; 7fffffffH
  0004a	77 04		 ja	 SHORT $LN9@gz_zero
  0004c	3b de		 cmp	 ebx, esi
  0004e	7e 02		 jle	 SHORT $LN10@gz_zero
$LN9@gz_zero:
  00050	8b de		 mov	 ebx, esi
$LN10@gz_zero:

; 128  :         if (first) {

  00052	85 ed		 test	 ebp, ebp
  00054	74 10		 je	 SHORT $LN2@gz_zero

; 129  :             memset(state->in, 0, n);

  00056	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  0005a	44 8b c3	 mov	 r8d, ebx
  0005d	33 d2		 xor	 edx, edx
  0005f	e8 00 00 00 00	 call	 memset

; 130  :             first = 0;

  00064	33 ed		 xor	 ebp, ebp
$LN2@gz_zero:

; 131  :         }
; 132  :         strm->avail_in = n;

  00066	89 5f 78	 mov	 DWORD PTR [rdi+120], ebx

; 133  :         strm->next_in = state->in;

  00069	48 8b 47 20	 mov	 rax, QWORD PTR [rdi+32]

; 134  :         state->pos += n;
; 135  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  0006d	33 d2		 xor	 edx, edx
  0006f	48 89 47 70	 mov	 QWORD PTR [rdi+112], rax
  00073	01 5f 10	 add	 DWORD PTR [rdi+16], ebx
  00076	48 8b cf	 mov	 rcx, rdi
  00079	e8 00 00 00 00	 call	 gz_comp
  0007e	83 f8 ff	 cmp	 eax, -1
  00081	74 1b		 je	 SHORT $LN12@gz_zero

; 137  :         len -= n;

  00083	2b f3		 sub	 esi, ebx

; 125  :     while (len) {

  00085	75 ba		 jne	 SHORT $LL4@gz_zero
$LN3@gz_zero:

; 138  :     }
; 139  :     return 0;

  00087	33 c0		 xor	 eax, eax
$LN16@gz_zero:
  00089	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008e	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 140  : }

  00093	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00098	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009c	5f		 pop	 rdi
  0009d	c3		 ret	 0
$LN12@gz_zero:

; 136  :             return -1;

  0009e	83 c8 ff	 or	 eax, -1
  000a1	eb e6		 jmp	 SHORT $LN16@gz_zero
gz_zero	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzwrite.c
;	COMDAT gz_comp
_TEXT	SEGMENT
state$ = 48
flush$ = 56
gz_comp	PROC						; COMDAT

; 62   : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 63   :     int ret, got;
; 64   :     unsigned have;
; 65   :     z_streamp strm = &(state->strm);
; 66   : 
; 67   :     /* allocate memory if this is the first time through */
; 68   :     if (state->size == 0 && gz_init(state) == -1)

  0000f	83 79 14 00	 cmp	 DWORD PTR [rcx+20], 0
  00013	8b ea		 mov	 ebp, edx
  00015	48 8b f9	 mov	 rdi, rcx
  00018	75 1c		 jne	 SHORT $LN12@gz_comp
  0001a	e8 00 00 00 00	 call	 gz_init
  0001f	83 f8 ff	 cmp	 eax, -1
  00022	75 12		 jne	 SHORT $LN12@gz_comp

; 69   :         return -1;

  00024	0b c0		 or	 eax, eax

; 108  : }

  00026	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0002b	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5f		 pop	 rdi
  00035	c3		 ret	 0
$LN12@gz_comp:

; 70   : 
; 71   :     /* run deflate() on provided input until it produces no more output */
; 72   :     ret = Z_OK;

  00036	33 c0		 xor	 eax, eax
  00038	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0003d	0f 1f 00	 npad	 3
$LL11@gz_comp:

; 73   :     do {
; 74   :         /* write out current buffer contents if full, or if flushing, but if
; 75   :            doing Z_FINISH then don't write until we get to Z_STREAM_END */
; 76   :         if (strm->avail_out == 0 || (flush != Z_NO_FLUSH &&
; 77   :             (flush != Z_FINISH || ret == Z_STREAM_END))) {

  00040	83 bf 88 00 00
	00 00		 cmp	 DWORD PTR [rdi+136], 0
  00047	74 0e		 je	 SHORT $LN6@gz_comp
  00049	85 ed		 test	 ebp, ebp
  0004b	74 55		 je	 SHORT $LN8@gz_comp
  0004d	83 fd 04	 cmp	 ebp, 4
  00050	75 05		 jne	 SHORT $LN6@gz_comp
  00052	83 f8 01	 cmp	 eax, 1
  00055	75 4b		 jne	 SHORT $LN8@gz_comp
$LN6@gz_comp:

; 78   :             have = (unsigned)(strm->next_out - state->next);

  00057	8b b7 80 00 00
	00		 mov	 esi, DWORD PTR [rdi+128]
  0005d	2b 77 30	 sub	 esi, DWORD PTR [rdi+48]

; 79   :             if (have && ((got = write(state->fd, state->next, have)) < 0 ||
; 80   :                          (unsigned)got != have)) {

  00060	74 18		 je	 SHORT $LN5@gz_comp
  00062	48 8b 57 30	 mov	 rdx, QWORD PTR [rdi+48]
  00066	8b 4f 04	 mov	 ecx, DWORD PTR [rdi+4]
  00069	44 8b c6	 mov	 r8d, esi
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_write
  00072	85 c0		 test	 eax, eax
  00074	78 5c		 js	 SHORT $LN4@gz_comp
  00076	3b c6		 cmp	 eax, esi
  00078	75 58		 jne	 SHORT $LN4@gz_comp
$LN5@gz_comp:

; 83   :             }
; 84   :             if (strm->avail_out == 0) {

  0007a	83 bf 88 00 00
	00 00		 cmp	 DWORD PTR [rdi+136], 0
  00081	75 14		 jne	 SHORT $LN3@gz_comp

; 85   :                 strm->avail_out = state->size;

  00083	8b 47 14	 mov	 eax, DWORD PTR [rdi+20]
  00086	89 87 88 00 00
	00		 mov	 DWORD PTR [rdi+136], eax

; 86   :                 strm->next_out = state->out;

  0008c	48 8b 47 28	 mov	 rax, QWORD PTR [rdi+40]
  00090	48 89 87 80 00
	00 00		 mov	 QWORD PTR [rdi+128], rax
$LN3@gz_comp:

; 87   :             }
; 88   :             state->next = strm->next_out;

  00097	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  0009e	48 89 47 30	 mov	 QWORD PTR [rdi+48], rax
$LN8@gz_comp:

; 89   :         }
; 90   : 
; 91   :         /* compress */
; 92   :         have = strm->avail_out;

  000a2	8b b7 88 00 00
	00		 mov	 esi, DWORD PTR [rdi+136]

; 93   :         ret = deflate(strm, flush);

  000a8	48 8d 4f 70	 lea	 rcx, QWORD PTR [rdi+112]
  000ac	8b d5		 mov	 edx, ebp
  000ae	e8 00 00 00 00	 call	 deflate

; 94   :         if (ret == Z_STREAM_ERROR) {

  000b3	83 f8 fe	 cmp	 eax, -2
  000b6	74 30		 je	 SHORT $LN17@gz_comp

; 98   :         }
; 99   :         have -= strm->avail_out;

  000b8	3b b7 88 00 00
	00		 cmp	 esi, DWORD PTR [rdi+136]

; 100  :     } while (have);

  000be	75 80		 jne	 SHORT $LL11@gz_comp

; 101  : 
; 102  :     /* if that completed a deflate stream, allow another to start */
; 103  :     if (flush == Z_FINISH)

  000c0	83 fd 04	 cmp	 ebp, 4
  000c3	75 09		 jne	 SHORT $LN1@gz_comp

; 104  :         deflateReset(strm);

  000c5	48 8d 4f 70	 lea	 rcx, QWORD PTR [rdi+112]
  000c9	e8 00 00 00 00	 call	 deflateReset
$LN1@gz_comp:

; 105  : 
; 106  :     /* all done, no errors */
; 107  :     return 0;

  000ce	33 c0		 xor	 eax, eax
  000d0	eb 2d		 jmp	 SHORT $LN19@gz_comp
$LN4@gz_comp:

; 81   :                 gz_error(state, Z_ERRNO, zstrerror());

  000d2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000d8	8b 08		 mov	 ecx, DWORD PTR [rax]
  000da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  000e0	83 ca ff	 or	 edx, -1
  000e3	4c 8b c0	 mov	 r8, rax

; 82   :                 return -1;

  000e6	eb 0c		 jmp	 SHORT $LN20@gz_comp
$LN17@gz_comp:

; 95   :             gz_error(state, Z_STREAM_ERROR,
; 96   :                       "internal error: deflate stream corrupt");

  000e8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CH@DEEGAHIB@internal?5error?3?5deflate?5stream?5c@
  000ef	ba fe ff ff ff	 mov	 edx, -2
$LN20@gz_comp:
  000f4	48 8b cf	 mov	 rcx, rdi
  000f7	e8 00 00 00 00	 call	 gz_error

; 97   :             return -1;

  000fc	83 c8 ff	 or	 eax, -1
$LN19@gz_comp:

; 108  : }

  000ff	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00104	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00109	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0010e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00112	5f		 pop	 rdi
  00113	c3		 ret	 0
gz_comp	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzwrite.c
;	COMDAT gz_init
_TEXT	SEGMENT
state$ = 80
gz_init	PROC						; COMDAT

; 17   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 18   :     int ret;
; 19   :     z_streamp strm = &(state->strm);
; 20   : 
; 21   :     /* allocate input and output buffers */
; 22   :     state->in = malloc(state->want);

  00014	8b 59 18	 mov	 ebx, DWORD PTR [rcx+24]
  00017	48 8b f1	 mov	 rsi, rcx
  0001a	8b cb		 mov	 ecx, ebx
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 23   :     state->out = malloc(state->want);

  00022	8b cb		 mov	 ecx, ebx
  00024	48 8b f8	 mov	 rdi, rax
  00027	48 89 46 20	 mov	 QWORD PTR [rsi+32], rax
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00031	48 89 46 28	 mov	 QWORD PTR [rsi+40], rax

; 24   :     if (state->in == NULL || state->out == NULL) {

  00035	48 85 ff	 test	 rdi, rdi
  00038	0f 84 82 00 00
	00		 je	 $LN4@gz_init
  0003e	48 85 c0	 test	 rax, rax
  00041	0f 84 87 00 00
	00		 je	 $LN3@gz_init

; 31   :     }
; 32   : 
; 33   :     /* allocate deflate memory, set up for gzip compression */
; 34   :     strm->zalloc = Z_NULL;

  00047	33 c0		 xor	 eax, eax

; 35   :     strm->zfree = Z_NULL;
; 36   :     strm->opaque = Z_NULL;
; 37   :     ret = deflateInit2(strm, state->level, Z_DEFLATED,
; 38   :                        15 + 16, 8, state->strategy);

  00049	c7 44 24 38 58
	00 00 00	 mov	 DWORD PTR [rsp+56], 88	; 00000058H
  00051	41 b9 1f 00 00
	00		 mov	 r9d, 31
  00057	48 89 86 a0 00
	00 00		 mov	 QWORD PTR [rsi+160], rax
  0005e	48 89 86 a8 00
	00 00		 mov	 QWORD PTR [rsi+168], rax
  00065	48 89 86 b0 00
	00 00		 mov	 QWORD PTR [rsi+176], rax
  0006c	8b 56 50	 mov	 edx, DWORD PTR [rsi+80]
  0006f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05DFCKICEH@1?42?45?$AA@
  00076	45 8d 41 e9	 lea	 r8d, QWORD PTR [r9-23]
  0007a	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0007f	8b 46 54	 mov	 eax, DWORD PTR [rsi+84]
  00082	48 8d 4e 70	 lea	 rcx, QWORD PTR [rsi+112]
  00086	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  0008a	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  00092	e8 00 00 00 00	 call	 deflateInit2_

; 39   :     if (ret != Z_OK) {

  00097	85 c0		 test	 eax, eax
  00099	74 06		 je	 SHORT $LN1@gz_init

; 40   :         free(state->in);

  0009b	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]

; 41   :         gz_error(state, Z_MEM_ERROR, "out of memory");
; 42   :         return -1;

  0009f	eb 36		 jmp	 SHORT $LN8@gz_init
$LN1@gz_init:

; 43   :     }
; 44   : 
; 45   :     /* mark state as initialized */
; 46   :     state->size = state->want;

  000a1	8b 46 18	 mov	 eax, DWORD PTR [rsi+24]
  000a4	89 46 14	 mov	 DWORD PTR [rsi+20], eax

; 47   : 
; 48   :     /* initialize write buffer */
; 49   :     strm->avail_out = state->size;

  000a7	89 86 88 00 00
	00		 mov	 DWORD PTR [rsi+136], eax

; 50   :     strm->next_out = state->out;

  000ad	48 8b 46 28	 mov	 rax, QWORD PTR [rsi+40]
  000b1	48 89 86 80 00
	00 00		 mov	 QWORD PTR [rsi+128], rax

; 51   :     state->next = strm->next_out;

  000b8	48 89 46 30	 mov	 QWORD PTR [rsi+48], rax

; 52   :     return 0;

  000bc	33 c0		 xor	 eax, eax
  000be	eb 34		 jmp	 SHORT $LN6@gz_init
$LN4@gz_init:

; 25   :         if (state->out != NULL)

  000c0	48 85 c0	 test	 rax, rax
  000c3	74 09		 je	 SHORT $LN3@gz_init

; 26   :             free(state->out);

  000c5	48 8b c8	 mov	 rcx, rax
  000c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@gz_init:

; 27   :         if (state->in != NULL)

  000ce	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
  000d2	48 85 c9	 test	 rcx, rcx
  000d5	74 06		 je	 SHORT $LN2@gz_init
$LN8@gz_init:

; 28   :             free(state->in);

  000d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@gz_init:

; 29   :         gz_error(state, Z_MEM_ERROR, "out of memory");

  000dd	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000e4	ba fc ff ff ff	 mov	 edx, -4
  000e9	48 8b ce	 mov	 rcx, rsi
  000ec	e8 00 00 00 00	 call	 gz_error

; 30   :         return -1;

  000f1	83 c8 ff	 or	 eax, -1
$LN6@gz_init:

; 53   : }

  000f4	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000f9	48 8b 6c 24 58	 mov	 rbp, QWORD PTR [rsp+88]
  000fe	48 8b 74 24 60	 mov	 rsi, QWORD PTR [rsp+96]
  00103	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00107	5f		 pop	 rdi
  00108	c3		 ret	 0
gz_init	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzwrite.c
;	COMDAT gzclose_w
_TEXT	SEGMENT
file$ = 48
gzclose_w PROC						; COMDAT

; 502  : {

$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 503  :     int ret = 0;

  0000a	33 ff		 xor	 edi, edi
  0000c	48 8b d9	 mov	 rbx, rcx

; 504  :     gz_statep state;
; 505  : 
; 506  :     /* get internal structure */
; 507  :     if (file == NULL)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	75 10		 jne	 SHORT $LN3@gzclose_w
$LN6@gzclose_w:

; 508  :         return Z_STREAM_ERROR;

  00014	b8 fe ff ff ff	 mov	 eax, -2

; 530  :     return ret ? Z_ERRNO : Z_OK;
; 531  : }

  00019	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5f		 pop	 rdi
  00023	c3		 ret	 0
$LN3@gzclose_w:

; 509  :     state = (gz_statep)file;
; 510  : 
; 511  :     /* check that we're writing */
; 512  :     if (state->mode != GZ_WRITE)

  00024	81 39 b1 79 00
	00		 cmp	 DWORD PTR [rcx], 31153	; 000079b1H
  0002a	75 e8		 jne	 SHORT $LN6@gzclose_w

; 513  :         return Z_STREAM_ERROR;
; 514  : 
; 515  :     /* check for seek request */
; 516  :     if (state->seek) {

  0002c	39 79 5c	 cmp	 DWORD PTR [rcx+92], edi
  0002f	74 0d		 je	 SHORT $LN1@gzclose_w

; 517  :         state->seek = 0;
; 518  :         ret += gz_zero(state, state->skip);

  00031	8b 51 58	 mov	 edx, DWORD PTR [rcx+88]
  00034	89 79 5c	 mov	 DWORD PTR [rcx+92], edi
  00037	e8 00 00 00 00	 call	 gz_zero
  0003c	8b f8		 mov	 edi, eax
$LN1@gzclose_w:

; 519  :     }
; 520  : 
; 521  :     /* flush, free memory, and close file */
; 522  :     ret += gz_comp(state, Z_FINISH);

  0003e	ba 04 00 00 00	 mov	 edx, 4
  00043	48 8b cb	 mov	 rcx, rbx
  00046	e8 00 00 00 00	 call	 gz_comp

; 523  :     (void)deflateEnd(&(state->strm));

  0004b	48 8d 4b 70	 lea	 rcx, QWORD PTR [rbx+112]
  0004f	03 f8		 add	 edi, eax
  00051	e8 00 00 00 00	 call	 deflateEnd

; 524  :     free(state->out);

  00056	48 8b 4b 28	 mov	 rcx, QWORD PTR [rbx+40]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 525  :     free(state->in);

  00060	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00064	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 526  :     gz_error(state, Z_OK, NULL);

  0006a	45 33 c0	 xor	 r8d, r8d
  0006d	33 d2		 xor	 edx, edx
  0006f	48 8b cb	 mov	 rcx, rbx
  00072	e8 00 00 00 00	 call	 gz_error

; 527  :     free(state->path);

  00077	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0007b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 528  :     ret += close(state->fd);

  00081	8b 4b 04	 mov	 ecx, DWORD PTR [rbx+4]
  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 529  :     free(state);

  0008a	48 8b cb	 mov	 rcx, rbx
  0008d	03 f8		 add	 edi, eax
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 530  :     return ret ? Z_ERRNO : Z_OK;
; 531  : }

  00095	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009a	f7 df		 neg	 edi
  0009c	1b c0		 sbb	 eax, eax
  0009e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a2	5f		 pop	 rdi
  000a3	c3		 ret	 0
gzclose_w ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzwrite.c
;	COMDAT gzflush
_TEXT	SEGMENT
file$ = 48
flush$ = 56
gzflush	PROC						; COMDAT

; 429  : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b fa		 mov	 edi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 430  :     gz_statep state;
; 431  : 
; 432  :     /* get internal structure */
; 433  :     if (file == NULL)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	75 0e		 jne	 SHORT $LN7@gzflush
$LN10@gzflush:

; 434  :         return -1;

  00014	83 c8 ff	 or	 eax, -1

; 455  : }

  00017	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5f		 pop	 rdi
  00021	c3		 ret	 0
$LN7@gzflush:

; 435  :     state = (gz_statep)file;
; 436  : 
; 437  :     /* check that we're writing and that there's no error */
; 438  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00022	81 39 b1 79 00
	00		 cmp	 DWORD PTR [rcx], 31153	; 000079b1H
  00028	75 3d		 jne	 SHORT $LN5@gzflush
  0002a	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0002e	75 37		 jne	 SHORT $LN5@gzflush

; 440  : 
; 441  :     /* check flush parameter */
; 442  :     if (flush < 0 || flush > Z_FINISH)

  00030	83 fa 04	 cmp	 edx, 4
  00033	77 32		 ja	 SHORT $LN5@gzflush

; 443  :         return Z_STREAM_ERROR;
; 444  : 
; 445  :     /* check for seek request */
; 446  :     if (state->seek) {

  00035	83 79 5c 00	 cmp	 DWORD PTR [rcx+92], 0
  00039	74 14		 je	 SHORT $LN1@gzflush

; 447  :         state->seek = 0;
; 448  :         if (gz_zero(state, state->skip) == -1)

  0003b	8b 51 58	 mov	 edx, DWORD PTR [rcx+88]
  0003e	c7 41 5c 00 00
	00 00		 mov	 DWORD PTR [rcx+92], 0
  00045	e8 00 00 00 00	 call	 gz_zero
  0004a	83 f8 ff	 cmp	 eax, -1
  0004d	74 c5		 je	 SHORT $LN10@gzflush
$LN1@gzflush:

; 449  :             return -1;
; 450  :     }
; 451  : 
; 452  :     /* compress remaining data with requested flush */
; 453  :     gz_comp(state, flush);

  0004f	8b d7		 mov	 edx, edi
  00051	48 8b cb	 mov	 rcx, rbx
  00054	e8 00 00 00 00	 call	 gz_comp

; 454  :     return state->err;

  00059	8b 43 60	 mov	 eax, DWORD PTR [rbx+96]

; 455  : }

  0005c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5f		 pop	 rdi
  00066	c3		 ret	 0
$LN5@gzflush:

; 439  :         return Z_STREAM_ERROR;

  00067	b8 fe ff ff ff	 mov	 eax, -2

; 455  : }

  0006c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00071	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
gzflush	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzwrite.c
;	COMDAT gzputc
_TEXT	SEGMENT
buf$ = 48
file$ = 48
c$ = 56
gzputc	PROC						; COMDAT

; 224  : {

$LN12:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b fa		 mov	 edi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 225  :     unsigned char buf[1];
; 226  :     gz_statep state;
; 227  :     z_streamp strm;
; 228  : 
; 229  :     /* get internal structure */
; 230  :     if (file == NULL)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	0f 84 85 00 00
	00		 je	 $LN6@gzputc

; 231  :         return -1;
; 232  :     state = (gz_statep)file;
; 233  :     strm = &(state->strm);
; 234  : 
; 235  :     /* check that we're writing and that there's no error */
; 236  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00018	81 39 b1 79 00
	00		 cmp	 DWORD PTR [rcx], 31153	; 000079b1H
  0001e	75 7d		 jne	 SHORT $LN6@gzputc
  00020	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00024	75 77		 jne	 SHORT $LN6@gzputc

; 238  : 
; 239  :     /* check for seek request */
; 240  :     if (state->seek) {

  00026	83 79 5c 00	 cmp	 DWORD PTR [rcx+92], 0
  0002a	74 14		 je	 SHORT $LN4@gzputc

; 241  :         state->seek = 0;
; 242  :         if (gz_zero(state, state->skip) == -1)

  0002c	8b 51 58	 mov	 edx, DWORD PTR [rcx+88]
  0002f	c7 41 5c 00 00
	00 00		 mov	 DWORD PTR [rcx+92], 0
  00036	e8 00 00 00 00	 call	 gz_zero
  0003b	83 f8 ff	 cmp	 eax, -1
  0003e	74 5d		 je	 SHORT $LN6@gzputc
$LN4@gzputc:

; 243  :             return -1;
; 244  :     }
; 245  : 
; 246  :     /* try writing to input buffer for speed (state->size == 0 if buffer not
; 247  :        initialized) */
; 248  :     if (strm->avail_in < state->size) {

  00040	8b 4b 78	 mov	 ecx, DWORD PTR [rbx+120]
  00043	3b 4b 14	 cmp	 ecx, DWORD PTR [rbx+20]
  00046	73 27		 jae	 SHORT $LN3@gzputc

; 249  :         if (strm->avail_in == 0)

  00048	85 c9		 test	 ecx, ecx
  0004a	75 08		 jne	 SHORT $LN2@gzputc

; 250  :             strm->next_in = state->in;

  0004c	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00050	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax
$LN2@gzputc:

; 251  :         strm->next_in[strm->avail_in++] = c;

  00054	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  00058	40 88 3c 01	 mov	 BYTE PTR [rcx+rax], dil
  0005c	ff 43 78	 inc	 DWORD PTR [rbx+120]

; 252  :         state->pos++;

  0005f	ff 43 10	 inc	 DWORD PTR [rbx+16]

; 253  :         return c;

  00062	8b c7		 mov	 eax, edi

; 259  :         return -1;
; 260  :     return c;
; 261  : }

  00064	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00069	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006d	5f		 pop	 rdi
  0006e	c3		 ret	 0
$LN3@gzputc:

; 254  :     }
; 255  : 
; 256  :     /* no room in buffer or not initialized, use gz_write() */
; 257  :     buf[0] = c;
; 258  :     if (gzwrite(file, buf, 1) != 1)

  0006f	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00074	41 b8 01 00 00
	00		 mov	 r8d, 1
  0007a	48 8b cb	 mov	 rcx, rbx
  0007d	40 88 7c 24 30	 mov	 BYTE PTR buf$[rsp], dil
  00082	e8 00 00 00 00	 call	 gzwrite
  00087	83 c9 ff	 or	 ecx, -1
  0008a	83 f8 01	 cmp	 eax, 1
  0008d	0f 45 f9	 cmovne	 edi, ecx
  00090	8b c7		 mov	 eax, edi

; 259  :         return -1;
; 260  :     return c;
; 261  : }

  00092	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00097	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009b	5f		 pop	 rdi
  0009c	c3		 ret	 0
$LN6@gzputc:

; 237  :         return -1;

  0009d	83 c8 ff	 or	 eax, -1

; 259  :         return -1;
; 260  :     return c;
; 261  : }

  000a0	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000a5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a9	5f		 pop	 rdi
  000aa	c3		 ret	 0
gzputc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzwrite.c
;	COMDAT gzputs
_TEXT	SEGMENT
file$ = 48
str$ = 56
gzputs	PROC						; COMDAT

; 267  : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 268  :     int ret;
; 269  :     unsigned len;
; 270  : 
; 271  :     /* write string */
; 272  :     len = (unsigned)strlen(str);

  00006	48 83 cb ff	 or	 rbx, -1
  0000a	66 0f 1f 44 00
	00		 npad	 6
$LL5@gzputs:
  00010	48 ff c3	 inc	 rbx
  00013	80 3c 1a 00	 cmp	 BYTE PTR [rdx+rbx], 0
  00017	75 f7		 jne	 SHORT $LL5@gzputs

; 273  :     ret = gzwrite(file, str, len);

  00019	44 8b c3	 mov	 r8d, ebx
  0001c	e8 00 00 00 00	 call	 gzwrite

; 274  :     return ret == 0 && len != 0 ? -1 : ret;

  00021	85 c0		 test	 eax, eax
  00023	75 07		 jne	 SHORT $LN3@gzputs
  00025	85 db		 test	 ebx, ebx
  00027	74 03		 je	 SHORT $LN3@gzputs
  00029	83 c8 ff	 or	 eax, -1
$LN3@gzputs:

; 275  : }

  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5b		 pop	 rbx
  00031	c3		 ret	 0
gzputs	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzwrite.c
;	COMDAT gzprintf
_TEXT	SEGMENT
file$ = 64
format$ = 72
gzprintf PROC						; COMDAT

; 282  : {

$LN16:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  0000f	53		 push	 rbx
  00010	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00014	48 8b d9	 mov	 rbx, rcx

; 283  :     int size, len;
; 284  :     gz_statep state;
; 285  :     z_streamp strm;
; 286  :     va_list va;
; 287  : 
; 288  :     /* get internal structure */
; 289  :     if (file == NULL)

  00017	48 85 c9	 test	 rcx, rcx
  0001a	75 09		 jne	 SHORT $LN9@gzprintf

; 290  :         return -1;

  0001c	83 c8 ff	 or	 eax, -1

; 346  :     return len;
; 347  : }

  0001f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00023	5b		 pop	 rbx
  00024	c3		 ret	 0
$LN9@gzprintf:

; 291  :     state = (gz_statep)file;
; 292  :     strm = &(state->strm);
; 293  : 
; 294  :     /* check that we're writing and that there's no error */
; 295  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  00025	81 39 b1 79 00
	00		 cmp	 DWORD PTR [rcx], 31153	; 000079b1H
  0002b	75 16		 jne	 SHORT $LN14@gzprintf
  0002d	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00031	75 10		 jne	 SHORT $LN14@gzprintf

; 296  :         return 0;
; 297  : 
; 298  :     /* make sure we have some buffer space */
; 299  :     if (state->size == 0 && gz_init(state) == -1)

  00033	83 79 14 00	 cmp	 DWORD PTR [rcx+20], 0
  00037	75 12		 jne	 SHORT $LN6@gzprintf
  00039	e8 00 00 00 00	 call	 gz_init
  0003e	83 f8 ff	 cmp	 eax, -1
  00041	75 08		 jne	 SHORT $LN6@gzprintf
$LN14@gzprintf:

; 300  :         return 0;

  00043	33 c0		 xor	 eax, eax

; 346  :     return len;
; 347  : }

  00045	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
$LN6@gzprintf:

; 301  : 
; 302  :     /* check for seek request */
; 303  :     if (state->seek) {

  0004b	83 7b 5c 00	 cmp	 DWORD PTR [rbx+92], 0
  0004f	74 17		 je	 SHORT $LN4@gzprintf

; 304  :         state->seek = 0;
; 305  :         if (gz_zero(state, state->skip) == -1)

  00051	8b 53 58	 mov	 edx, DWORD PTR [rbx+88]
  00054	48 8b cb	 mov	 rcx, rbx
  00057	c7 43 5c 00 00
	00 00		 mov	 DWORD PTR [rbx+92], 0
  0005e	e8 00 00 00 00	 call	 gz_zero
  00063	83 f8 ff	 cmp	 eax, -1
  00066	74 db		 je	 SHORT $LN14@gzprintf
$LN4@gzprintf:

; 306  :             return 0;
; 307  :     }
; 308  : 
; 309  :     /* consume whatever's left in the input buffer */
; 310  :     if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  00068	83 7b 78 00	 cmp	 DWORD PTR [rbx+120], 0
  0006c	74 0f		 je	 SHORT $LN3@gzprintf
  0006e	33 d2		 xor	 edx, edx
  00070	48 8b cb	 mov	 rcx, rbx
  00073	e8 00 00 00 00	 call	 gz_comp
  00078	83 f8 ff	 cmp	 eax, -1
  0007b	74 c6		 je	 SHORT $LN14@gzprintf
$LN3@gzprintf:

; 311  :         return 0;
; 312  : 
; 313  :     /* do the printf() into the input buffer, put length in len */
; 314  :     size = (int)(state->size);
; 315  :     state->in[size - 1] = 0;

  0007d	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00081	48 89 74 24 28	 mov	 QWORD PTR [rsp+40], rsi
  00086	48 63 73 14	 movsxd	 rsi, DWORD PTR [rbx+20]
  0008a	c6 44 30 ff 00	 mov	 BYTE PTR [rax+rsi-1], 0

; 316  :     va_start(va, format);
; 317  : #ifdef NO_vsnprintf
; 318  : #  ifdef HAS_vsprintf_void
; 319  :     (void)vsprintf(state->in, format, va);
; 320  :     va_end(va);
; 321  :     for (len = 0; len < size; len++)
; 322  :         if (state->in[len] == 0) break;
; 323  : #  else
; 324  :     len = vsprintf(state->in, format, va);
; 325  :     va_end(va);
; 326  : #  endif
; 327  : #else
; 328  : #  ifdef HAS_vsnprintf_void
; 329  :     (void)vsnprintf(state->in, size, format, va);
; 330  :     va_end(va);
; 331  :     len = strlen(state->in);
; 332  : #  else
; 333  :     len = vsnprintf((char *)(state->in), size, format, va);

  0008f	4c 8b 44 24 48	 mov	 r8, QWORD PTR format$[rsp]
  00094	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  00098	4c 8d 4c 24 50	 lea	 r9, QWORD PTR format$[rsp+8]
  0009d	48 8b d6	 mov	 rdx, rsi
  000a0	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__vsnprintf

; 334  :     va_end(va);
; 335  : #  endif
; 336  : #endif
; 337  : 
; 338  :     /* check that printf() results fit in buffer */
; 339  :     if (len <= 0 || len >= (int)size || state->in[size - 1] != 0)

  000ab	85 c0		 test	 eax, eax
  000ad	7e 29		 jle	 SHORT $LN1@gzprintf
  000af	3b c6		 cmp	 eax, esi
  000b1	7d 25		 jge	 SHORT $LN1@gzprintf
  000b3	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
  000b7	80 7c 31 ff 00	 cmp	 BYTE PTR [rcx+rsi-1], 0
  000bc	75 1a		 jne	 SHORT $LN1@gzprintf

; 341  : 
; 342  :     /* update buffer and position, defer compression until needed */
; 343  :     strm->avail_in = (unsigned)len;

  000be	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  000c3	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]
  000c8	89 43 78	 mov	 DWORD PTR [rbx+120], eax

; 344  :     strm->next_in = state->in;

  000cb	48 89 4b 70	 mov	 QWORD PTR [rbx+112], rcx

; 345  :     state->pos += len;

  000cf	01 43 10	 add	 DWORD PTR [rbx+16], eax

; 346  :     return len;
; 347  : }

  000d2	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000d6	5b		 pop	 rbx
  000d7	c3		 ret	 0
$LN1@gzprintf:
  000d8	48 8b 74 24 28	 mov	 rsi, QWORD PTR [rsp+40]
  000dd	48 8b 7c 24 20	 mov	 rdi, QWORD PTR [rsp+32]

; 340  :         return 0;

  000e2	33 c0		 xor	 eax, eax

; 346  :     return len;
; 347  : }

  000e4	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e8	5b		 pop	 rbx
  000e9	c3		 ret	 0
gzprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzwrite.c
;	COMDAT gzwrite
_TEXT	SEGMENT
file$ = 64
buf$ = 72
len$ = 80
gzwrite	PROC						; COMDAT

; 147  : {

$LN31:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	55		 push	 rbp
  00006	41 56		 push	 r14
  00008	41 57		 push	 r15
  0000a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000e	41 8b e8	 mov	 ebp, r8d
  00011	4c 8b f2	 mov	 r14, rdx
  00014	48 8b d9	 mov	 rbx, rcx

; 148  :     unsigned put = len;

  00017	45 8b f8	 mov	 r15d, r8d

; 149  :     unsigned n;
; 150  :     gz_statep state;
; 151  :     z_streamp strm;
; 152  : 
; 153  :     /* get internal structure */
; 154  :     if (file == NULL)

  0001a	48 85 c9	 test	 rcx, rcx
  0001d	74 24		 je	 SHORT $LN29@gzwrite

; 155  :         return 0;
; 156  :     state = (gz_statep)file;
; 157  :     strm = &(state->strm);
; 158  : 
; 159  :     /* check that we're writing and that there's no error */
; 160  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0001f	81 39 b1 79 00
	00		 cmp	 DWORD PTR [rcx], 31153	; 000079b1H
  00025	75 1c		 jne	 SHORT $LN29@gzwrite
  00027	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0002b	75 16		 jne	 SHORT $LN29@gzwrite

; 161  :         return 0;
; 162  : 
; 163  :     /* since an int is returned, make sure len fits in one, otherwise return
; 164  :        with an error (this avoids the flaw in the interface) */
; 165  :     if ((int)len < 0) {

  0002d	45 85 c0	 test	 r8d, r8d
  00030	79 22		 jns	 SHORT $LN27@gzwrite

; 166  :         gz_error(state, Z_BUF_ERROR, "requested length does not fit in int");

  00032	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  00039	ba fb ff ff ff	 mov	 edx, -5
  0003e	e8 00 00 00 00	 call	 gz_error
$LN29@gzwrite:

; 167  :         return 0;

  00043	33 c0		 xor	 eax, eax

; 218  : }

  00045	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	41 5f		 pop	 r15
  00050	41 5e		 pop	 r14
  00052	5d		 pop	 rbp
  00053	c3		 ret	 0
$LN27@gzwrite:

; 168  :     }
; 169  : 
; 170  :     /* if len is zero, avoid unnecessary operations */
; 171  :     if (len == 0)

  00054	74 ed		 je	 SHORT $LN29@gzwrite

; 172  :         return 0;
; 173  : 
; 174  :     /* allocate memory if this is the first time through */
; 175  :     if (state->size == 0 && gz_init(state) == -1)

  00056	83 79 14 00	 cmp	 DWORD PTR [rcx+20], 0
  0005a	75 0a		 jne	 SHORT $LN13@gzwrite
  0005c	e8 00 00 00 00	 call	 gz_init
  00061	83 f8 ff	 cmp	 eax, -1
  00064	74 dd		 je	 SHORT $LN29@gzwrite
$LN13@gzwrite:

; 176  :         return 0;
; 177  : 
; 178  :     /* check for seek request */
; 179  :     if (state->seek) {

  00066	83 7b 5c 00	 cmp	 DWORD PTR [rbx+92], 0
  0006a	74 17		 je	 SHORT $LN11@gzwrite

; 180  :         state->seek = 0;
; 181  :         if (gz_zero(state, state->skip) == -1)

  0006c	8b 53 58	 mov	 edx, DWORD PTR [rbx+88]
  0006f	48 8b cb	 mov	 rcx, rbx
  00072	c7 43 5c 00 00
	00 00		 mov	 DWORD PTR [rbx+92], 0
  00079	e8 00 00 00 00	 call	 gz_zero
  0007e	83 f8 ff	 cmp	 eax, -1
  00081	74 c0		 je	 SHORT $LN29@gzwrite
$LN11@gzwrite:
  00083	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00088	48 89 7c 24 48	 mov	 QWORD PTR [rsp+72], rdi

; 182  :             return 0;
; 183  :     }
; 184  : 
; 185  :     /* for small len, copy to input buffer, otherwise compress directly */
; 186  :     if (len < state->size) {

  0008d	3b 6b 14	 cmp	 ebp, DWORD PTR [rbx+20]
  00090	73 4a		 jae	 SHORT $LN10@gzwrite
$LL9@gzwrite:

; 187  :         /* copy to input buffer, compress when full */
; 188  :         do {
; 189  :             if (strm->avail_in == 0)

  00092	8b 4b 78	 mov	 ecx, DWORD PTR [rbx+120]
  00095	85 c9		 test	 ecx, ecx
  00097	75 08		 jne	 SHORT $LN6@gzwrite

; 190  :                 strm->next_in = state->in;

  00099	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0009d	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax
$LN6@gzwrite:

; 191  :             n = state->size - strm->avail_in;

  000a1	8b 73 14	 mov	 esi, DWORD PTR [rbx+20]

; 192  :             if (n > len)
; 193  :                 n = len;
; 194  :             memcpy(strm->next_in + strm->avail_in, buf, n);

  000a4	49 8b d6	 mov	 rdx, r14
  000a7	2b f1		 sub	 esi, ecx
  000a9	3b f5		 cmp	 esi, ebp
  000ab	0f 47 f5	 cmova	 esi, ebp
  000ae	48 03 4b 70	 add	 rcx, QWORD PTR [rbx+112]
  000b2	44 8b c6	 mov	 r8d, esi
  000b5	8b fe		 mov	 edi, esi
  000b7	e8 00 00 00 00	 call	 memcpy

; 195  :             strm->avail_in += n;

  000bc	01 73 78	 add	 DWORD PTR [rbx+120], esi

; 196  :             state->pos += n;

  000bf	01 73 10	 add	 DWORD PTR [rbx+16], esi

; 197  :             buf = (char *)buf + n;

  000c2	4c 03 f7	 add	 r14, rdi

; 198  :             len -= n;

  000c5	2b ee		 sub	 ebp, esi

; 199  :             if (len && gz_comp(state, Z_NO_FLUSH) == -1)

  000c7	74 41		 je	 SHORT $LN1@gzwrite
  000c9	33 d2		 xor	 edx, edx
  000cb	48 8b cb	 mov	 rcx, rbx
  000ce	e8 00 00 00 00	 call	 gz_comp
  000d3	83 f8 ff	 cmp	 eax, -1
  000d6	75 ba		 jne	 SHORT $LL9@gzwrite
$LN28@gzwrite:

; 200  :                 return 0;

  000d8	33 c0		 xor	 eax, eax
  000da	eb 31		 jmp	 SHORT $LN26@gzwrite
$LN10@gzwrite:

; 201  :         } while (len);
; 202  :     }
; 203  :     else {
; 204  :         /* consume whatever's left in the input buffer */
; 205  :         if (strm->avail_in && gz_comp(state, Z_NO_FLUSH) == -1)

  000dc	83 7b 78 00	 cmp	 DWORD PTR [rbx+120], 0
  000e0	74 0f		 je	 SHORT $LN2@gzwrite
  000e2	33 d2		 xor	 edx, edx
  000e4	48 8b cb	 mov	 rcx, rbx
  000e7	e8 00 00 00 00	 call	 gz_comp
  000ec	83 f8 ff	 cmp	 eax, -1
  000ef	74 e7		 je	 SHORT $LN28@gzwrite
$LN2@gzwrite:

; 206  :             return 0;
; 207  : 
; 208  :         /* directly compress user buffer to file */
; 209  :         strm->avail_in = len;

  000f1	89 6b 78	 mov	 DWORD PTR [rbx+120], ebp

; 210  :         strm->next_in = (voidp)buf;

  000f4	4c 89 73 70	 mov	 QWORD PTR [rbx+112], r14

; 211  :         state->pos += len;

  000f8	01 6b 10	 add	 DWORD PTR [rbx+16], ebp

; 212  :         if (gz_comp(state, Z_NO_FLUSH) == -1)

  000fb	33 d2		 xor	 edx, edx
  000fd	48 8b cb	 mov	 rcx, rbx
  00100	e8 00 00 00 00	 call	 gz_comp
  00105	83 f8 ff	 cmp	 eax, -1
  00108	74 ce		 je	 SHORT $LN28@gzwrite
$LN1@gzwrite:

; 213  :             return 0;
; 214  :     }
; 215  : 
; 216  :     /* input was all buffered or compressed (put will fit in int) */
; 217  :     return (int)put;

  0010a	41 8b c7	 mov	 eax, r15d
$LN26@gzwrite:
  0010d	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00112	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]

; 218  : }

  00117	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0011c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00120	41 5f		 pop	 r15
  00122	41 5e		 pop	 r14
  00124	5d		 pop	 rbp
  00125	c3		 ret	 0
gzwrite	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzwrite.c
;	COMDAT gzsetparams
_TEXT	SEGMENT
file$ = 48
level$ = 56
strategy$ = 64
gzsetparams PROC					; COMDAT

; 462  : {

$LN14:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	41 8b f8	 mov	 edi, r8d
  00012	8b f2		 mov	 esi, edx
  00014	48 8b d9	 mov	 rbx, rcx

; 463  :     gz_statep state;
; 464  :     z_streamp strm;
; 465  : 
; 466  :     /* get internal structure */
; 467  :     if (file == NULL)

  00017	48 85 c9	 test	 rcx, rcx
  0001a	75 13		 jne	 SHORT $LN8@gzsetparam

; 468  :         return Z_STREAM_ERROR;

  0001c	8d 41 fe	 lea	 eax, QWORD PTR [rcx-2]

; 497  : }

  0001f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00024	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00029	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002d	5f		 pop	 rdi
  0002e	c3		 ret	 0
$LN8@gzsetparam:

; 469  :     state = (gz_statep)file;
; 470  :     strm = &(state->strm);
; 471  : 
; 472  :     /* check that we're writing and that there's no error */
; 473  :     if (state->mode != GZ_WRITE || state->err != Z_OK)

  0002f	81 39 b1 79 00
	00		 cmp	 DWORD PTR [rcx], 31153	; 000079b1H
  00035	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  0003a	75 6a		 jne	 SHORT $LN6@gzsetparam
  0003c	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00040	75 64		 jne	 SHORT $LN6@gzsetparam

; 475  : 
; 476  :     /* if no change is requested, then do nothing */
; 477  :     if (level == state->level && strategy == state->strategy)

  00042	3b 51 50	 cmp	 edx, DWORD PTR [rcx+80]
  00045	75 06		 jne	 SHORT $LN5@gzsetparam
  00047	44 3b 41 54	 cmp	 r8d, DWORD PTR [rcx+84]
  0004b	74 55		 je	 SHORT $LN12@gzsetparam
$LN5@gzsetparam:

; 478  :         return Z_OK;
; 479  : 
; 480  :     /* check for seek request */
; 481  :     if (state->seek) {

  0004d	83 79 5c 00	 cmp	 DWORD PTR [rcx+92], 0
  00051	74 18		 je	 SHORT $LN3@gzsetparam

; 482  :         state->seek = 0;
; 483  :         if (gz_zero(state, state->skip) == -1)

  00053	8b 51 58	 mov	 edx, DWORD PTR [rcx+88]
  00056	c7 41 5c 00 00
	00 00		 mov	 DWORD PTR [rcx+92], 0
  0005d	e8 00 00 00 00	 call	 gz_zero
  00062	83 f8 ff	 cmp	 eax, -1
  00065	75 04		 jne	 SHORT $LN3@gzsetparam

; 484  :             return -1;

  00067	0b c0		 or	 eax, eax
  00069	eb 40		 jmp	 SHORT $LN11@gzsetparam
$LN3@gzsetparam:

; 485  :     }
; 486  : 
; 487  :     /* change compression parameters for subsequent input */
; 488  :     if (state->size) {

  0006b	83 7b 14 00	 cmp	 DWORD PTR [rbx+20], 0
  0006f	74 2b		 je	 SHORT $LN2@gzsetparam

; 489  :         /* flush previous input with previous parameters before changing */
; 490  :         if (strm->avail_in && gz_comp(state, Z_PARTIAL_FLUSH) == -1)

  00071	83 7b 78 00	 cmp	 DWORD PTR [rbx+120], 0
  00075	74 17		 je	 SHORT $LN1@gzsetparam
  00077	ba 01 00 00 00	 mov	 edx, 1
  0007c	48 8b cb	 mov	 rcx, rbx
  0007f	e8 00 00 00 00	 call	 gz_comp
  00084	83 f8 ff	 cmp	 eax, -1
  00087	75 05		 jne	 SHORT $LN1@gzsetparam

; 491  :             return state->err;

  00089	8b 43 60	 mov	 eax, DWORD PTR [rbx+96]
  0008c	eb 1d		 jmp	 SHORT $LN11@gzsetparam
$LN1@gzsetparam:

; 492  :         deflateParams(strm, level, strategy);

  0008e	48 8d 4b 70	 lea	 rcx, QWORD PTR [rbx+112]
  00092	44 8b c7	 mov	 r8d, edi
  00095	8b d6		 mov	 edx, esi
  00097	e8 00 00 00 00	 call	 deflateParams
$LN2@gzsetparam:

; 493  :     }
; 494  :     state->level = level;

  0009c	89 73 50	 mov	 DWORD PTR [rbx+80], esi

; 495  :     state->strategy = strategy;

  0009f	89 7b 54	 mov	 DWORD PTR [rbx+84], edi
$LN12@gzsetparam:

; 496  :     return Z_OK;

  000a2	33 c0		 xor	 eax, eax
  000a4	eb 05		 jmp	 SHORT $LN11@gzsetparam
$LN6@gzsetparam:

; 474  :         return Z_STREAM_ERROR;

  000a6	b8 fe ff ff ff	 mov	 eax, -2
$LN11@gzsetparam:
  000ab	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]

; 497  : }

  000b0	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000b5	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000ba	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
gzsetparams ENDP
_TEXT	ENDS
END
