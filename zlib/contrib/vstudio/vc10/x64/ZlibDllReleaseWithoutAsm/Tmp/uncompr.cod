; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	uncompress
PUBLIC	??_C@_05DFCKICEH@1?42?45?$AA@			; `string'
EXTRN	inflate:PROC
EXTRN	inflateEnd:PROC
EXTRN	inflateInit_:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$uncompress DD imagerel $LN11
	DD	imagerel $LN11+78
	DD	imagerel $unwind$uncompress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$uncompress DD imagerel $LN11+78
	DD	imagerel $LN11+144
	DD	imagerel $chain$0$uncompress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$uncompress DD imagerel $LN11+144
	DD	imagerel $LN11+166
	DD	imagerel $chain$2$uncompress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$uncompress DD imagerel $LN11+166
	DD	imagerel $LN11+185
	DD	imagerel $chain$4$uncompress
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$uncompress DD imagerel $LN11+185
	DD	imagerel $LN11+194
	DD	imagerel $chain$5$uncompress
pdata	ENDS
;	COMDAT ??_C@_05DFCKICEH@1?42?45?$AA@
CONST	SEGMENT
??_C@_05DFCKICEH@1?42?45?$AA@ DB '1.2.5', 00H		; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$uncompress DD 021H
	DD	imagerel $LN11
	DD	imagerel $LN11+78
	DD	imagerel $unwind$uncompress
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$uncompress DD 020021H
	DD	0123400H
	DD	imagerel $LN11
	DD	imagerel $LN11+78
	DD	imagerel $unwind$uncompress
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$uncompress DD 020021H
	DD	0123400H
	DD	imagerel $LN11
	DD	imagerel $LN11+78
	DD	imagerel $unwind$uncompress
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$uncompress DD 020821H
	DD	0123408H
	DD	imagerel $LN11
	DD	imagerel $LN11+78
	DD	imagerel $unwind$uncompress
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$uncompress DD 020901H
	DD	07002f209H
xdata	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\uncompr.c
;	COMDAT uncompress
_TEXT	SEGMENT
stream$ = 32
dest$ = 144
destLen$ = 152
source$ = 160
sourceLen$ = 168
uncompress PROC						; COMDAT

; 29   : {

$LN11:
  00000	40 57		 push	 rdi
  00002	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H

; 30   :     z_stream stream;
; 31   :     int err;
; 32   : 
; 33   :     stream.next_in = (Bytef*)source;
; 34   :     stream.avail_in = (uInt)sourceLen;
; 35   :     /* Check for source > 64K on 16-bit machine: */
; 36   :     if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
; 37   : 
; 38   :     stream.next_out = dest;
; 39   :     stream.avail_out = (uInt)*destLen;

  00009	8b 02		 mov	 eax, DWORD PTR [rdx]
  0000b	48 8b fa	 mov	 rdi, rdx
  0000e	4c 89 44 24 20	 mov	 QWORD PTR stream$[rsp], r8
  00013	89 44 24 38	 mov	 DWORD PTR stream$[rsp+24], eax

; 40   :     if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;
; 41   : 
; 42   :     stream.zalloc = (alloc_func)0;

  00017	33 c0		 xor	 eax, eax
  00019	48 89 4c 24 30	 mov	 QWORD PTR stream$[rsp+16], rcx

; 43   :     stream.zfree = (free_func)0;
; 44   : 
; 45   :     err = inflateInit(&stream);

  0001e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05DFCKICEH@1?42?45?$AA@
  00025	48 8d 4c 24 20	 lea	 rcx, QWORD PTR stream$[rsp]
  0002a	44 8d 40 58	 lea	 r8d, QWORD PTR [rax+88]
  0002e	44 89 4c 24 28	 mov	 DWORD PTR stream$[rsp+8], r9d
  00033	48 89 44 24 50	 mov	 QWORD PTR stream$[rsp+48], rax
  00038	48 89 44 24 58	 mov	 QWORD PTR stream$[rsp+56], rax
  0003d	e8 00 00 00 00	 call	 inflateInit_

; 46   :     if (err != Z_OK) return err;

  00042	85 c0		 test	 eax, eax
  00044	75 73		 jne	 SHORT $LN7@uncompress

; 47   : 
; 48   :     err = inflate(&stream, Z_FINISH);

  00046	8d 50 04	 lea	 edx, QWORD PTR [rax+4]
  00049	48 8d 4c 24 20	 lea	 rcx, QWORD PTR stream$[rsp]
  0004e	48 89 9c 24 90
	00 00 00	 mov	 QWORD PTR [rsp+144], rbx
  00056	e8 00 00 00 00	 call	 inflate

; 49   :     if (err != Z_STREAM_END) {
; 50   :         inflateEnd(&stream);

  0005b	48 8d 4c 24 20	 lea	 rcx, QWORD PTR stream$[rsp]
  00060	8b d8		 mov	 ebx, eax
  00062	83 f8 01	 cmp	 eax, 1
  00065	74 3f		 je	 SHORT $LN3@uncompress
  00067	e8 00 00 00 00	 call	 inflateEnd

; 51   :         if (err == Z_NEED_DICT || (err == Z_BUF_ERROR && stream.avail_in == 0))

  0006c	83 fb 02	 cmp	 ebx, 2
  0006f	74 1f		 je	 SHORT $LN1@uncompress
  00071	83 fb fb	 cmp	 ebx, -5
  00074	75 07		 jne	 SHORT $LN2@uncompress
  00076	83 7c 24 28 00	 cmp	 DWORD PTR stream$[rsp+8], 0
  0007b	74 13		 je	 SHORT $LN1@uncompress
$LN2@uncompress:

; 53   :         return err;

  0007d	8b c3		 mov	 eax, ebx
  0007f	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]

; 58   :     return err;
; 59   : }

  00087	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0008e	5f		 pop	 rdi
  0008f	c3		 ret	 0
$LN1@uncompress:

; 52   :             return Z_DATA_ERROR;

  00090	b8 fd ff ff ff	 mov	 eax, -3
  00095	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]

; 58   :     return err;
; 59   : }

  0009d	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000a4	5f		 pop	 rdi
  000a5	c3		 ret	 0
$LN3@uncompress:

; 54   :     }
; 55   :     *destLen = stream.total_out;

  000a6	8b 44 24 3c	 mov	 eax, DWORD PTR stream$[rsp+28]
  000aa	89 07		 mov	 DWORD PTR [rdi], eax

; 56   : 
; 57   :     err = inflateEnd(&stream);

  000ac	e8 00 00 00 00	 call	 inflateEnd
  000b1	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
$LN7@uncompress:

; 58   :     return err;
; 59   : }

  000b9	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  000c0	5f		 pop	 rdi
  000c1	c3		 ret	 0
uncompress ENDP
_TEXT	ENDS
END
