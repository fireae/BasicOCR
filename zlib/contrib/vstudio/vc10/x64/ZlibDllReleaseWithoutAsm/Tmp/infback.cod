; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
CONST	ENDS
PUBLIC	inflateBack
PUBLIC	inflateBackEnd
PUBLIC	inflateBackInit_
PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
EXTRN	zcalloc:PROC
EXTRN	zcfree:PROC
EXTRN	inflate_table:PROC
EXTRN	inflate_fast:PROC
EXTRN	memcpy:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBack DD imagerel $LN477
	DD	imagerel $LN477+66
	DD	imagerel $unwind$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBack DD imagerel $LN477+66
	DD	imagerel $LN477+3974
	DD	imagerel $chain$3$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBack DD imagerel $LN477+3974
	DD	imagerel $LN477+3992
	DD	imagerel $chain$4$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflateBack DD imagerel $LN477+3992
	DD	imagerel $LN477+4068
	DD	imagerel $chain$5$inflateBack
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackEnd DD imagerel $LN6
	DD	imagerel $LN6+65
	DD	imagerel $unwind$inflateBackEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackInit_ DD imagerel $LN13
	DD	imagerel $LN13+83
	DD	imagerel $unwind$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateBackInit_ DD imagerel $LN13+83
	DD	imagerel $LN13+192
	DD	imagerel $chain$1$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateBackInit_ DD imagerel $LN13+192
	DD	imagerel $LN13+225
	DD	imagerel $chain$3$inflateBackInit_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateBackInit_ DD imagerel $LN13+225
	DD	imagerel $LN13+267
	DD	imagerel $chain$4$inflateBackInit_
pdata	ENDS
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBackInit_ DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+83
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBackInit_ DD 040021H
	DD	07e400H
	DD	067400H
	DD	imagerel $LN13
	DD	imagerel $LN13+83
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateBackInit_ DD 040a21H
	DD	07e40aH
	DD	067405H
	DD	imagerel $LN13
	DD	imagerel $LN13+83
	DD	imagerel $unwind$inflateBackInit_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackInit_ DD 060f01H
	DD	09540fH
	DD	08340fH
	DD	0600b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackEnd DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflateBack DD 080021H
	DD	0be400H
	DD	0c7400H
	DD	0d6400H
	DD	0e3400H
	DD	imagerel $LN477
	DD	imagerel $LN477+66
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateBack DD 021H
	DD	imagerel $LN477
	DD	imagerel $LN477+66
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateBack DD 082421H
	DD	0be424H
	DD	0c7420H
	DD	0d6408H
	DD	0e3404H
	DD	imagerel $LN477
	DD	imagerel $LN477+66
	DD	imagerel $unwind$inflateBack
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBack DD 052101H
	DD	0f01ae221H
	DD	0c016d018H
	DD	05014H
xdata	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\infback.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 76   : #ifdef BUILDFIXED
; 77   :     static int virgin = 1;
; 78   :     static code *lenfix, *distfix;
; 79   :     static code fixed[544];
; 80   : 
; 81   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 82   :     if (virgin) {
; 83   :         unsigned sym, bits;
; 84   :         static code *next;
; 85   : 
; 86   :         /* literal/length table */
; 87   :         sym = 0;
; 88   :         while (sym < 144) state->lens[sym++] = 8;
; 89   :         while (sym < 256) state->lens[sym++] = 9;
; 90   :         while (sym < 280) state->lens[sym++] = 7;
; 91   :         while (sym < 288) state->lens[sym++] = 8;
; 92   :         next = fixed;
; 93   :         lenfix = next;
; 94   :         bits = 9;
; 95   :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 96   : 
; 97   :         /* distance table */
; 98   :         sym = 0;
; 99   :         while (sym < 32) state->lens[sym++] = 5;
; 100  :         distfix = next;
; 101  :         bits = 5;
; 102  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 103  : 
; 104  :         /* do this just once */
; 105  :         virgin = 0;
; 106  :     }
; 107  : #else /* !BUILDFIXED */
; 108  : #   include "inffixed.h"
; 109  : #endif /* BUILDFIXED */
; 110  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 111  :     state->lenbits = 9;

  00007	c7 41 68 09 00
	00 00		 mov	 DWORD PTR [rcx+104], 9

; 112  :     state->distcode = distfix;
; 113  :     state->distbits = 5;

  0000e	c7 41 6c 05 00
	00 00		 mov	 DWORD PTR [rcx+108], 5
  00015	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax
  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00020	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 114  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\infback.c
;	COMDAT inflateBackInit_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
window$ = 64
version$ = 72
stream_size$ = 80
inflateBackInit_ PROC					; COMDAT

; 34   : {

$LN13:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 6c 24 20	 mov	 QWORD PTR [rsp+32], rbp
  0000a	56		 push	 rsi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	49 8b e8	 mov	 rbp, r8
  00012	8b f2		 mov	 esi, edx
  00014	48 8b d9	 mov	 rbx, rcx

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 38   :         stream_size != (int)(sizeof(z_stream)))

  00017	4d 85 c9	 test	 r9, r9
  0001a	0f 84 d6 00 00
	00		 je	 $LN6@inflateBac
  00020	41 80 39 31	 cmp	 BYTE PTR [r9], 49	; 00000031H
  00024	0f 85 cc 00 00
	00		 jne	 $LN6@inflateBac
  0002a	83 7c 24 50 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  0002f	0f 85 c1 00 00
	00		 jne	 $LN6@inflateBac

; 39   :         return Z_VERSION_ERROR;
; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00035	48 85 c9	 test	 rcx, rcx
  00038	0f 84 a3 00 00
	00		 je	 $LN4@inflateBac
  0003e	4d 85 c0	 test	 r8, r8
  00041	0f 84 9a 00 00
	00		 je	 $LN4@inflateBac
  00047	8d 42 f8	 lea	 eax, DWORD PTR [rdx-8]
  0004a	83 f8 07	 cmp	 eax, 7
  0004d	0f 87 8e 00 00
	00		 ja	 $LN4@inflateBac

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */

  00053	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00058	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  0005d	45 33 f6	 xor	 r14d, r14d
  00060	4c 89 71 20	 mov	 QWORD PTR [rcx+32], r14

; 44   :     if (strm->zalloc == (alloc_func)0) {

  00064	4c 39 71 30	 cmp	 QWORD PTR [rcx+48], r14
  00068	75 0f		 jne	 SHORT $LN3@inflateBac

; 45   :         strm->zalloc = zcalloc;

  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 46   :         strm->opaque = (voidpf)0;

  00071	4c 89 71 40	 mov	 QWORD PTR [rcx+64], r14
  00075	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN3@inflateBac:

; 47   :     }
; 48   :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  00079	4c 39 71 38	 cmp	 QWORD PTR [rcx+56], r14
  0007d	75 0b		 jne	 SHORT $LN2@inflateBac
  0007f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcfree
  00086	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN2@inflateBac:

; 49   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,
; 50   :                                                sizeof(struct inflate_state));

  0008a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0008e	bf 01 00 00 00	 mov	 edi, 1
  00093	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  00099	8b d7		 mov	 edx, edi
  0009b	ff 53 30	 call	 QWORD PTR [rbx+48]

; 51   :     if (state == Z_NULL) return Z_MEM_ERROR;

  0009e	48 85 c0	 test	 rax, rax
  000a1	75 1d		 jne	 SHORT $LN1@inflateBac
  000a3	8d 47 fb	 lea	 eax, QWORD PTR [rdi-5]
$LN11@inflateBac:
  000a6	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]
  000ab	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]

; 61   : }

  000b0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000b5	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000ba	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000be	5e		 pop	 rsi
  000bf	c3		 ret	 0
$LN1@inflateBac:

; 52   :     Tracev((stderr, "inflate: allocated\n"));
; 53   :     strm->state = (struct internal_state FAR *)state;

  000c0	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 54   :     state->dmax = 32768U;
; 55   :     state->wbits = windowBits;
; 56   :     state->wsize = 1U << windowBits;

  000c4	8b ce		 mov	 ecx, esi
  000c6	c7 40 14 00 80
	00 00		 mov	 DWORD PTR [rax+20], 32768 ; 00008000H
  000cd	d3 e7		 shl	 edi, cl
  000cf	89 70 28	 mov	 DWORD PTR [rax+40], esi

; 57   :     state->window = window;

  000d2	48 89 68 38	 mov	 QWORD PTR [rax+56], rbp
  000d6	89 78 2c	 mov	 DWORD PTR [rax+44], edi

; 58   :     state->wnext = 0;
; 59   :     state->whave = 0;

  000d9	4c 89 70 30	 mov	 QWORD PTR [rax+48], r14

; 60   :     return Z_OK;

  000dd	33 c0		 xor	 eax, eax
  000df	eb c5		 jmp	 SHORT $LN11@inflateBac
$LN4@inflateBac:

; 42   :         return Z_STREAM_ERROR;

  000e1	b8 fe ff ff ff	 mov	 eax, -2

; 61   : }

  000e6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000eb	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  000f0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f4	5e		 pop	 rsi
  000f5	c3		 ret	 0
$LN6@inflateBac:
  000f6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000fb	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00100	b8 fa ff ff ff	 mov	 eax, -6
  00105	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00109	5e		 pop	 rsi
  0010a	c3		 ret	 0
inflateBackInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\infback.c
;	COMDAT inflateBackEnd
_TEXT	SEGMENT
strm$ = 48
inflateBackEnd PROC					; COMDAT

; 625  : {

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 626  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 28		 je	 SHORT $LN1@inflateBac
  0000e	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  00012	48 85 d2	 test	 rdx, rdx
  00015	74 1f		 je	 SHORT $LN1@inflateBac
  00017	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0001b	48 85 c0	 test	 rax, rax
  0001e	74 16		 je	 SHORT $LN1@inflateBac

; 628  :     ZFREE(strm, strm->state);

  00020	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00024	ff d0		 call	 rax

; 629  :     strm->state = Z_NULL;

  00026	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 630  :     Tracev((stderr, "inflate: end\n"));
; 631  :     return Z_OK;

  0002e	33 c0		 xor	 eax, eax

; 632  : }

  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
$LN1@inflateBac:

; 627  :         return Z_STREAM_ERROR;

  00036	b8 fe ff ff ff	 mov	 eax, -2

; 632  : }

  0003b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003f	5b		 pop	 rbx
  00040	c3		 ret	 0
inflateBackEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\infback.c
;	COMDAT inflateBack
_TEXT	SEGMENT
left$1$ = 48
last$ = 52
here$ = 52
next$ = 56
put$1$ = 64
strm$ = 160
in$ = 168
in_desc$ = 176
out$ = 184
out_desc$ = 192
inflateBack PROC					; COMDAT

; 247  : {

$LN477:
  00000	48 8b c4	 mov	 rax, rsp
  00003	4c 89 48 20	 mov	 QWORD PTR [rax+32], r9
  00007	4c 89 40 18	 mov	 QWORD PTR [rax+24], r8
  0000b	48 89 50 10	 mov	 QWORD PTR [rax+16], rdx
  0000f	48 89 48 08	 mov	 QWORD PTR [rax+8], rcx
  00013	55		 push	 rbp
  00014	41 54		 push	 r12
  00016	41 55		 push	 r13
  00018	41 57		 push	 r15
  0001a	48 8b ec	 mov	 rbp, rsp
  0001d	48 83 ec 78	 sub	 rsp, 120		; 00000078H
  00021	4d 8b e8	 mov	 r13, r8
  00024	4c 8b fa	 mov	 r15, rdx
  00027	4c 8b c1	 mov	 r8, rcx

; 248  :     struct inflate_state FAR *state;
; 249  :     unsigned char FAR *next;    /* next input */
; 250  :     unsigned char FAR *put;     /* next output */
; 251  :     unsigned have, left;        /* available input and output */
; 252  :     unsigned long hold;         /* bit buffer */
; 253  :     unsigned bits;              /* bits in bit buffer */
; 254  :     unsigned copy;              /* number of stored or match bytes to copy */
; 255  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 256  :     code here;                  /* current decoding table entry */
; 257  :     code last;                  /* parent table entry */
; 258  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 259  :     int ret;                    /* return code */
; 260  :     static const unsigned short order[19] = /* permutation of code lengths */
; 261  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 262  : 
; 263  :     /* Check that the strm exists and that the state was initialized */
; 264  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0002a	48 85 c9	 test	 rcx, rcx
  0002d	0f 84 53 0f 00
	00		 je	 $LN346@inflateBac
  00033	4c 8b 61 28	 mov	 r12, QWORD PTR [rcx+40]
  00037	4d 85 e4	 test	 r12, r12
  0003a	0f 84 46 0f 00
	00		 je	 $LN346@inflateBac

; 266  :     state = (struct inflate_state FAR *)strm->state;
; 267  : 
; 268  :     /* Reset the state */
; 269  :     strm->msg = Z_NULL;

  00040	33 d2		 xor	 edx, edx
  00042	48 89 58 d8	 mov	 QWORD PTR [rax-40], rbx
  00046	48 89 70 d0	 mov	 QWORD PTR [rax-48], rsi
  0004a	48 89 51 20	 mov	 QWORD PTR [rcx+32], rdx

; 270  :     state->mode = TYPE;

  0004e	49 c7 04 24 0b
	00 00 00	 mov	 QWORD PTR [r12], 11

; 271  :     state->last = 0;
; 272  :     state->whave = 0;

  00056	41 89 54 24 30	 mov	 DWORD PTR [r12+48], edx

; 273  :     next = strm->next_in;

  0005b	4c 8b 11	 mov	 r10, QWORD PTR [rcx]
  0005e	48 89 78 c8	 mov	 QWORD PTR [rax-56], rdi
  00062	4c 89 70 c0	 mov	 QWORD PTR [rax-64], r14
  00066	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10

; 274  :     have = next != Z_NULL ? strm->avail_in : 0;

  0006a	4d 85 d2	 test	 r10, r10
  0006d	74 05		 je	 SHORT $LN350@inflateBac
  0006f	8b 79 08	 mov	 edi, DWORD PTR [rcx+8]
  00072	eb 02		 jmp	 SHORT $LN351@inflateBac
$LN350@inflateBac:
  00074	8b fa		 mov	 edi, edx
$LN351@inflateBac:

; 275  :     hold = 0;
; 276  :     bits = 0;
; 277  :     put = state->window;
; 278  :     left = state->wsize;
; 279  : 
; 280  :     /* Inflate until end of block marked as last */
; 281  :     for (;;)
; 282  :         switch (state->mode) {

  00076	41 8b 04 24	 mov	 eax, DWORD PTR [r12]
  0007a	49 8b 5c 24 38	 mov	 rbx, QWORD PTR [r12+56]
  0007f	45 8b 4c 24 2c	 mov	 r9d, DWORD PTR [r12+44]
  00084	83 e8 0b	 sub	 eax, 11
  00087	44 8b f2	 mov	 r14d, edx
  0008a	8b f2		 mov	 esi, edx
  0008c	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00090	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  00094	83 f8 12	 cmp	 eax, 18
  00097	0f 87 b6 0e 00
	00		 ja	 $LN1@inflateBac
$LN474@inflateBac:
  0009d	48 98		 cdqe
  0009f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  000a6	41 bb 01 00 00
	00		 mov	 r11d, 1
  000ac	8b 8c 81 00 00
	00 00		 mov	 ecx, DWORD PTR $LN453@inflateBac[rcx+rax*4]
  000b3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:__ImageBase
  000ba	48 03 c8	 add	 rcx, rax
  000bd	ff e1		 jmp	 rcx
$LN341@inflateBac:

; 283  :         case TYPE:
; 284  :             /* determine and dispatch block type */
; 285  :             if (state->last) {

  000bf	41 83 7c 24 04
	00		 cmp	 DWORD PTR [r12+4], 0
  000c5	74 1b		 je	 SHORT $LN336@inflateBac

; 286  :                 BYTEBITS();

  000c7	8b ce		 mov	 ecx, esi

; 287  :                 state->mode = DONE;

  000c9	41 c7 04 24 1c
	00 00 00	 mov	 DWORD PTR [r12], 28

; 288  :                 break;

  000d1	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  000d5	83 e1 07	 and	 ecx, 7
  000d8	41 d3 ee	 shr	 r14d, cl
  000db	2b f1		 sub	 esi, ecx
  000dd	e9 a9 0a 00 00	 jmp	 $LN402@inflateBac
$LN336@inflateBac:

; 289  :             }
; 290  :             NEEDBITS(3);

  000e2	83 fe 03	 cmp	 esi, 3
  000e5	73 42		 jae	 SHORT $LN335@inflateBac
$LL333@inflateBac:
  000e7	85 ff		 test	 edi, edi
  000e9	75 18		 jne	 SHORT $LN327@inflateBac
  000eb	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  000ef	49 8b cd	 mov	 rcx, r13
  000f2	41 ff d7	 call	 r15
  000f5	8b f8		 mov	 edi, eax
  000f7	85 c0		 test	 eax, eax
  000f9	0f 84 1a 0e 00
	00		 je	 $LN377@inflateBac
  000ff	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN327@inflateBac:
  00103	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00107	8b ce		 mov	 ecx, esi
  00109	49 ff c2	 inc	 r10
  0010c	d3 e0		 shl	 eax, cl
  0010e	83 c6 08	 add	 esi, 8
  00111	ff cf		 dec	 edi
  00113	44 03 f0	 add	 r14d, eax
  00116	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  0011a	83 fe 03	 cmp	 esi, 3
  0011d	72 c8		 jb	 SHORT $LL333@inflateBac
  0011f	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00123	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00127	33 d2		 xor	 edx, edx
$LN335@inflateBac:

; 291  :             state->last = BITS(1);

  00129	41 8b c6	 mov	 eax, r14d

; 292  :             DROPBITS(1);

  0012c	41 d1 ee	 shr	 r14d, 1
  0012f	ff ce		 dec	 esi
  00131	83 e0 01	 and	 eax, 1
  00134	41 89 44 24 04	 mov	 DWORD PTR [r12+4], eax

; 293  :             switch (BITS(2)) {

  00139	41 8b c6	 mov	 eax, r14d
  0013c	83 e0 03	 and	 eax, 3
  0013f	74 67		 je	 SHORT $LN318@inflateBac
  00141	ff c8		 dec	 eax
  00143	74 43		 je	 SHORT $LN317@inflateBac
  00145	ff c8		 dec	 eax
  00147	74 27		 je	 SHORT $LN316@inflateBac
  00149	ff c8		 dec	 eax
  0014b	75 63		 jne	 SHORT $LN314@inflateBac

; 309  :                 break;
; 310  :             case 3:
; 311  :                 strm->msg = (char *)"invalid block type";

  0014d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 312  :                 state->mode = BAD;
; 313  :             }
; 314  :             DROPBITS(2);

  00154	41 c1 ee 02	 shr	 r14d, 2
  00158	83 c6 fe	 add	 esi, -2			; fffffffeH
  0015b	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  0015f	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29

; 315  :             break;

  00167	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  0016b	e9 1b 0a 00 00	 jmp	 $LN402@inflateBac
$LN316@inflateBac:

; 304  :                 break;
; 305  :             case 2:                             /* dynamic block */
; 306  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 307  :                         state->last ? " (last)" : ""));
; 308  :                 state->mode = TABLE;

  00170	41 c7 04 24 10
	00 00 00	 mov	 DWORD PTR [r12], 16

; 315  :             break;

  00178	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  0017c	41 c1 ee 02	 shr	 r14d, 2
  00180	83 c6 fe	 add	 esi, -2			; fffffffeH
  00183	e9 03 0a 00 00	 jmp	 $LN402@inflateBac
$LN317@inflateBac:

; 298  :                 break;
; 299  :             case 1:                             /* fixed block */
; 300  :                 fixedtables(state);

  00188	49 8b cc	 mov	 rcx, r12
  0018b	e8 00 00 00 00	 call	 fixedtables

; 301  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 302  :                         state->last ? " (last)" : ""));
; 303  :                 state->mode = LEN;              /* decode codes */

  00190	41 c7 04 24 14
	00 00 00	 mov	 DWORD PTR [r12], 20

; 315  :             break;

  00198	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  0019c	41 c1 ee 02	 shr	 r14d, 2
  001a0	83 c6 fe	 add	 esi, -2			; fffffffeH
  001a3	e9 e3 09 00 00	 jmp	 $LN402@inflateBac
$LN318@inflateBac:

; 294  :             case 0:                             /* stored block */
; 295  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 296  :                         state->last ? " (last)" : ""));
; 297  :                 state->mode = STORED;

  001a8	41 c7 04 24 0d
	00 00 00	 mov	 DWORD PTR [r12], 13
$LN314@inflateBac:

; 315  :             break;

  001b0	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  001b4	41 c1 ee 02	 shr	 r14d, 2
  001b8	83 c6 fe	 add	 esi, -2			; fffffffeH
  001bb	e9 cb 09 00 00	 jmp	 $LN402@inflateBac
$LN310@inflateBac:

; 316  : 
; 317  :         case STORED:
; 318  :             /* get and verify stored block length */
; 319  :             BYTEBITS();                         /* go to byte boundary */

  001c0	8b ce		 mov	 ecx, esi
  001c2	83 e1 07	 and	 ecx, 7
  001c5	2b f1		 sub	 esi, ecx
  001c7	41 d3 ee	 shr	 r14d, cl

; 320  :             NEEDBITS(32);

  001ca	83 fe 20	 cmp	 esi, 32			; 00000020H
  001cd	73 43		 jae	 SHORT $LN306@inflateBac
  001cf	90		 npad	 1
$LL304@inflateBac:
  001d0	85 ff		 test	 edi, edi
  001d2	75 18		 jne	 SHORT $LN298@inflateBac
  001d4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  001d8	49 8b cd	 mov	 rcx, r13
  001db	41 ff d7	 call	 r15
  001de	8b f8		 mov	 edi, eax
  001e0	85 c0		 test	 eax, eax
  001e2	0f 84 31 0d 00
	00		 je	 $LN377@inflateBac
  001e8	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN298@inflateBac:
  001ec	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  001f0	8b ce		 mov	 ecx, esi
  001f2	49 ff c2	 inc	 r10
  001f5	d3 e0		 shl	 eax, cl
  001f7	83 c6 08	 add	 esi, 8
  001fa	ff cf		 dec	 edi
  001fc	44 03 f0	 add	 r14d, eax
  001ff	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00203	83 fe 20	 cmp	 esi, 32			; 00000020H
  00206	72 c8		 jb	 SHORT $LL304@inflateBac
  00208	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0020c	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00210	33 d2		 xor	 edx, edx
$LN306@inflateBac:

; 321  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  00212	41 8b c6	 mov	 eax, r14d
  00215	41 0f b7 ce	 movzx	 ecx, r14w
  00219	f7 d0		 not	 eax
  0021b	c1 e8 10	 shr	 eax, 16
  0021e	3b c8		 cmp	 ecx, eax
  00220	74 1c		 je	 SHORT $LN294@inflateBac

; 322  :                 strm->msg = (char *)"invalid stored block lengths";

  00222	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  00229	49 89 40 20	 mov	 QWORD PTR [r8+32], rax

; 323  :                 state->mode = BAD;

  0022d	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29

; 324  :                 break;

  00235	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00239	e9 4d 09 00 00	 jmp	 $LN402@inflateBac
$LN294@inflateBac:

; 325  :             }
; 326  :             state->length = (unsigned)hold & 0xffff;

  0023e	41 89 4c 24 48	 mov	 DWORD PTR [r12+72], ecx

; 327  :             Tracev((stderr, "inflate:       stored length %u\n",
; 328  :                     state->length));
; 329  :             INITBITS();

  00243	44 8b f2	 mov	 r14d, edx
  00246	8b f2		 mov	 esi, edx

; 330  : 
; 331  :             /* copy stored block from input to output */
; 332  :             while (state->length != 0) {

  00248	85 c9		 test	 ecx, ecx
  0024a	0f 84 97 00 00
	00		 je	 $LN289@inflateBac
$LL290@inflateBac:

; 333  :                 copy = state->length;

  00250	45 8b 7c 24 48	 mov	 r15d, DWORD PTR [r12+72]

; 334  :                 PULL();

  00255	85 ff		 test	 edi, edi
  00257	75 14		 jne	 SHORT $LN287@inflateBac
  00259	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0025d	49 8b cd	 mov	 rcx, r13
  00260	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00263	8b f8		 mov	 edi, eax
  00265	85 c0		 test	 eax, eax
  00267	0f 84 ac 0c 00
	00		 je	 $LN377@inflateBac
$LN287@inflateBac:

; 335  :                 ROOM();

  0026d	8b 5d b8	 mov	 ebx, DWORD PTR left$1$[rbp-120]
  00270	85 db		 test	 ebx, ebx
  00272	75 2b		 jne	 SHORT $LN282@inflateBac
  00274	41 8b 5c 24 2c	 mov	 ebx, DWORD PTR [r12+44]
  00279	49 8b 44 24 38	 mov	 rax, QWORD PTR [r12+56]
  0027e	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00282	44 8b c3	 mov	 r8d, ebx
  00285	48 8b d0	 mov	 rdx, rax
  00288	48 89 45 c8	 mov	 QWORD PTR put$1$[rbp-120], rax
  0028c	89 5d b8	 mov	 DWORD PTR left$1$[rbp-120], ebx
  0028f	41 89 5c 24 30	 mov	 DWORD PTR [r12+48], ebx
  00294	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00297	85 c0		 test	 eax, eax
  00299	0f 85 93 08 00
	00		 jne	 $LN380@inflateBac
$LN282@inflateBac:

; 336  :                 if (copy > have) copy = have;
; 337  :                 if (copy > left) copy = left;
; 338  :                 zmemcpy(put, next, copy);

  0029f	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  002a3	48 8b 4d c8	 mov	 rcx, QWORD PTR put$1$[rbp-120]
  002a7	44 3b ff	 cmp	 r15d, edi
  002aa	44 0f 47 ff	 cmova	 r15d, edi
  002ae	44 3b fb	 cmp	 r15d, ebx
  002b1	44 0f 47 fb	 cmova	 r15d, ebx
  002b5	45 8b c7	 mov	 r8d, r15d
  002b8	41 8b df	 mov	 ebx, r15d
  002bb	e8 00 00 00 00	 call	 memcpy

; 339  :                 have -= copy;
; 340  :                 next += copy;
; 341  :                 left -= copy;

  002c0	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  002c4	48 01 5d c0	 add	 QWORD PTR next$[rbp-120], rbx

; 342  :                 put += copy;

  002c8	48 01 5d c8	 add	 QWORD PTR put$1$[rbp-120], rbx
  002cc	45 2b cf	 sub	 r9d, r15d
  002cf	41 2b ff	 sub	 edi, r15d

; 343  :                 state->length -= copy;

  002d2	45 29 7c 24 48	 sub	 DWORD PTR [r12+72], r15d
  002d7	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  002db	0f 85 6f ff ff
	ff		 jne	 $LL290@inflateBac
  002e1	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  002e5	33 d2		 xor	 edx, edx
$LN289@inflateBac:

; 344  :             }
; 345  :             Tracev((stderr, "inflate:       stored end\n"));
; 346  :             state->mode = TYPE;

  002e7	41 c7 04 24 0b
	00 00 00	 mov	 DWORD PTR [r12], 11

; 347  :             break;

  002ef	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  002f3	e9 8f 08 00 00	 jmp	 $LN469@inflateBac
$LN275@inflateBac:

; 348  : 
; 349  :         case TABLE:
; 350  :             /* get dynamic table entries descriptor */
; 351  :             NEEDBITS(14);

  002f8	83 fe 0e	 cmp	 esi, 14
  002fb	73 43		 jae	 SHORT $LN274@inflateBac
  002fd	0f 1f 00	 npad	 3
$LL272@inflateBac:
  00300	85 ff		 test	 edi, edi
  00302	75 18		 jne	 SHORT $LN266@inflateBac
  00304	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00308	49 8b cd	 mov	 rcx, r13
  0030b	41 ff d7	 call	 r15
  0030e	8b f8		 mov	 edi, eax
  00310	85 c0		 test	 eax, eax
  00312	0f 84 01 0c 00
	00		 je	 $LN377@inflateBac
  00318	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN266@inflateBac:
  0031c	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00320	8b ce		 mov	 ecx, esi
  00322	49 ff c2	 inc	 r10
  00325	d3 e0		 shl	 eax, cl
  00327	83 c6 08	 add	 esi, 8
  0032a	ff cf		 dec	 edi
  0032c	44 03 f0	 add	 r14d, eax
  0032f	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00333	83 fe 0e	 cmp	 esi, 14
  00336	72 c8		 jb	 SHORT $LL272@inflateBac
  00338	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0033c	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
$LN274@inflateBac:

; 352  :             state->nlen = BITS(5) + 257;

  00340	41 8b c6	 mov	 eax, r14d

; 353  :             DROPBITS(5);

  00343	41 c1 ee 05	 shr	 r14d, 5

; 354  :             state->ndist = BITS(5) + 1;
; 355  :             DROPBITS(5);
; 356  :             state->ncode = BITS(4) + 4;
; 357  :             DROPBITS(4);

  00347	83 c6 f2	 add	 esi, -14		; fffffff2H
  0034a	41 8b ce	 mov	 ecx, r14d
  0034d	41 c1 ee 05	 shr	 r14d, 5
  00351	83 e0 1f	 and	 eax, 31
  00354	41 8b d6	 mov	 edx, r14d
  00357	83 e1 1f	 and	 ecx, 31
  0035a	05 01 01 00 00	 add	 eax, 257		; 00000101H
  0035f	83 e2 0f	 and	 edx, 15
  00362	ff c1		 inc	 ecx
  00364	41 c1 ee 04	 shr	 r14d, 4
  00368	83 c2 04	 add	 edx, 4
  0036b	41 89 44 24 74	 mov	 DWORD PTR [r12+116], eax
  00370	41 89 4c 24 78	 mov	 DWORD PTR [r12+120], ecx
  00375	41 89 54 24 70	 mov	 DWORD PTR [r12+112], edx

; 358  : #ifndef PKZIP_BUG_WORKAROUND
; 359  :             if (state->nlen > 286 || state->ndist > 30) {

  0037a	3d 1e 01 00 00	 cmp	 eax, 286		; 0000011eH
  0037f	0f 87 e4 05 00
	00		 ja	 $LN252@inflateBac
  00385	83 f9 1e	 cmp	 ecx, 30
  00388	0f 87 db 05 00
	00		 ja	 $LN252@inflateBac

; 363  :             }
; 364  : #endif
; 365  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 366  : 
; 367  :             /* get code length code lengths (not a typo) */
; 368  :             state->have = 0;

  0038e	33 c9		 xor	 ecx, ecx

; 369  :             while (state->have < state->ncode) {

  00390	85 d2		 test	 edx, edx
  00392	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00399	41 89 4c 24 7c	 mov	 DWORD PTR [r12+124], ecx
  0039e	0f 84 86 00 00
	00		 je	 $LN359@inflateBac
$LL251@inflateBac:

; 370  :                 NEEDBITS(3);

  003a4	83 fe 03	 cmp	 esi, 3
  003a7	73 45		 jae	 SHORT $LN248@inflateBac
  003a9	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  003ad	0f 1f 00	 npad	 3
$LL246@inflateBac:
  003b0	85 ff		 test	 edi, edi
  003b2	75 18		 jne	 SHORT $LN240@inflateBac
  003b4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  003b8	49 8b cd	 mov	 rcx, r13
  003bb	41 ff d7	 call	 r15
  003be	8b f8		 mov	 edi, eax
  003c0	85 c0		 test	 eax, eax
  003c2	0f 84 51 0b 00
	00		 je	 $LN377@inflateBac
  003c8	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN240@inflateBac:
  003cc	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  003cf	8b ce		 mov	 ecx, esi
  003d1	48 ff c2	 inc	 rdx
  003d4	d3 e0		 shl	 eax, cl
  003d6	83 c6 08	 add	 esi, 8
  003d9	ff cf		 dec	 edi
  003db	44 03 f0	 add	 r14d, eax
  003de	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  003e2	83 fe 03	 cmp	 esi, 3
  003e5	72 c9		 jb	 SHORT $LL246@inflateBac
  003e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
$LN248@inflateBac:

; 371  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  003ee	41 8b 44 24 7c	 mov	 eax, DWORD PTR [r12+124]
  003f3	41 0f b7 ce	 movzx	 ecx, r14w

; 372  :                 DROPBITS(3);

  003f7	83 c6 fd	 add	 esi, -3			; fffffffdH
  003fa	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[rdx+rax*2]
  00402	66 83 e1 07	 and	 cx, 7
  00406	41 c1 ee 03	 shr	 r14d, 3
  0040a	66 41 89 8c 44
	88 00 00 00	 mov	 WORD PTR [r12+rax*2+136], cx
  00413	41 ff 44 24 7c	 inc	 DWORD PTR [r12+124]
  00418	41 8b 44 24 7c	 mov	 eax, DWORD PTR [r12+124]
  0041d	41 3b 44 24 70	 cmp	 eax, DWORD PTR [r12+112]
  00422	0f 82 7c ff ff
	ff		 jb	 $LL251@inflateBac
  00428	33 c9		 xor	 ecx, ecx
$LN359@inflateBac:

; 373  :             }
; 374  :             while (state->have < 19)

  0042a	41 83 7c 24 7c
	13		 cmp	 DWORD PTR [r12+124], 19
  00430	73 23		 jae	 SHORT $LN232@inflateBac
$LL233@inflateBac:

; 375  :                 state->lens[order[state->have++]] = 0;

  00432	41 8b 44 24 7c	 mov	 eax, DWORD PTR [r12+124]
  00437	0f b7 84 42 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[rdx+rax*2]
  0043f	66 41 89 8c 44
	88 00 00 00	 mov	 WORD PTR [r12+rax*2+136], cx
  00448	41 ff 44 24 7c	 inc	 DWORD PTR [r12+124]
  0044d	41 83 7c 24 7c
	13		 cmp	 DWORD PTR [r12+124], 19
  00453	72 dd		 jb	 SHORT $LL233@inflateBac
$LN232@inflateBac:

; 376  :             state->next = state->codes;

  00455	49 8d 84 24 48
	05 00 00	 lea	 rax, QWORD PTR [r12+1352]

; 377  :             state->lencode = (code const FAR *)(state->next);
; 378  :             state->lenbits = 7;
; 379  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 380  :                                 &(state->lenbits), state->work);

  0045d	49 8d 94 24 08
	03 00 00	 lea	 rdx, QWORD PTR [r12+776]
  00465	4d 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR [r12+128]
  0046d	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  00472	49 89 84 24 80
	00 00 00	 mov	 QWORD PTR [r12+128], rax
  0047a	49 89 44 24 58	 mov	 QWORD PTR [r12+88], rax
  0047f	49 8d 44 24 68	 lea	 rax, QWORD PTR [r12+104]
  00484	49 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR [r12+136]
  0048c	41 b8 13 00 00
	00		 mov	 r8d, 19
  00492	33 c9		 xor	 ecx, ecx
  00494	c7 00 07 00 00
	00		 mov	 DWORD PTR [rax], 7
  0049a	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0049f	e8 00 00 00 00	 call	 inflate_table

; 381  :             if (ret) {

  004a4	85 c0		 test	 eax, eax
  004a6	74 26		 je	 SHORT $LN231@inflateBac

; 382  :                 strm->msg = (char *)"invalid code lengths set";

  004a8	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 383  :                 state->mode = BAD;
; 384  :                 break;

  004ac	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  004b0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
  004b7	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  004bb	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29
  004c3	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  004c7	33 d2		 xor	 edx, edx
  004c9	e9 bd 06 00 00	 jmp	 $LN402@inflateBac
$LN231@inflateBac:

; 385  :             }
; 386  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 387  : 
; 388  :             /* get length and distance code code lengths */
; 389  :             state->have = 0;
; 390  :             while (state->have < state->nlen + state->ndist) {

  004ce	41 8b 44 24 78	 mov	 eax, DWORD PTR [r12+120]
  004d3	41 c7 44 24 7c
	00 00 00 00	 mov	 DWORD PTR [r12+124], 0
  004dc	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  004e0	41 03 44 24 74	 add	 eax, DWORD PTR [r12+116]
  004e5	0f 84 be 02 00
	00		 je	 $LN229@inflateBac
  004eb	0f 1f 44 00 00	 npad	 5
$LL230@inflateBac:

; 391  :                 for (;;) {
; 392  :                     here = state->lencode[BITS(state->lenbits)];

  004f0	41 8b 4c 24 68	 mov	 ecx, DWORD PTR [r12+104]
  004f5	b8 01 00 00 00	 mov	 eax, 1
  004fa	d3 e0		 shl	 eax, cl
  004fc	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  004ff	41 8b c6	 mov	 eax, r14d
  00502	48 23 c8	 and	 rcx, rax
  00505	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  0050a	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]

; 393  :                     if ((unsigned)(here.bits) <= bits) break;

  0050d	8b c8		 mov	 ecx, eax
  0050f	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  00512	c1 e9 08	 shr	 ecx, 8
  00515	0f b6 c9	 movzx	 ecx, cl
  00518	3b ce		 cmp	 ecx, esi
  0051a	76 63		 jbe	 SHORT $LN383@inflateBac
  0051c	0f 1f 40 00	 npad	 4
$LL228@inflateBac:

; 394  :                     PULLBYTE();

  00520	85 ff		 test	 edi, edi
  00522	75 18		 jne	 SHORT $LN221@inflateBac
  00524	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00528	49 8b cd	 mov	 rcx, r13
  0052b	41 ff d7	 call	 r15
  0052e	8b f8		 mov	 edi, eax
  00530	85 c0		 test	 eax, eax
  00532	0f 84 e1 09 00
	00		 je	 $LN377@inflateBac
  00538	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN221@inflateBac:
  0053c	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00540	8b ce		 mov	 ecx, esi
  00542	49 ff c2	 inc	 r10
  00545	d3 e0		 shl	 eax, cl
  00547	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  0054b	41 8b 4c 24 68	 mov	 ecx, DWORD PTR [r12+104]
  00550	44 03 f0	 add	 r14d, eax
  00553	b8 01 00 00 00	 mov	 eax, 1
  00558	83 c6 08	 add	 esi, 8
  0055b	d3 e0		 shl	 eax, cl
  0055d	ff cf		 dec	 edi
  0055f	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00562	41 8b c6	 mov	 eax, r14d
  00565	48 23 c8	 and	 rcx, rax
  00568	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  0056d	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00570	8b c8		 mov	 ecx, eax
  00572	89 45 bc	 mov	 DWORD PTR here$[rbp-120], eax
  00575	c1 e9 08	 shr	 ecx, 8
  00578	0f b6 c9	 movzx	 ecx, cl
  0057b	3b ce		 cmp	 ecx, esi
  0057d	77 a1		 ja	 SHORT $LL228@inflateBac
$LN383@inflateBac:

; 395  :                 }
; 396  :                 if (here.val < 16) {

  0057f	8b c8		 mov	 ecx, eax
  00581	c1 e9 10	 shr	 ecx, 16
  00584	66 83 f9 10	 cmp	 cx, 16
  00588	73 6a		 jae	 SHORT $LN217@inflateBac

; 397  :                     NEEDBITS(here.bits);

  0058a	c1 e8 08	 shr	 eax, 8
  0058d	0f b6 d8	 movzx	 ebx, al
  00590	3b f3		 cmp	 esi, ebx
  00592	73 37		 jae	 SHORT $LN215@inflateBac
$LL213@inflateBac:
  00594	85 ff		 test	 edi, edi
  00596	75 18		 jne	 SHORT $LN207@inflateBac
  00598	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  0059c	49 8b cd	 mov	 rcx, r13
  0059f	41 ff d7	 call	 r15
  005a2	8b f8		 mov	 edi, eax
  005a4	85 c0		 test	 eax, eax
  005a6	0f 84 6d 09 00
	00		 je	 $LN377@inflateBac
  005ac	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN207@inflateBac:
  005b0	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  005b4	8b ce		 mov	 ecx, esi
  005b6	49 ff c2	 inc	 r10
  005b9	d3 e0		 shl	 eax, cl
  005bb	83 c6 08	 add	 esi, 8
  005be	ff cf		 dec	 edi
  005c0	44 03 f0	 add	 r14d, eax
  005c3	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  005c7	3b f3		 cmp	 esi, ebx
  005c9	72 c9		 jb	 SHORT $LL213@inflateBac
$LN215@inflateBac:

; 398  :                     DROPBITS(here.bits);

  005cb	0f b6 4d bd	 movzx	 ecx, BYTE PTR here$[rbp-119]

; 399  :                     state->lens[state->have++] = here.val;

  005cf	0f b7 45 be	 movzx	 eax, WORD PTR here$[rbp-118]
  005d3	41 d3 ee	 shr	 r14d, cl
  005d6	2b f1		 sub	 esi, ecx
  005d8	41 8b 4c 24 7c	 mov	 ecx, DWORD PTR [r12+124]
  005dd	66 41 89 84 4c
	88 00 00 00	 mov	 WORD PTR [r12+rcx*2+136], ax
  005e6	41 ff 44 24 7c	 inc	 DWORD PTR [r12+124]

; 400  :                 }
; 401  :                 else {

  005eb	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  005ef	e9 9c 01 00 00	 jmp	 $LN416@inflateBac
$LN217@inflateBac:

; 402  :                     if (here.val == 16) {

  005f4	0f b7 45 be	 movzx	 eax, WORD PTR here$[rbp-118]
  005f8	44 0f b6 7d bd	 movzx	 r15d, BYTE PTR here$[rbp-119]
  005fd	66 83 f8 10	 cmp	 ax, 16
  00601	75 7c		 jne	 SHORT $LN199@inflateBac

; 403  :                         NEEDBITS(here.bits + 2);

  00603	41 8d 5f 02	 lea	 ebx, DWORD PTR [r15+2]
  00607	3b f3		 cmp	 esi, ebx
  00609	73 3c		 jae	 SHORT $LN197@inflateBac
  0060b	0f 1f 44 00 00	 npad	 5
$LL195@inflateBac:
  00610	85 ff		 test	 edi, edi
  00612	75 18		 jne	 SHORT $LN189@inflateBac
  00614	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00618	49 8b cd	 mov	 rcx, r13
  0061b	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  0061e	8b f8		 mov	 edi, eax
  00620	85 c0		 test	 eax, eax
  00622	0f 84 f1 08 00
	00		 je	 $LN377@inflateBac
  00628	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN189@inflateBac:
  0062c	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00630	8b ce		 mov	 ecx, esi
  00632	49 ff c2	 inc	 r10
  00635	d3 e0		 shl	 eax, cl
  00637	83 c6 08	 add	 esi, 8
  0063a	ff cf		 dec	 edi
  0063c	44 03 f0	 add	 r14d, eax
  0063f	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00643	3b f3		 cmp	 esi, ebx
  00645	72 c9		 jb	 SHORT $LL195@inflateBac
$LN197@inflateBac:

; 404  :                         DROPBITS(here.bits);
; 405  :                         if (state->have == 0) {

  00647	41 8b 44 24 7c	 mov	 eax, DWORD PTR [r12+124]
  0064c	41 8b cf	 mov	 ecx, r15d
  0064f	41 2b f7	 sub	 esi, r15d
  00652	41 d3 ee	 shr	 r14d, cl
  00655	85 c0		 test	 eax, eax
  00657	0f 84 89 01 00
	00		 je	 $LN389@inflateBac

; 409  :                         }
; 410  :                         len = (unsigned)(state->lens[state->have - 1]);
; 411  :                         copy = 3 + BITS(2);

  0065d	45 8b c6	 mov	 r8d, r14d
  00660	ff c8		 dec	 eax

; 412  :                         DROPBITS(2);

  00662	41 c1 ee 02	 shr	 r14d, 2
  00666	45 0f b7 8c 44
	88 00 00 00	 movzx	 r9d, WORD PTR [r12+rax*2+136]
  0066f	41 83 e0 03	 and	 r8d, 3
  00673	41 83 c0 03	 add	 r8d, 3
  00677	83 c6 fe	 add	 esi, -2			; fffffffeH

; 413  :                     }
; 414  :                     else if (here.val == 17) {

  0067a	e9 ca 00 00 00	 jmp	 $LN138@inflateBac
$LN199@inflateBac:
  0067f	66 83 f8 11	 cmp	 ax, 17
  00683	75 5e		 jne	 SHORT $LN156@inflateBac

; 415  :                         NEEDBITS(here.bits + 3);

  00685	41 8d 5f 03	 lea	 ebx, DWORD PTR [r15+3]
  00689	3b f3		 cmp	 esi, ebx
  0068b	73 3a		 jae	 SHORT $LN175@inflateBac
  0068d	0f 1f 00	 npad	 3
$LL173@inflateBac:
  00690	85 ff		 test	 edi, edi
  00692	75 18		 jne	 SHORT $LN167@inflateBac
  00694	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00698	49 8b cd	 mov	 rcx, r13
  0069b	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  0069e	8b f8		 mov	 edi, eax
  006a0	85 c0		 test	 eax, eax
  006a2	0f 84 71 08 00
	00		 je	 $LN377@inflateBac
  006a8	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN167@inflateBac:
  006ac	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  006b0	8b ce		 mov	 ecx, esi
  006b2	49 ff c2	 inc	 r10
  006b5	d3 e0		 shl	 eax, cl
  006b7	83 c6 08	 add	 esi, 8
  006ba	ff cf		 dec	 edi
  006bc	44 03 f0	 add	 r14d, eax
  006bf	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  006c3	3b f3		 cmp	 esi, ebx
  006c5	72 c9		 jb	 SHORT $LL173@inflateBac
$LN175@inflateBac:

; 416  :                         DROPBITS(here.bits);

  006c7	41 8b cf	 mov	 ecx, r15d

; 417  :                         len = 0;
; 418  :                         copy = 3 + BITS(3);
; 419  :                         DROPBITS(3);

  006ca	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  006cf	41 d3 ee	 shr	 r14d, cl
  006d2	45 8b c6	 mov	 r8d, r14d
  006d5	41 83 e0 07	 and	 r8d, 7
  006d9	41 83 c0 03	 add	 r8d, 3
  006dd	41 c1 ee 03	 shr	 r14d, 3

; 420  :                     }
; 421  :                     else {

  006e1	eb 5e		 jmp	 SHORT $LN470@inflateBac
$LN156@inflateBac:

; 422  :                         NEEDBITS(here.bits + 7);

  006e3	41 8d 5f 07	 lea	 ebx, DWORD PTR [r15+7]
  006e7	3b f3		 cmp	 esi, ebx
  006e9	73 3c		 jae	 SHORT $LN155@inflateBac
  006eb	0f 1f 44 00 00	 npad	 5
$LL153@inflateBac:
  006f0	85 ff		 test	 edi, edi
  006f2	75 18		 jne	 SHORT $LN147@inflateBac
  006f4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  006f8	49 8b cd	 mov	 rcx, r13
  006fb	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  006fe	8b f8		 mov	 edi, eax
  00700	85 c0		 test	 eax, eax
  00702	0f 84 11 08 00
	00		 je	 $LN377@inflateBac
  00708	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN147@inflateBac:
  0070c	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00710	8b ce		 mov	 ecx, esi
  00712	49 ff c2	 inc	 r10
  00715	d3 e0		 shl	 eax, cl
  00717	83 c6 08	 add	 esi, 8
  0071a	ff cf		 dec	 edi
  0071c	44 03 f0	 add	 r14d, eax
  0071f	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00723	3b f3		 cmp	 esi, ebx
  00725	72 c9		 jb	 SHORT $LL153@inflateBac
$LN155@inflateBac:

; 423  :                         DROPBITS(here.bits);

  00727	41 8b cf	 mov	 ecx, r15d

; 424  :                         len = 0;
; 425  :                         copy = 11 + BITS(7);
; 426  :                         DROPBITS(7);

  0072a	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  0072f	41 d3 ee	 shr	 r14d, cl
  00732	45 8b c6	 mov	 r8d, r14d
  00735	41 83 e0 7f	 and	 r8d, 127		; 0000007fH
  00739	41 83 c0 0b	 add	 r8d, 11
  0073d	41 c1 ee 07	 shr	 r14d, 7
$LN470@inflateBac:
  00741	41 2b c7	 sub	 eax, r15d
  00744	45 33 c9	 xor	 r9d, r9d
  00747	03 f0		 add	 esi, eax
$LN138@inflateBac:

; 427  :                     }
; 428  :                     if (state->have + copy > state->nlen + state->ndist) {

  00749	41 8b 54 24 78	 mov	 edx, DWORD PTR [r12+120]
  0074e	41 8b 4c 24 7c	 mov	 ecx, DWORD PTR [r12+124]
  00753	41 03 54 24 74	 add	 edx, DWORD PTR [r12+116]
  00758	41 03 c8	 add	 ecx, r8d
  0075b	3b ca		 cmp	 ecx, edx
  0075d	0f 87 83 00 00
	00		 ja	 $LN389@inflateBac

; 429  :                         strm->msg = (char *)"invalid bit length repeat";
; 430  :                         state->mode = BAD;
; 431  :                         break;
; 432  :                     }
; 433  :                     while (copy--)

  00763	45 85 c0	 test	 r8d, r8d
  00766	74 24		 je	 SHORT $LN465@inflateBac
  00768	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL136@inflateBac:

; 434  :                         state->lens[state->have++] = (unsigned short)len;

  00770	41 8b 44 24 7c	 mov	 eax, DWORD PTR [r12+124]
  00775	66 45 89 8c 44
	88 00 00 00	 mov	 WORD PTR [r12+rax*2+136], r9w
  0077e	41 ff 44 24 7c	 inc	 DWORD PTR [r12+124]
  00783	41 ff c8	 dec	 r8d
  00786	75 e8		 jne	 SHORT $LL136@inflateBac

; 429  :                         strm->msg = (char *)"invalid bit length repeat";
; 430  :                         state->mode = BAD;
; 431  :                         break;
; 432  :                     }
; 433  :                     while (copy--)

  00788	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN465@inflateBac:
  0078c	4c 8b 7d 30	 mov	 r15, QWORD PTR in$[rbp-120]
$LN416@inflateBac:

; 385  :             }
; 386  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 387  : 
; 388  :             /* get length and distance code code lengths */
; 389  :             state->have = 0;
; 390  :             while (state->have < state->nlen + state->ndist) {

  00790	41 8b 44 24 78	 mov	 eax, DWORD PTR [r12+120]
  00795	41 03 44 24 74	 add	 eax, DWORD PTR [r12+116]
  0079a	41 39 44 24 7c	 cmp	 DWORD PTR [r12+124], eax
  0079f	0f 82 4b fd ff
	ff		 jb	 $LL230@inflateBac

; 505  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 506  :                         "inflate:         literal '%c'\n" :
; 507  :                         "inflate:         literal 0x%02x\n", here.val));
; 508  :                 ROOM();

  007a5	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN229@inflateBac:

; 435  :                 }
; 436  :             }
; 437  : 
; 438  :             /* handle error breaks in while */
; 439  :             if (state->mode == BAD) break;

  007a9	41 83 3c 24 1d	 cmp	 DWORD PTR [r12], 29
  007ae	0f 84 cd 03 00
	00		 je	 $LN467@inflateBac

; 440  : 
; 441  :             /* check for end-of-block code (better have one) */
; 442  :             if (state->lens[256] == 0) {

  007b4	66 41 83 bc 24
	88 02 00 00 00	 cmp	 WORD PTR [r12+648], 0
  007be	75 3e		 jne	 SHORT $LN133@inflateBac

; 443  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  007c0	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 444  :                 state->mode = BAD;
; 445  :                 break;

  007c4	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  007c8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
  007cf	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  007d3	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29
  007db	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  007df	33 d2		 xor	 edx, edx
  007e1	e9 a5 03 00 00	 jmp	 $LN402@inflateBac
$LN389@inflateBac:

; 406  :                             strm->msg = (char *)"invalid bit length repeat";

  007e6	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 407  :                             state->mode = BAD;
; 408  :                             break;

  007ea	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  007ee	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  007f2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  007f9	e9 72 01 00 00	 jmp	 $LN472@inflateBac
$LN133@inflateBac:

; 446  :             }
; 447  : 
; 448  :             /* build code tables -- note: do not change the lenbits or distbits
; 449  :                values here (9 and 6) without reading the comments in inftrees.h
; 450  :                concerning the ENOUGH constants, which depend on those values */
; 451  :             state->next = state->codes;

  007fe	49 8d 84 24 48
	05 00 00	 lea	 rax, QWORD PTR [r12+1352]

; 452  :             state->lencode = (code const FAR *)(state->next);
; 453  :             state->lenbits = 9;
; 454  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 455  :                                 &(state->lenbits), state->work);

  00806	4d 8d 84 24 08
	03 00 00	 lea	 r8, QWORD PTR [r12+776]
  0080e	4d 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR [r12+128]
  00816	4c 89 44 24 28	 mov	 QWORD PTR [rsp+40], r8
  0081b	45 8b 44 24 74	 mov	 r8d, DWORD PTR [r12+116]
  00820	49 89 84 24 80
	00 00 00	 mov	 QWORD PTR [r12+128], rax
  00828	49 89 44 24 58	 mov	 QWORD PTR [r12+88], rax
  0082d	49 8d 44 24 68	 lea	 rax, QWORD PTR [r12+104]
  00832	49 8d 94 24 88
	00 00 00	 lea	 rdx, QWORD PTR [r12+136]
  0083a	b9 01 00 00 00	 mov	 ecx, 1
  0083f	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9
  00845	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  0084a	e8 00 00 00 00	 call	 inflate_table

; 456  :             if (ret) {

  0084f	85 c0		 test	 eax, eax
  00851	74 26		 je	 SHORT $LN132@inflateBac

; 457  :                 strm->msg = (char *)"invalid literal/lengths set";

  00853	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 458  :                 state->mode = BAD;
; 459  :                 break;

  00857	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  0085b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
  00862	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  00866	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29
  0086e	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00872	33 d2		 xor	 edx, edx
  00874	e9 12 03 00 00	 jmp	 $LN402@inflateBac
$LN132@inflateBac:

; 460  :             }
; 461  :             state->distcode = (code const FAR *)(state->next);
; 462  :             state->distbits = 6;
; 463  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 464  :                             &(state->next), &(state->distbits), state->work);

  00879	45 8b 44 24 78	 mov	 r8d, DWORD PTR [r12+120]
  0087e	49 8d 4c 24 6c	 lea	 rcx, QWORD PTR [r12+108]
  00883	4d 8d 8c 24 80
	00 00 00	 lea	 r9, QWORD PTR [r12+128]
  0088b	49 8b 01	 mov	 rax, QWORD PTR [r9]
  0088e	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  00894	49 89 44 24 60	 mov	 QWORD PTR [r12+96], rax
  00899	41 8b 44 24 74	 mov	 eax, DWORD PTR [r12+116]
  0089e	48 83 c0 44	 add	 rax, 68			; 00000044H
  008a2	49 8d 14 44	 lea	 rdx, QWORD PTR [r12+rax*2]
  008a6	49 8d 84 24 08
	03 00 00	 lea	 rax, QWORD PTR [r12+776]
  008ae	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  008b3	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  008b8	b9 02 00 00 00	 mov	 ecx, 2
  008bd	e8 00 00 00 00	 call	 inflate_table

; 465  :             if (ret) {
; 466  :                 strm->msg = (char *)"invalid distances set";

  008c2	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 467  :                 state->mode = BAD;
; 468  :                 break;

  008c6	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  008ca	85 c0		 test	 eax, eax
  008cc	74 0c		 je	 SHORT $LN131@inflateBac

; 465  :             if (ret) {
; 466  :                 strm->msg = (char *)"invalid distances set";

  008ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 467  :                 state->mode = BAD;
; 468  :                 break;

  008d5	e9 96 00 00 00	 jmp	 $LN472@inflateBac
$LN131@inflateBac:

; 469  :             }
; 470  :             Tracev((stderr, "inflate:       codes ok\n"));
; 471  :             state->mode = LEN;

  008da	41 c7 04 24 14
	00 00 00	 mov	 DWORD PTR [r12], 20
  008e2	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  008e6	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN130@inflateBac:

; 472  : 
; 473  :         case LEN:
; 474  :             /* use inflate_fast() if we have enough input and output */
; 475  :             if (have >= 6 && left >= 258) {

  008ec	83 ff 06	 cmp	 edi, 6
  008ef	0f 82 92 00 00
	00		 jb	 $LN367@inflateBac
  008f5	41 81 f9 02 01
	00 00		 cmp	 r9d, 258		; 00000102H
  008fc	0f 82 85 00 00
	00		 jb	 $LN367@inflateBac

; 476  :                 RESTORE();

  00902	49 89 58 10	 mov	 QWORD PTR [r8+16], rbx
  00906	45 89 48 18	 mov	 DWORD PTR [r8+24], r9d
  0090a	4d 89 10	 mov	 QWORD PTR [r8], r10
  0090d	41 89 78 08	 mov	 DWORD PTR [r8+8], edi

; 477  :                 if (state->whave < state->wsize)

  00911	41 8b 54 24 2c	 mov	 edx, DWORD PTR [r12+44]
  00916	45 89 74 24 40	 mov	 DWORD PTR [r12+64], r14d
  0091b	41 89 74 24 44	 mov	 DWORD PTR [r12+68], esi
  00920	41 39 54 24 30	 cmp	 DWORD PTR [r12+48], edx
  00925	73 0a		 jae	 SHORT $LN125@inflateBac

; 478  :                     state->whave = state->wsize - left;

  00927	8b c2		 mov	 eax, edx
  00929	41 2b c1	 sub	 eax, r9d
  0092c	41 89 44 24 30	 mov	 DWORD PTR [r12+48], eax
$LN125@inflateBac:

; 479  :                 inflate_fast(strm, state->wsize);

  00931	49 8b c8	 mov	 rcx, r8
  00934	e8 00 00 00 00	 call	 inflate_fast

; 480  :                 LOAD();

  00939	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  0093d	33 d2		 xor	 edx, edx
  0093f	4d 8b 10	 mov	 r10, QWORD PTR [r8]
  00942	49 8b 58 10	 mov	 rbx, QWORD PTR [r8+16]
  00946	45 8b 48 18	 mov	 r9d, DWORD PTR [r8+24]
  0094a	41 8b 78 08	 mov	 edi, DWORD PTR [r8+8]
  0094e	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00952	45 8b 74 24 40	 mov	 r14d, DWORD PTR [r12+64]
  00957	41 8b 74 24 44	 mov	 esi, DWORD PTR [r12+68]
  0095c	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00960	44 89 4d b8	 mov	 DWORD PTR left$1$[rbp-120], r9d
  00964	e9 22 02 00 00	 jmp	 $LN402@inflateBac
$LN252@inflateBac:

; 360  :                 strm->msg = (char *)"too many length or distance symbols";

  00969	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
$LN472@inflateBac:
  00970	49 89 40 20	 mov	 QWORD PTR [r8+32], rax

; 361  :                 state->mode = BAD;

  00974	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29

; 362  :                 break;

  0097c	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00980	33 d2		 xor	 edx, edx
  00982	e9 04 02 00 00	 jmp	 $LN402@inflateBac
$LN367@inflateBac:

; 481  :                 break;
; 482  :             }
; 483  : 
; 484  :             /* get a literal, length, or end-of-block code */
; 485  :             for (;;) {
; 486  :                 here = state->lencode[BITS(state->lenbits)];

  00987	41 8b 4c 24 68	 mov	 ecx, DWORD PTR [r12+104]
  0098c	41 8b c3	 mov	 eax, r11d
  0098f	d3 e0		 shl	 eax, cl
  00991	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00994	41 8b c6	 mov	 eax, r14d
  00997	48 23 c8	 and	 rcx, rax
  0099a	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  0099f	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]

; 487  :                 if ((unsigned)(here.bits) <= bits) break;

  009a2	8b c8		 mov	 ecx, eax
  009a4	c1 e9 08	 shr	 ecx, 8
  009a7	0f b6 c9	 movzx	 ecx, cl
  009aa	3b ce		 cmp	 ecx, esi
  009ac	76 62		 jbe	 SHORT $LN391@inflateBac
  009ae	66 90		 npad	 2
$LL121@inflateBac:

; 488  :                 PULLBYTE();

  009b0	85 ff		 test	 edi, edi
  009b2	75 1e		 jne	 SHORT $LN114@inflateBac
  009b4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  009b8	49 8b cd	 mov	 rcx, r13
  009bb	41 ff d7	 call	 r15
  009be	8b f8		 mov	 edi, eax
  009c0	85 c0		 test	 eax, eax
  009c2	0f 84 51 05 00
	00		 je	 $LN377@inflateBac
  009c8	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  009cc	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN114@inflateBac:
  009d2	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  009d6	8b ce		 mov	 ecx, esi
  009d8	49 ff c2	 inc	 r10
  009db	d3 e0		 shl	 eax, cl
  009dd	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  009e1	41 8b 4c 24 68	 mov	 ecx, DWORD PTR [r12+104]
  009e6	44 03 f0	 add	 r14d, eax
  009e9	41 8b c3	 mov	 eax, r11d
  009ec	83 c6 08	 add	 esi, 8
  009ef	d3 e0		 shl	 eax, cl
  009f1	ff cf		 dec	 edi
  009f3	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  009f6	41 8b c6	 mov	 eax, r14d
  009f9	48 23 c8	 and	 rcx, rax
  009fc	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  00a01	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00a04	8b c8		 mov	 ecx, eax
  00a06	c1 e9 08	 shr	 ecx, 8
  00a09	0f b6 c9	 movzx	 ecx, cl
  00a0c	3b ce		 cmp	 ecx, esi
  00a0e	77 a0		 ja	 SHORT $LL121@inflateBac
$LN391@inflateBac:

; 489  :             }
; 490  :             if (here.op && (here.op & 0xf0) == 0) {

  00a10	84 c0		 test	 al, al
  00a12	0f 84 d6 00 00
	00		 je	 $LN96@inflateBac
  00a18	a8 f0		 test	 al, 240			; 000000f0H
  00a1a	0f 85 ce 00 00
	00		 jne	 $LN96@inflateBac

; 491  :                 last = here;
; 492  :                 for (;;) {
; 493  :                     here = state->lencode[last.val +
; 494  :                             (BITS(last.bits + last.op) >> last.bits)];

  00a20	44 8b c8	 mov	 r9d, eax
  00a23	0f b6 c8	 movzx	 ecx, al
  00a26	89 45 bc	 mov	 DWORD PTR last$[rbp-120], eax

; 495  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00a29	44 0f b6 7d bd	 movzx	 r15d, BYTE PTR last$[rbp-119]
  00a2e	41 c1 e9 08	 shr	 r9d, 8
  00a32	8b d8		 mov	 ebx, eax
  00a34	c1 e8 10	 shr	 eax, 16
  00a37	41 0f b6 d1	 movzx	 edx, r9b
  00a3b	45 8b c3	 mov	 r8d, r11d
  00a3e	03 ca		 add	 ecx, edx
  00a40	41 d3 e0	 shl	 r8d, cl
  00a43	8b ca		 mov	 ecx, edx
  00a45	41 ff c8	 dec	 r8d
  00a48	45 23 c6	 and	 r8d, r14d
  00a4b	41 d3 e8	 shr	 r8d, cl
  00a4e	44 03 c0	 add	 r8d, eax
  00a51	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  00a56	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  00a5a	8b c8		 mov	 ecx, eax
  00a5c	c1 e9 08	 shr	 ecx, 8
  00a5f	0f b6 d1	 movzx	 edx, cl
  00a62	41 0f b6 c9	 movzx	 ecx, r9b
  00a66	03 d1		 add	 edx, ecx
  00a68	3b d6		 cmp	 edx, esi
  00a6a	76 79		 jbe	 SHORT $LN98@inflateBac
  00a6c	44 0f b7 6d be	 movzx	 r13d, WORD PTR last$[rbp-118]
$LL109@inflateBac:

; 496  :                     PULLBYTE();

  00a71	85 ff		 test	 edi, edi
  00a73	75 1f		 jne	 SHORT $LN102@inflateBac
  00a75	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00a79	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00a7d	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00a80	8b f8		 mov	 edi, eax
  00a82	85 c0		 test	 eax, eax
  00a84	0f 84 8f 04 00
	00		 je	 $LN377@inflateBac
  00a8a	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00a8e	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN102@inflateBac:
  00a94	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00a98	8b ce		 mov	 ecx, esi
  00a9a	45 0f b6 c7	 movzx	 r8d, r15b
  00a9e	d3 e0		 shl	 eax, cl
  00aa0	41 8b d3	 mov	 edx, r11d
  00aa3	49 ff c2	 inc	 r10
  00aa6	44 03 f0	 add	 r14d, eax
  00aa9	41 0f b7 c5	 movzx	 eax, r13w
  00aad	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00ab1	0f b6 cb	 movzx	 ecx, bl
  00ab4	83 c6 08	 add	 esi, 8
  00ab7	ff cf		 dec	 edi
  00ab9	41 03 c8	 add	 ecx, r8d
  00abc	d3 e2		 shl	 edx, cl
  00abe	41 8b c8	 mov	 ecx, r8d
  00ac1	ff ca		 dec	 edx
  00ac3	41 23 d6	 and	 edx, r14d
  00ac6	d3 ea		 shr	 edx, cl
  00ac8	03 d0		 add	 edx, eax
  00aca	49 8b 44 24 58	 mov	 rax, QWORD PTR [r12+88]
  00acf	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00ad2	8b c8		 mov	 ecx, eax
  00ad4	c1 e9 08	 shr	 ecx, 8
  00ad7	0f b6 d1	 movzx	 edx, cl
  00ada	41 03 d0	 add	 edx, r8d
  00add	3b d6		 cmp	 edx, esi
  00adf	77 90		 ja	 SHORT $LL109@inflateBac
  00ae1	4c 8b 6d 38	 mov	 r13, QWORD PTR in_desc$[rbp-120]
$LN98@inflateBac:

; 497  :                 }
; 498  :                 DROPBITS(last.bits);

  00ae5	41 0f b6 cf	 movzx	 ecx, r15b
  00ae9	41 d3 ee	 shr	 r14d, cl
  00aec	2b f1		 sub	 esi, ecx
$LN96@inflateBac:

; 499  :             }
; 500  :             DROPBITS(here.bits);

  00aee	8b c8		 mov	 ecx, eax
  00af0	c1 e9 08	 shr	 ecx, 8
  00af3	0f b6 c9	 movzx	 ecx, cl
  00af6	41 d3 ee	 shr	 r14d, cl
  00af9	2b f1		 sub	 esi, ecx

; 501  :             state->length = (unsigned)here.val;

  00afb	8b c8		 mov	 ecx, eax
  00afd	c1 e9 10	 shr	 ecx, 16
  00b00	41 89 4c 24 48	 mov	 DWORD PTR [r12+72], ecx

; 502  : 
; 503  :             /* process literal */
; 504  :             if (here.op == 0) {

  00b05	84 c0		 test	 al, al
  00b07	75 64		 jne	 SHORT $LN92@inflateBac

; 505  :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 506  :                         "inflate:         literal '%c'\n" :
; 507  :                         "inflate:         literal 0x%02x\n", here.val));
; 508  :                 ROOM();

  00b09	44 8b 7d b8	 mov	 r15d, DWORD PTR left$1$[rbp-120]
  00b0d	45 85 ff	 test	 r15d, r15d
  00b10	75 2f		 jne	 SHORT $LN466@inflateBac
  00b12	45 8b 7c 24 2c	 mov	 r15d, DWORD PTR [r12+44]
  00b17	49 8b 5c 24 38	 mov	 rbx, QWORD PTR [r12+56]
  00b1c	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00b20	45 8b c7	 mov	 r8d, r15d
  00b23	48 8b d3	 mov	 rdx, rbx
  00b26	45 89 7c 24 30	 mov	 DWORD PTR [r12+48], r15d
  00b2b	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00b2e	85 c0		 test	 eax, eax
  00b30	74 13		 je	 SHORT $LN90@inflateBac
$LN380@inflateBac:

; 335  :                 ROOM();

  00b32	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00b36	41 bb fb ff ff
	ff		 mov	 r11d, -5
  00b3c	e9 18 04 00 00	 jmp	 $inf_leave$478
$LN466@inflateBac:
  00b41	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
$LN90@inflateBac:

; 509  :                 *put++ = (unsigned char)(state->length);

  00b45	41 0f b6 44 24
	48		 movzx	 eax, BYTE PTR [r12+72]
  00b4b	48 ff c3	 inc	 rbx

; 510  :                 left--;

  00b4e	41 ff cf	 dec	 r15d
  00b51	88 43 ff	 mov	 BYTE PTR [rbx-1], al

; 511  :                 state->mode = LEN;

  00b54	41 c7 04 24 14
	00 00 00	 mov	 DWORD PTR [r12], 20

; 512  :                 break;

  00b5c	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00b60	44 89 7d b8	 mov	 DWORD PTR left$1$[rbp-120], r15d
  00b64	45 8b cf	 mov	 r9d, r15d
  00b67	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00b6b	eb 18		 jmp	 SHORT $LN471@inflateBac
$LN92@inflateBac:

; 513  :             }
; 514  : 
; 515  :             /* process end of block */
; 516  :             if (here.op & 32) {

  00b6d	a8 20		 test	 al, 32			; 00000020H
  00b6f	74 37		 je	 SHORT $LN86@inflateBac

; 517  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 518  :                 state->mode = TYPE;
; 519  :                 break;

  00b71	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00b75	41 c7 04 24 0b
	00 00 00	 mov	 DWORD PTR [r12], 11
  00b7d	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
$LN467@inflateBac:
  00b81	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
$LN471@inflateBac:
  00b85	33 d2		 xor	 edx, edx
$LN469@inflateBac:
  00b87	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
$LN402@inflateBac:

; 275  :     hold = 0;
; 276  :     bits = 0;
; 277  :     put = state->window;
; 278  :     left = state->wsize;
; 279  : 
; 280  :     /* Inflate until end of block marked as last */
; 281  :     for (;;)
; 282  :         switch (state->mode) {

  00b8b	41 8b 04 24	 mov	 eax, DWORD PTR [r12]
  00b8f	83 e8 0b	 sub	 eax, 11
  00b92	83 f8 12	 cmp	 eax, 18
  00b95	0f 87 b8 03 00
	00		 ja	 $LN1@inflateBac
  00b9b	4c 8b 6d 38	 mov	 r13, QWORD PTR in_desc$[rbp-120]
  00b9f	4c 8b 7d 30	 mov	 r15, QWORD PTR in$[rbp-120]
  00ba3	e9 f5 f4 ff ff	 jmp	 $LN474@inflateBac
$LN86@inflateBac:

; 520  :             }
; 521  : 
; 522  :             /* invalid code */
; 523  :             if (here.op & 64) {

  00ba8	a8 40		 test	 al, 64			; 00000040H
  00baa	74 18		 je	 SHORT $LN85@inflateBac

; 524  :                 strm->msg = (char *)"invalid literal/length code";

  00bac	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 525  :                 state->mode = BAD;
; 526  :                 break;

  00bb0	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00bb4	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00bb8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  00bbf	e9 ac fd ff ff	 jmp	 $LN472@inflateBac
$LN85@inflateBac:

; 527  :             }
; 528  : 
; 529  :             /* length code -- get extra bits, if any */
; 530  :             state->extra = (unsigned)(here.op) & 15;

  00bc4	0f b6 c8	 movzx	 ecx, al
  00bc7	83 e1 0f	 and	 ecx, 15
  00bca	41 89 4c 24 50	 mov	 DWORD PTR [r12+80], ecx

; 531  :             if (state->extra != 0) {

  00bcf	74 67		 je	 SHORT $LN68@inflateBac

; 532  :                 NEEDBITS(state->extra);

  00bd1	3b f1		 cmp	 esi, ecx
  00bd3	73 4a		 jae	 SHORT $LN82@inflateBac
  00bd5	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
  00bd9	0f 1f 80 00 00
	00 00		 npad	 7
$LL80@inflateBac:
  00be0	85 ff		 test	 edi, edi
  00be2	75 18		 jne	 SHORT $LN74@inflateBac
  00be4	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00be8	49 8b cd	 mov	 rcx, r13
  00beb	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00bee	8b f8		 mov	 edi, eax
  00bf0	85 c0		 test	 eax, eax
  00bf2	0f 84 21 03 00
	00		 je	 $LN377@inflateBac
  00bf8	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN74@inflateBac:
  00bfc	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00bff	8b ce		 mov	 ecx, esi
  00c01	48 ff c2	 inc	 rdx
  00c04	d3 e0		 shl	 eax, cl
  00c06	83 c6 08	 add	 esi, 8
  00c09	ff cf		 dec	 edi
  00c0b	44 03 f0	 add	 r14d, eax
  00c0e	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00c12	41 3b 74 24 50	 cmp	 esi, DWORD PTR [r12+80]
  00c17	72 c7		 jb	 SHORT $LL80@inflateBac
  00c19	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN82@inflateBac:

; 533  :                 state->length += BITS(state->extra);

  00c1f	41 8b 4c 24 50	 mov	 ecx, DWORD PTR [r12+80]
  00c24	41 8b c3	 mov	 eax, r11d
  00c27	d3 e0		 shl	 eax, cl
  00c29	ff c8		 dec	 eax
  00c2b	41 23 c6	 and	 eax, r14d

; 534  :                 DROPBITS(state->extra);

  00c2e	41 d3 ee	 shr	 r14d, cl
  00c31	41 01 44 24 48	 add	 DWORD PTR [r12+72], eax
  00c36	2b f1		 sub	 esi, ecx
$LN68@inflateBac:

; 535  :             }
; 536  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 537  : 
; 538  :             /* get distance code */
; 539  :             for (;;) {
; 540  :                 here = state->distcode[BITS(state->distbits)];

  00c38	41 8b 4c 24 6c	 mov	 ecx, DWORD PTR [r12+108]

; 541  :                 if ((unsigned)(here.bits) <= bits) break;

  00c3d	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00c41	41 8b c3	 mov	 eax, r11d
  00c44	d3 e0		 shl	 eax, cl
  00c46	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00c49	41 8b c6	 mov	 eax, r14d
  00c4c	48 23 c8	 and	 rcx, rax
  00c4f	49 8b 44 24 60	 mov	 rax, QWORD PTR [r12+96]
  00c54	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00c57	8b c8		 mov	 ecx, eax
  00c59	c1 e9 08	 shr	 ecx, 8
  00c5c	0f b6 c9	 movzx	 ecx, cl
  00c5f	3b ce		 cmp	 ecx, esi
  00c61	76 60		 jbe	 SHORT $LN396@inflateBac
$LL67@inflateBac:

; 542  :                 PULLBYTE();

  00c63	85 ff		 test	 edi, edi
  00c65	75 1e		 jne	 SHORT $LN60@inflateBac
  00c67	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00c6b	49 8b cd	 mov	 rcx, r13
  00c6e	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00c71	8b f8		 mov	 edi, eax
  00c73	85 c0		 test	 eax, eax
  00c75	0f 84 9e 02 00
	00		 je	 $LN377@inflateBac
  00c7b	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00c7f	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN60@inflateBac:
  00c85	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00c89	8b ce		 mov	 ecx, esi
  00c8b	49 ff c2	 inc	 r10
  00c8e	d3 e0		 shl	 eax, cl
  00c90	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00c94	41 8b 4c 24 6c	 mov	 ecx, DWORD PTR [r12+108]
  00c99	44 03 f0	 add	 r14d, eax
  00c9c	41 8b c3	 mov	 eax, r11d
  00c9f	83 c6 08	 add	 esi, 8
  00ca2	d3 e0		 shl	 eax, cl
  00ca4	ff cf		 dec	 edi
  00ca6	8d 48 ff	 lea	 ecx, DWORD PTR [rax-1]
  00ca9	41 8b c6	 mov	 eax, r14d
  00cac	48 23 c8	 and	 rcx, rax
  00caf	49 8b 44 24 60	 mov	 rax, QWORD PTR [r12+96]
  00cb4	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  00cb7	8b c8		 mov	 ecx, eax
  00cb9	c1 e9 08	 shr	 ecx, 8
  00cbc	0f b6 c9	 movzx	 ecx, cl
  00cbf	3b ce		 cmp	 ecx, esi
  00cc1	77 a0		 ja	 SHORT $LL67@inflateBac
$LN396@inflateBac:

; 543  :             }
; 544  :             if ((here.op & 0xf0) == 0) {

  00cc3	a8 f0		 test	 al, 240			; 000000f0H
  00cc5	0f 85 ce 00 00
	00		 jne	 $LN42@inflateBac

; 545  :                 last = here;
; 546  :                 for (;;) {
; 547  :                     here = state->distcode[last.val +
; 548  :                             (BITS(last.bits + last.op) >> last.bits)];

  00ccb	44 8b c8	 mov	 r9d, eax
  00cce	0f b6 c8	 movzx	 ecx, al
  00cd1	89 45 bc	 mov	 DWORD PTR last$[rbp-120], eax

; 549  :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00cd4	44 0f b6 6d bd	 movzx	 r13d, BYTE PTR last$[rbp-119]
  00cd9	41 c1 e9 08	 shr	 r9d, 8
  00cdd	8b d8		 mov	 ebx, eax
  00cdf	c1 e8 10	 shr	 eax, 16
  00ce2	41 0f b6 d1	 movzx	 edx, r9b
  00ce6	45 8b c3	 mov	 r8d, r11d
  00ce9	03 ca		 add	 ecx, edx
  00ceb	41 d3 e0	 shl	 r8d, cl
  00cee	8b ca		 mov	 ecx, edx
  00cf0	41 ff c8	 dec	 r8d
  00cf3	45 23 c6	 and	 r8d, r14d
  00cf6	41 d3 e8	 shr	 r8d, cl
  00cf9	44 03 c0	 add	 r8d, eax
  00cfc	49 8b 44 24 60	 mov	 rax, QWORD PTR [r12+96]
  00d01	42 8b 04 80	 mov	 eax, DWORD PTR [rax+r8*4]
  00d05	8b c8		 mov	 ecx, eax
  00d07	c1 e9 08	 shr	 ecx, 8
  00d0a	0f b6 d1	 movzx	 edx, cl
  00d0d	41 0f b6 c9	 movzx	 ecx, r9b
  00d11	03 d1		 add	 edx, ecx
  00d13	3b d6		 cmp	 edx, esi
  00d15	76 79		 jbe	 SHORT $LN44@inflateBac
  00d17	44 0f b7 7d be	 movzx	 r15d, WORD PTR last$[rbp-118]
  00d1c	0f 1f 40 00	 npad	 4
$LL55@inflateBac:

; 550  :                     PULLBYTE();

  00d20	85 ff		 test	 edi, edi
  00d22	75 1f		 jne	 SHORT $LN48@inflateBac
  00d24	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00d28	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00d2c	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00d2f	8b f8		 mov	 edi, eax
  00d31	85 c0		 test	 eax, eax
  00d33	0f 84 e0 01 00
	00		 je	 $LN377@inflateBac
  00d39	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00d3d	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN48@inflateBac:
  00d43	41 0f b6 02	 movzx	 eax, BYTE PTR [r10]
  00d47	8b ce		 mov	 ecx, esi
  00d49	45 0f b6 c5	 movzx	 r8d, r13b
  00d4d	d3 e0		 shl	 eax, cl
  00d4f	41 8b d3	 mov	 edx, r11d
  00d52	49 ff c2	 inc	 r10
  00d55	44 03 f0	 add	 r14d, eax
  00d58	41 0f b7 c7	 movzx	 eax, r15w
  00d5c	4c 89 55 c0	 mov	 QWORD PTR next$[rbp-120], r10
  00d60	0f b6 cb	 movzx	 ecx, bl
  00d63	83 c6 08	 add	 esi, 8
  00d66	ff cf		 dec	 edi
  00d68	41 03 c8	 add	 ecx, r8d
  00d6b	d3 e2		 shl	 edx, cl
  00d6d	41 8b c8	 mov	 ecx, r8d
  00d70	ff ca		 dec	 edx
  00d72	41 23 d6	 and	 edx, r14d
  00d75	d3 ea		 shr	 edx, cl
  00d77	03 d0		 add	 edx, eax
  00d79	49 8b 44 24 60	 mov	 rax, QWORD PTR [r12+96]
  00d7e	8b 04 90	 mov	 eax, DWORD PTR [rax+rdx*4]
  00d81	8b c8		 mov	 ecx, eax
  00d83	c1 e9 08	 shr	 ecx, 8
  00d86	0f b6 d1	 movzx	 edx, cl
  00d89	41 03 d0	 add	 edx, r8d
  00d8c	3b d6		 cmp	 edx, esi
  00d8e	77 90		 ja	 SHORT $LL55@inflateBac
$LN44@inflateBac:

; 551  :                 }
; 552  :                 DROPBITS(last.bits);

  00d90	41 0f b6 cd	 movzx	 ecx, r13b
  00d94	41 d3 ee	 shr	 r14d, cl
  00d97	2b f1		 sub	 esi, ecx
$LN42@inflateBac:

; 553  :             }
; 554  :             DROPBITS(here.bits);

  00d99	8b c8		 mov	 ecx, eax
  00d9b	c1 e9 08	 shr	 ecx, 8
  00d9e	0f b6 c9	 movzx	 ecx, cl
  00da1	41 d3 ee	 shr	 r14d, cl
  00da4	2b f1		 sub	 esi, ecx

; 555  :             if (here.op & 64) {

  00da6	a8 40		 test	 al, 64			; 00000040H
  00da8	74 18		 je	 SHORT $LN38@inflateBac

; 556  :                 strm->msg = (char *)"invalid distance code";

  00daa	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]

; 557  :                 state->mode = BAD;
; 558  :                 break;

  00dae	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00db2	44 8b 4d b8	 mov	 r9d, DWORD PTR left$1$[rbp-120]
  00db6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  00dbd	e9 ae fb ff ff	 jmp	 $LN472@inflateBac
$LN38@inflateBac:

; 559  :             }
; 560  :             state->offset = (unsigned)here.val;

  00dc2	8b c8		 mov	 ecx, eax
  00dc4	c1 e9 10	 shr	 ecx, 16
  00dc7	41 89 4c 24 4c	 mov	 DWORD PTR [r12+76], ecx

; 561  : 
; 562  :             /* get distance extra bits, if any */
; 563  :             state->extra = (unsigned)(here.op) & 15;

  00dcc	0f b6 c8	 movzx	 ecx, al
  00dcf	83 e1 0f	 and	 ecx, 15
  00dd2	41 89 4c 24 50	 mov	 DWORD PTR [r12+80], ecx

; 564  :             if (state->extra != 0) {

  00dd7	74 61		 je	 SHORT $LN21@inflateBac

; 565  :                 NEEDBITS(state->extra);

  00dd9	3b f1		 cmp	 esi, ecx
  00ddb	73 44		 jae	 SHORT $LN35@inflateBac
  00ddd	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LL33@inflateBac:
  00de1	85 ff		 test	 edi, edi
  00de3	75 19		 jne	 SHORT $LN27@inflateBac
  00de5	48 8b 4d 38	 mov	 rcx, QWORD PTR in_desc$[rbp-120]
  00de9	48 8d 55 c0	 lea	 rdx, QWORD PTR next$[rbp-120]
  00ded	ff 55 30	 call	 QWORD PTR in$[rbp-120]
  00df0	8b f8		 mov	 edi, eax
  00df2	85 c0		 test	 eax, eax
  00df4	0f 84 1f 01 00
	00		 je	 $LN377@inflateBac
  00dfa	48 8b 55 c0	 mov	 rdx, QWORD PTR next$[rbp-120]
$LN27@inflateBac:
  00dfe	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00e01	8b ce		 mov	 ecx, esi
  00e03	48 ff c2	 inc	 rdx
  00e06	d3 e0		 shl	 eax, cl
  00e08	83 c6 08	 add	 esi, 8
  00e0b	ff cf		 dec	 edi
  00e0d	44 03 f0	 add	 r14d, eax
  00e10	48 89 55 c0	 mov	 QWORD PTR next$[rbp-120], rdx
  00e14	41 3b 74 24 50	 cmp	 esi, DWORD PTR [r12+80]
  00e19	72 c6		 jb	 SHORT $LL33@inflateBac
  00e1b	41 bb 01 00 00
	00		 mov	 r11d, 1
$LN35@inflateBac:

; 566  :                 state->offset += BITS(state->extra);

  00e21	41 8b 4c 24 50	 mov	 ecx, DWORD PTR [r12+80]
  00e26	41 8b c3	 mov	 eax, r11d
  00e29	d3 e0		 shl	 eax, cl
  00e2b	ff c8		 dec	 eax
  00e2d	41 23 c6	 and	 eax, r14d

; 567  :                 DROPBITS(state->extra);

  00e30	41 d3 ee	 shr	 r14d, cl
  00e33	41 01 44 24 4c	 add	 DWORD PTR [r12+76], eax
  00e38	2b f1		 sub	 esi, ecx
$LN21@inflateBac:

; 568  :             }
; 569  :             if (state->offset > state->wsize - (state->whave < state->wsize ?
; 570  :                                                 left : 0)) {

  00e3a	41 8b 4c 24 2c	 mov	 ecx, DWORD PTR [r12+44]
  00e3f	44 8b 7d b8	 mov	 r15d, DWORD PTR left$1$[rbp-120]

; 572  :                 state->mode = BAD;
; 573  :                 break;

  00e43	48 8b 5d c8	 mov	 rbx, QWORD PTR put$1$[rbp-120]
  00e47	33 d2		 xor	 edx, edx
  00e49	41 39 4c 24 30	 cmp	 DWORD PTR [r12+48], ecx
  00e4e	8b c2		 mov	 eax, edx
  00e50	41 0f 42 c7	 cmovb	 eax, r15d
  00e54	2b c8		 sub	 ecx, eax
  00e56	41 39 4c 24 4c	 cmp	 DWORD PTR [r12+76], ecx
  00e5b	76 23		 jbe	 SHORT $LL19@inflateBac

; 571  :                 strm->msg = (char *)"invalid distance too far back";

  00e5d	4c 8b 45 28	 mov	 r8, QWORD PTR strm$[rbp-120]
  00e61	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 572  :                 state->mode = BAD;
; 573  :                 break;

  00e68	45 8b cf	 mov	 r9d, r15d
  00e6b	49 89 40 20	 mov	 QWORD PTR [r8+32], rax
  00e6f	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29
  00e77	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00e7b	e9 0b fd ff ff	 jmp	 $LN402@inflateBac
$LL19@inflateBac:

; 574  :             }
; 575  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 576  : 
; 577  :             /* copy match from window to output */
; 578  :             do {
; 579  :                 ROOM();

  00e80	45 85 ff	 test	 r15d, r15d
  00e83	75 24		 jne	 SHORT $LN15@inflateBac
  00e85	45 8b 7c 24 2c	 mov	 r15d, DWORD PTR [r12+44]
  00e8a	49 8b 5c 24 38	 mov	 rbx, QWORD PTR [r12+56]
  00e8f	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00e93	45 8b c7	 mov	 r8d, r15d
  00e96	48 8b d3	 mov	 rdx, rbx
  00e99	45 89 7c 24 30	 mov	 DWORD PTR [r12+48], r15d
  00e9e	ff 55 40	 call	 QWORD PTR out$[rbp-120]
  00ea1	85 c0		 test	 eax, eax
  00ea3	0f 85 89 fc ff
	ff		 jne	 $LN380@inflateBac
$LN15@inflateBac:

; 580  :                 copy = state->wsize - state->offset;

  00ea9	41 8b 4c 24 4c	 mov	 ecx, DWORD PTR [r12+76]
  00eae	41 8b 44 24 2c	 mov	 eax, DWORD PTR [r12+44]
  00eb3	2b c1		 sub	 eax, ecx

; 581  :                 if (copy < left) {

  00eb5	41 3b c7	 cmp	 eax, r15d
  00eb8	73 0c		 jae	 SHORT $LN11@inflateBac

; 582  :                     from = put + copy;

  00eba	8b d0		 mov	 edx, eax

; 583  :                     copy = left - copy;

  00ebc	41 8b cf	 mov	 ecx, r15d
  00ebf	48 03 d3	 add	 rdx, rbx
  00ec2	2b c8		 sub	 ecx, eax

; 584  :                 }
; 585  :                 else {

  00ec4	eb 09		 jmp	 SHORT $LN10@inflateBac
$LN11@inflateBac:

; 586  :                     from = put - state->offset;

  00ec6	48 8b d3	 mov	 rdx, rbx
  00ec9	48 2b d1	 sub	 rdx, rcx

; 587  :                     copy = left;

  00ecc	41 8b cf	 mov	 ecx, r15d
$LN10@inflateBac:

; 588  :                 }
; 589  :                 if (copy > state->length) copy = state->length;

  00ecf	41 3b 4c 24 48	 cmp	 ecx, DWORD PTR [r12+72]
  00ed4	41 0f 47 4c 24
	48		 cmova	 ecx, DWORD PTR [r12+72]

; 590  :                 state->length -= copy;

  00eda	41 29 4c 24 48	 sub	 DWORD PTR [r12+72], ecx

; 591  :                 left -= copy;

  00edf	44 2b f9	 sub	 r15d, ecx

; 594  :                 } while (--copy);

  00ee2	48 2b d3	 sub	 rdx, rbx
  00ee5	44 89 7d b8	 mov	 DWORD PTR left$1$[rbp-120], r15d
  00ee9	0f 1f 80 00 00
	00 00		 npad	 7
$LL8@inflateBac:

; 592  :                 do {
; 593  :                     *put++ = *from++;

  00ef0	0f b6 04 1a	 movzx	 eax, BYTE PTR [rdx+rbx]
  00ef4	48 ff c3	 inc	 rbx
  00ef7	88 43 ff	 mov	 BYTE PTR [rbx-1], al

; 594  :                 } while (--copy);

  00efa	ff c9		 dec	 ecx
  00efc	75 f2		 jne	 SHORT $LL8@inflateBac

; 595  :             } while (state->length != 0);

  00efe	48 89 5d c8	 mov	 QWORD PTR put$1$[rbp-120], rbx
  00f02	41 39 4c 24 48	 cmp	 DWORD PTR [r12+72], ecx
  00f07	0f 85 73 ff ff
	ff		 jne	 $LL19@inflateBac
  00f0d	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00f11	45 8b cf	 mov	 r9d, r15d
  00f14	e9 6c fc ff ff	 jmp	 $LN471@inflateBac
$LN377@inflateBac:

; 289  :             }
; 290  :             NEEDBITS(3);

  00f19	45 33 d2	 xor	 r10d, r10d
$LN475@inflateBac:
  00f1c	41 bb fb ff ff
	ff		 mov	 r11d, -5
  00f22	eb 35		 jmp	 SHORT $inf_leave$478
$LN5@inflateBac:

; 596  :             break;
; 597  : 
; 598  :         case DONE:
; 599  :             /* inflate stream terminated properly -- write leftover output */
; 600  :             ret = Z_STREAM_END;
; 601  :             if (left < state->wsize) {

  00f24	45 8b 44 24 2c	 mov	 r8d, DWORD PTR [r12+44]
  00f29	45 3b c8	 cmp	 r9d, r8d
  00f2c	73 2b		 jae	 SHORT $inf_leave$478

; 602  :                 if (out(out_desc, state->window, state->wsize - left))

  00f2e	49 8b 54 24 38	 mov	 rdx, QWORD PTR [r12+56]
  00f33	48 8b 4d 48	 mov	 rcx, QWORD PTR out_desc$[rbp-120]
  00f37	45 2b c1	 sub	 r8d, r9d
  00f3a	ff 55 40	 call	 QWORD PTR out$[rbp-120]

; 603  :                     ret = Z_BUF_ERROR;
; 604  :             }
; 605  :             goto inf_leave;

  00f3d	4c 8b 55 c0	 mov	 r10, QWORD PTR next$[rbp-120]
  00f41	85 c0		 test	 eax, eax
  00f43	75 d7		 jne	 SHORT $LN475@inflateBac
  00f45	44 8d 58 01	 lea	 r11d, QWORD PTR [rax+1]
  00f49	eb 0e		 jmp	 SHORT $inf_leave$478
$LN2@inflateBac:

; 606  : 
; 607  :         case BAD:
; 608  :             ret = Z_DATA_ERROR;

  00f4b	41 bb fd ff ff
	ff		 mov	 r11d, -3

; 609  :             goto inf_leave;

  00f51	eb 06		 jmp	 SHORT $inf_leave$478
$LN1@inflateBac:

; 610  : 
; 611  :         default:                /* can't happen, but makes compilers happy */
; 612  :             ret = Z_STREAM_ERROR;

  00f53	41 bb fe ff ff
	ff		 mov	 r11d, -2
$inf_leave$478:

; 613  :             goto inf_leave;
; 614  :         }
; 615  : 
; 616  :     /* Return unused input */
; 617  :   inf_leave:
; 618  :     strm->next_in = next;

  00f59	48 8b 45 28	 mov	 rax, QWORD PTR strm$[rbp-120]
  00f5d	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  00f62	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  00f67	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]

; 619  :     strm->avail_in = have;

  00f6c	89 78 08	 mov	 DWORD PTR [rax+8], edi
  00f6f	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00f74	4c 89 10	 mov	 QWORD PTR [rax], r10

; 620  :     return ret;

  00f77	41 8b c3	 mov	 eax, r11d

; 621  : }

  00f7a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00f7e	41 5f		 pop	 r15
  00f80	41 5d		 pop	 r13
  00f82	41 5c		 pop	 r12
  00f84	5d		 pop	 rbp
  00f85	c3		 ret	 0
$LN346@inflateBac:

; 265  :         return Z_STREAM_ERROR;

  00f86	b8 fe ff ff ff	 mov	 eax, -2

; 621  : }

  00f8b	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00f8f	41 5f		 pop	 r15
  00f91	41 5d		 pop	 r13
  00f93	41 5c		 pop	 r12
  00f95	5d		 pop	 rbp
  00f96	c3		 ret	 0
  00f97	90		 npad	 1
$LN453@inflateBac:
  00f98	00 00 00 00	 DD	 $LN341@inflateBac
  00f9c	00 00 00 00	 DD	 $LN1@inflateBac
  00fa0	00 00 00 00	 DD	 $LN310@inflateBac
  00fa4	00 00 00 00	 DD	 $LN1@inflateBac
  00fa8	00 00 00 00	 DD	 $LN1@inflateBac
  00fac	00 00 00 00	 DD	 $LN275@inflateBac
  00fb0	00 00 00 00	 DD	 $LN1@inflateBac
  00fb4	00 00 00 00	 DD	 $LN1@inflateBac
  00fb8	00 00 00 00	 DD	 $LN1@inflateBac
  00fbc	00 00 00 00	 DD	 $LN130@inflateBac
  00fc0	00 00 00 00	 DD	 $LN1@inflateBac
  00fc4	00 00 00 00	 DD	 $LN1@inflateBac
  00fc8	00 00 00 00	 DD	 $LN1@inflateBac
  00fcc	00 00 00 00	 DD	 $LN1@inflateBac
  00fd0	00 00 00 00	 DD	 $LN1@inflateBac
  00fd4	00 00 00 00	 DD	 $LN1@inflateBac
  00fd8	00 00 00 00	 DD	 $LN1@inflateBac
  00fdc	00 00 00 00	 DD	 $LN5@inflateBac
  00fe0	00 00 00 00	 DD	 $LN2@inflateBac
inflateBack ENDP
_TEXT	ENDS
END
