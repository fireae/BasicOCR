; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	inflate_fast
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate_fast DD imagerel $LN97
	DD	imagerel $LN97+1234
	DD	imagerel $unwind$inflate_fast
pdata	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_fast DD 091501H
	DD	0f0116215H
	DD	0d00de00fH
	DD	07009c00bH
	DD	050076008H
	DD	03006H
xdata	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inffast.c
;	COMDAT inflate_fast
_TEXT	SEGMENT
dcode$1$ = 0
lcode$1$ = 8
beg$1$ = 16
window$1$ = 24
tv445 = 32
strm$ = 128
wsize$1$ = 136
start$ = 136
dmask$1$ = 144
whave$1$ = 152
inflate_fast PROC					; COMDAT

; 70   : {

$LN97:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	55		 push	 rbp
  00007	56		 push	 rsi
  00008	57		 push	 rdi
  00009	41 54		 push	 r12
  0000b	41 55		 push	 r13
  0000d	41 56		 push	 r14
  0000f	41 57		 push	 r15
  00011	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 71   :     struct inflate_state FAR *state;
; 72   :     unsigned char FAR *in;      /* local strm->next_in */
; 73   :     unsigned char FAR *last;    /* while in < last, enough input available */
; 74   :     unsigned char FAR *out;     /* local strm->next_out */
; 75   :     unsigned char FAR *beg;     /* inflate()'s initial strm->next_out */
; 76   :     unsigned char FAR *end;     /* while out < end, enough space available */
; 77   : #ifdef INFLATE_STRICT
; 78   :     unsigned dmax;              /* maximum distance from zlib header */
; 79   : #endif
; 80   :     unsigned wsize;             /* window size or zero if not using window */
; 81   :     unsigned whave;             /* valid bytes in the window */
; 82   :     unsigned wnext;             /* window write index */
; 83   :     unsigned char FAR *window;  /* allocated sliding window, if wsize != 0 */
; 84   :     unsigned long hold;         /* local strm->hold */
; 85   :     unsigned bits;              /* local strm->bits */
; 86   :     code const FAR *lcode;      /* local strm->lencode */
; 87   :     code const FAR *dcode;      /* local strm->distcode */
; 88   :     unsigned lmask;             /* mask for first level of length codes */
; 89   :     unsigned dmask;             /* mask for first level of distance codes */
; 90   :     code here;                  /* retrieved table entry */
; 91   :     unsigned op;                /* code bits, operation, extra bits, or */
; 92   :                                 /*  window position, window bytes to copy */
; 93   :     unsigned len;               /* match length, unused bytes */
; 94   :     unsigned dist;              /* match distance */
; 95   :     unsigned char FAR *from;    /* where to copy match from */
; 96   : 
; 97   :     /* copy state to local variables */
; 98   :     state = (struct inflate_state FAR *)strm->state;

  00015	4c 8b 61 28	 mov	 r12, QWORD PTR [rcx+40]

; 99   :     in = strm->next_in - OFF;
; 100  :     last = in + (strm->avail_in - 5);

  00019	44 8b 69 08	 mov	 r13d, DWORD PTR [rcx+8]
  0001d	48 8b 31	 mov	 rsi, QWORD PTR [rcx]

; 101  :     out = strm->next_out - OFF;

  00020	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 102  :     beg = out - (start - strm->avail_out);

  00024	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]

; 103  :     end = out + (strm->avail_out - 257);
; 104  : #ifdef INFLATE_STRICT
; 105  :     dmax = state->dmax;
; 106  : #endif
; 107  :     wsize = state->wsize;
; 108  :     whave = state->whave;
; 109  :     wnext = state->wnext;
; 110  :     window = state->window;
; 111  :     hold = state->hold;
; 112  :     bits = state->bits;
; 113  :     lcode = state->lencode;

  00027	4d 8b 4c 24 58	 mov	 r9, QWORD PTR [r12+88]

; 114  :     dcode = state->distcode;

  0002c	49 8b 7c 24 60	 mov	 rdi, QWORD PTR [r12+96]
  00031	45 8b 74 24 34	 mov	 r14d, DWORD PTR [r12+52]
  00036	41 8b 5c 24 40	 mov	 ebx, DWORD PTR [r12+64]
  0003b	45 8b 5c 24 44	 mov	 r11d, DWORD PTR [r12+68]
  00040	2b d1		 sub	 edx, ecx
  00042	49 ff c8	 dec	 r8
  00045	8b c2		 mov	 eax, edx
  00047	44 8d b9 ff fe
	ff ff		 lea	 r15d, DWORD PTR [rcx-257]

; 115  :     lmask = (1U << state->lenbits) - 1;

  0004e	41 8b 4c 24 68	 mov	 ecx, DWORD PTR [r12+104]
  00053	bd 01 00 00 00	 mov	 ebp, 1
  00058	49 8b d0	 mov	 rdx, r8
  0005b	48 ff ce	 dec	 rsi
  0005e	48 2b d0	 sub	 rdx, rax
  00061	41 8b 44 24 2c	 mov	 eax, DWORD PTR [r12+44]
  00066	41 83 ed 05	 sub	 r13d, 5
  0006a	89 84 24 88 00
	00 00		 mov	 DWORD PTR wsize$1$[rsp], eax
  00071	41 8b 44 24 30	 mov	 eax, DWORD PTR [r12+48]
  00076	48 89 54 24 10	 mov	 QWORD PTR beg$1$[rsp], rdx
  0007b	89 84 24 98 00
	00 00		 mov	 DWORD PTR whave$1$[rsp], eax
  00082	49 8b 44 24 38	 mov	 rax, QWORD PTR [r12+56]

; 116  :     dmask = (1U << state->distbits) - 1;

  00087	8b d5		 mov	 edx, ebp
  00089	48 89 44 24 18	 mov	 QWORD PTR window$1$[rsp], rax
  0008e	8b c5		 mov	 eax, ebp
  00090	4c 03 ee	 add	 r13, rsi
  00093	d3 e0		 shl	 eax, cl
  00095	41 8b 4c 24 6c	 mov	 ecx, DWORD PTR [r12+108]
  0009a	4d 03 f8	 add	 r15, r8
  0009d	d3 e2		 shl	 edx, cl
  0009f	ff c8		 dec	 eax
  000a1	4c 89 4c 24 08	 mov	 QWORD PTR lcode$1$[rsp], r9
  000a6	ff ca		 dec	 edx
  000a8	48 89 3c 24	 mov	 QWORD PTR dcode$1$[rsp], rdi
  000ac	89 94 24 90 00
	00 00		 mov	 DWORD PTR dmask$1$[rsp], edx
  000b3	8b d0		 mov	 edx, eax
  000b5	48 89 54 24 20	 mov	 QWORD PTR tv445[rsp], rdx
  000ba	66 0f 1f 44 00
	00		 npad	 6
$LL55@inflate_fa:

; 117  : 
; 118  :     /* decode literals and length/distances until end-of-block or not enough
; 119  :        input data or output space */
; 120  :     do {
; 121  :         if (bits < 15) {

  000c0	41 83 fb 0f	 cmp	 r11d, 15
  000c4	73 1e		 jae	 SHORT $LN52@inflate_fa

; 122  :             hold += (unsigned long)(PUP(in)) << bits;

  000c6	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  000ca	41 8b cb	 mov	 ecx, r11d

; 123  :             bits += 8;
; 124  :             hold += (unsigned long)(PUP(in)) << bits;

  000cd	48 83 c6 02	 add	 rsi, 2
  000d1	d3 e0		 shl	 eax, cl
  000d3	41 8d 4b 08	 lea	 ecx, DWORD PTR [r11+8]
  000d7	03 d8		 add	 ebx, eax
  000d9	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  000dc	d3 e0		 shl	 eax, cl
  000de	03 d8		 add	 ebx, eax

; 125  :             bits += 8;

  000e0	41 83 c3 10	 add	 r11d, 16
$LN52@inflate_fa:

; 126  :         }
; 127  :         here = lcode[hold & lmask];

  000e4	8b c3		 mov	 eax, ebx
  000e6	48 23 c2	 and	 rax, rdx
  000e9	45 8b 14 81	 mov	 r10d, DWORD PTR [r9+rax*4]

; 128  :       dolen:
; 129  :         op = (unsigned)(here.bits);

  000ed	41 8b c2	 mov	 eax, r10d

; 130  :         hold >>= op;
; 131  :         bits -= op;
; 132  :         op = (unsigned)(here.op);

  000f0	41 0f b6 d2	 movzx	 edx, r10b
  000f4	c1 e8 08	 shr	 eax, 8
  000f7	0f b6 c8	 movzx	 ecx, al
  000fa	d3 eb		 shr	 ebx, cl
  000fc	44 2b d9	 sub	 r11d, ecx

; 133  :         if (op == 0) {                          /* literal */

  000ff	45 84 d2	 test	 r10b, r10b
  00102	74 3a		 je	 SHORT $LN72@inflate_fa
$dolen$98:

; 138  :         }
; 139  :         else if (op & 16) {                     /* length base */

  00104	f6 c2 10	 test	 dl, 16
  00107	75 44		 jne	 SHORT $LN73@inflate_fa

; 291  :             }
; 292  :         }
; 293  :         else if ((op & 64) == 0) {              /* 2nd level length code */

  00109	f6 c2 40	 test	 dl, 64			; 00000040H
  0010c	0f 85 07 03 00
	00		 jne	 $LN5@inflate_fa

; 294  :             here = lcode[here.val + (hold & ((1U << op) - 1))];

  00112	8b ca		 mov	 ecx, edx
  00114	41 c1 ea 10	 shr	 r10d, 16
  00118	8b c5		 mov	 eax, ebp
  0011a	d3 e0		 shl	 eax, cl
  0011c	ff c8		 dec	 eax
  0011e	23 c3		 and	 eax, ebx
  00120	41 03 c2	 add	 eax, r10d
  00123	45 8b 14 81	 mov	 r10d, DWORD PTR [r9+rax*4]
  00127	41 8b c2	 mov	 eax, r10d
  0012a	41 0f b6 d2	 movzx	 edx, r10b
  0012e	c1 e8 08	 shr	 eax, 8
  00131	0f b6 c8	 movzx	 ecx, al
  00134	d3 eb		 shr	 ebx, cl
  00136	44 2b d9	 sub	 r11d, ecx
  00139	45 84 d2	 test	 r10b, r10b
  0013c	75 c6		 jne	 SHORT $dolen$98
$LN72@inflate_fa:

; 134  :             Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 135  :                     "inflate:         literal '%c'\n" :
; 136  :                     "inflate:         literal 0x%02x\n", here.val));
; 137  :             PUP(out) = (unsigned char)(here.val);

  0013e	49 ff c0	 inc	 r8
  00141	41 c1 ea 10	 shr	 r10d, 16
  00145	45 88 10	 mov	 BYTE PTR [r8], r10b
  00148	e9 b8 02 00 00	 jmp	 $LN54@inflate_fa
$LN73@inflate_fa:

; 140  :             len = (unsigned)(here.val);

  0014d	41 c1 ea 10	 shr	 r10d, 16

; 141  :             op &= 15;                           /* number of extra bits */

  00151	83 e2 0f	 and	 edx, 15

; 142  :             if (op) {

  00154	74 29		 je	 SHORT $LN48@inflate_fa

; 143  :                 if (bits < op) {

  00156	44 3b da	 cmp	 r11d, edx
  00159	73 12		 jae	 SHORT $LN47@inflate_fa

; 144  :                     hold += (unsigned long)(PUP(in)) << bits;

  0015b	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  0015f	48 ff c6	 inc	 rsi
  00162	41 8b cb	 mov	 ecx, r11d
  00165	d3 e0		 shl	 eax, cl
  00167	03 d8		 add	 ebx, eax

; 145  :                     bits += 8;

  00169	41 83 c3 08	 add	 r11d, 8
$LN47@inflate_fa:

; 146  :                 }
; 147  :                 len += (unsigned)hold & ((1U << op) - 1);

  0016d	8b ca		 mov	 ecx, edx
  0016f	8b c5		 mov	 eax, ebp
  00171	d3 e0		 shl	 eax, cl
  00173	ff c8		 dec	 eax
  00175	23 c3		 and	 eax, ebx

; 148  :                 hold >>= op;

  00177	d3 eb		 shr	 ebx, cl
  00179	44 03 d0	 add	 r10d, eax

; 149  :                 bits -= op;

  0017c	44 2b da	 sub	 r11d, edx
$LN48@inflate_fa:

; 150  :             }
; 151  :             Tracevv((stderr, "inflate:         length %u\n", len));
; 152  :             if (bits < 15) {

  0017f	41 83 fb 0f	 cmp	 r11d, 15
  00183	73 1e		 jae	 SHORT $LN46@inflate_fa

; 153  :                 hold += (unsigned long)(PUP(in)) << bits;

  00185	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  00189	41 8b cb	 mov	 ecx, r11d

; 154  :                 bits += 8;
; 155  :                 hold += (unsigned long)(PUP(in)) << bits;

  0018c	48 83 c6 02	 add	 rsi, 2
  00190	d3 e0		 shl	 eax, cl
  00192	41 8d 4b 08	 lea	 ecx, DWORD PTR [r11+8]
  00196	03 d8		 add	 ebx, eax
  00198	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0019b	d3 e0		 shl	 eax, cl
  0019d	03 d8		 add	 ebx, eax

; 156  :                 bits += 8;

  0019f	41 83 c3 10	 add	 r11d, 16
$LN46@inflate_fa:

; 157  :             }
; 158  :             here = dcode[hold & dmask];

  001a3	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR dmask$1$[rsp]
  001aa	8b c3		 mov	 eax, ebx
  001ac	48 23 c8	 and	 rcx, rax
  001af	8b 3c 8f	 mov	 edi, DWORD PTR [rdi+rcx*4]

; 159  :           dodist:
; 160  :             op = (unsigned)(here.bits);

  001b2	8b c7		 mov	 eax, edi

; 161  :             hold >>= op;
; 162  :             bits -= op;
; 163  :             op = (unsigned)(here.op);

  001b4	40 0f b6 d7	 movzx	 edx, dil
  001b8	c1 e8 08	 shr	 eax, 8
  001bb	0f b6 c8	 movzx	 ecx, al
  001be	d3 eb		 shr	 ebx, cl
  001c0	44 2b d9	 sub	 r11d, ecx

; 164  :             if (op & 16) {                      /* distance base */

  001c3	f6 c2 10	 test	 dl, 16
  001c6	75 3d		 jne	 SHORT $LN74@inflate_fa
  001c8	0f 1f 84 00 00
	00 00 00	 npad	 8
$dodist$99:

; 280  :                     }
; 281  :                 }
; 282  :             }
; 283  :             else if ((op & 64) == 0) {          /* 2nd level distance code */

  001d0	f6 c2 40	 test	 dl, 64			; 00000040H
  001d3	0f 85 6c 02 00
	00		 jne	 $LN8@inflate_fa

; 284  :                 here = dcode[here.val + (hold & ((1U << op) - 1))];

  001d9	8b ca		 mov	 ecx, edx
  001db	c1 ef 10	 shr	 edi, 16
  001de	8b c5		 mov	 eax, ebp
  001e0	d3 e0		 shl	 eax, cl
  001e2	48 8b 0c 24	 mov	 rcx, QWORD PTR dcode$1$[rsp]
  001e6	ff c8		 dec	 eax
  001e8	23 c3		 and	 eax, ebx
  001ea	03 c7		 add	 eax, edi
  001ec	8b 3c 81	 mov	 edi, DWORD PTR [rcx+rax*4]
  001ef	8b c7		 mov	 eax, edi
  001f1	40 0f b6 d7	 movzx	 edx, dil
  001f5	c1 e8 08	 shr	 eax, 8
  001f8	0f b6 c8	 movzx	 ecx, al
  001fb	d3 eb		 shr	 ebx, cl
  001fd	44 2b d9	 sub	 r11d, ecx
  00200	f6 c2 10	 test	 dl, 16
  00203	74 cb		 je	 SHORT $dodist$99
$LN74@inflate_fa:

; 165  :                 dist = (unsigned)(here.val);
; 166  :                 op &= 15;                       /* number of extra bits */

  00205	83 e2 0f	 and	 edx, 15
  00208	c1 ef 10	 shr	 edi, 16

; 167  :                 if (bits < op) {

  0020b	44 3b da	 cmp	 r11d, edx
  0020e	73 29		 jae	 SHORT $LN43@inflate_fa

; 168  :                     hold += (unsigned long)(PUP(in)) << bits;

  00210	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  00214	48 ff c6	 inc	 rsi
  00217	41 8b cb	 mov	 ecx, r11d
  0021a	d3 e0		 shl	 eax, cl

; 169  :                     bits += 8;

  0021c	41 83 c3 08	 add	 r11d, 8
  00220	03 d8		 add	 ebx, eax

; 170  :                     if (bits < op) {

  00222	44 3b da	 cmp	 r11d, edx
  00225	73 12		 jae	 SHORT $LN43@inflate_fa

; 171  :                         hold += (unsigned long)(PUP(in)) << bits;

  00227	0f b6 46 01	 movzx	 eax, BYTE PTR [rsi+1]
  0022b	48 ff c6	 inc	 rsi
  0022e	41 8b cb	 mov	 ecx, r11d
  00231	d3 e0		 shl	 eax, cl
  00233	03 d8		 add	 ebx, eax

; 172  :                         bits += 8;

  00235	41 83 c3 08	 add	 r11d, 8
$LN43@inflate_fa:

; 173  :                     }
; 174  :                 }
; 175  :                 dist += (unsigned)hold & ((1U << op) - 1);

  00239	8b ca		 mov	 ecx, edx
  0023b	8b c5		 mov	 eax, ebp

; 176  : #ifdef INFLATE_STRICT
; 177  :                 if (dist > dmax) {
; 178  :                     strm->msg = (char *)"invalid distance too far back";
; 179  :                     state->mode = BAD;
; 180  :                     break;
; 181  :                 }
; 182  : #endif
; 183  :                 hold >>= op;
; 184  :                 bits -= op;

  0023d	44 2b da	 sub	 r11d, edx
  00240	d3 e0		 shl	 eax, cl
  00242	ff c8		 dec	 eax
  00244	23 c3		 and	 eax, ebx
  00246	d3 eb		 shr	 ebx, cl
  00248	03 f8		 add	 edi, eax

; 185  :                 Tracevv((stderr, "inflate:         distance %u\n", dist));
; 186  :                 op = (unsigned)(out - beg);     /* max distance in output */

  0024a	41 8b c0	 mov	 eax, r8d
  0024d	2b 44 24 10	 sub	 eax, DWORD PTR beg$1$[rsp]

; 187  :                 if (dist > op) {                /* see if copy from window */

  00251	3b f8		 cmp	 edi, eax
  00253	0f 86 4d 01 00
	00		 jbe	 $LN42@inflate_fa

; 188  :                     op = dist - op;             /* distance back in window */

  00259	8b cf		 mov	 ecx, edi
  0025b	2b c8		 sub	 ecx, eax

; 189  :                     if (op > whave) {

  0025d	3b 8c 24 98 00
	00 00		 cmp	 ecx, DWORD PTR whave$1$[rsp]
  00264	76 0f		 jbe	 SHORT $LN40@inflate_fa

; 190  :                         if (state->sane) {

  00266	41 83 bc 24 d8
	1b 00 00 00	 cmp	 DWORD PTR [r12+7128], 0
  0026f	0f 85 ed 01 00
	00		 jne	 $LN75@inflate_fa
$LN40@inflate_fa:

; 194  :                             break;
; 195  :                         }
; 196  : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 197  :                         if (len <= op - whave) {
; 198  :                             do {
; 199  :                                 PUP(out) = 0;
; 200  :                             } while (--len);
; 201  :                             continue;
; 202  :                         }
; 203  :                         len -= op - whave;
; 204  :                         do {
; 205  :                             PUP(out) = 0;
; 206  :                         } while (--op > whave);
; 207  :                         if (op == 0) {
; 208  :                             from = out - dist;
; 209  :                             do {
; 210  :                                 PUP(out) = PUP(from);
; 211  :                             } while (--len);
; 212  :                             continue;
; 213  :                         }
; 214  : #endif
; 215  :                     }
; 216  :                     from = window - OFF;

  00275	48 8b 54 24 18	 mov	 rdx, QWORD PTR window$1$[rsp]
  0027a	4c 8d 4a ff	 lea	 r9, QWORD PTR [rdx-1]

; 217  :                     if (wnext == 0) {           /* very common case */

  0027e	45 85 f6	 test	 r14d, r14d
  00281	75 32		 jne	 SHORT $LN39@inflate_fa

; 218  :                         from += wsize - op;

  00283	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR wsize$1$[rsp]
  0028a	2b c1		 sub	 eax, ecx
  0028c	4c 03 c8	 add	 r9, rax

; 219  :                         if (op < len) {         /* some from window */

  0028f	41 3b ca	 cmp	 ecx, r10d
  00292	0f 83 a3 00 00
	00		 jae	 $LN69@inflate_fa

; 220  :                             len -= op;

  00298	44 2b d1	 sub	 r10d, ecx
  0029b	0f 1f 44 00 00	 npad	 5
$LL37@inflate_fa:

; 221  :                             do {
; 222  :                                 PUP(out) = PUP(from);

  002a0	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  002a5	49 ff c0	 inc	 r8
  002a8	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  002ac	41 88 00	 mov	 BYTE PTR [r8], al

; 223  :                             } while (--op);

  002af	ff c9		 dec	 ecx
  002b1	75 ed		 jne	 SHORT $LL37@inflate_fa

; 224  :                             from = out - dist;  /* rest from output */
; 225  :                         }

  002b3	eb 7e		 jmp	 SHORT $LN94@inflate_fa
$LN39@inflate_fa:

; 226  :                     }
; 227  :                     else if (wnext < op) {      /* wrap around window */
; 228  :                         from += wsize + wnext - op;

  002b5	41 8b c6	 mov	 eax, r14d
  002b8	2b c1		 sub	 eax, ecx
  002ba	44 3b f1	 cmp	 r14d, ecx
  002bd	73 56		 jae	 SHORT $LN33@inflate_fa
  002bf	03 84 24 88 00
	00 00		 add	 eax, DWORD PTR wsize$1$[rsp]

; 229  :                         op -= wnext;

  002c6	41 2b ce	 sub	 ecx, r14d
  002c9	4c 03 c8	 add	 r9, rax

; 230  :                         if (op < len) {         /* some from end of window */

  002cc	41 3b ca	 cmp	 ecx, r10d
  002cf	73 6a		 jae	 SHORT $LN69@inflate_fa

; 231  :                             len -= op;

  002d1	44 2b d1	 sub	 r10d, ecx

; 234  :                             } while (--op);

  002d4	4d 2b c8	 sub	 r9, r8
  002d7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL31@inflate_fa:

; 232  :                             do {
; 233  :                                 PUP(out) = PUP(from);

  002e0	43 0f b6 44 01
	01		 movzx	 eax, BYTE PTR [r9+r8+1]
  002e6	49 ff c0	 inc	 r8
  002e9	41 88 00	 mov	 BYTE PTR [r8], al

; 234  :                             } while (--op);

  002ec	ff c9		 dec	 ecx
  002ee	75 f0		 jne	 SHORT $LL31@inflate_fa

; 235  :                             from = window - OFF;

  002f0	4c 8d 4a ff	 lea	 r9, QWORD PTR [rdx-1]

; 236  :                             if (wnext < len) {  /* some from start of window */

  002f4	45 3b f2	 cmp	 r14d, r10d
  002f7	73 42		 jae	 SHORT $LN69@inflate_fa

; 237  :                                 op = wnext;

  002f9	41 8b ce	 mov	 ecx, r14d

; 238  :                                 len -= op;

  002fc	45 2b d6	 sub	 r10d, r14d
  002ff	90		 npad	 1
$LL27@inflate_fa:

; 239  :                                 do {
; 240  :                                     PUP(out) = PUP(from);

  00300	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  00305	49 ff c0	 inc	 r8
  00308	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  0030c	41 88 00	 mov	 BYTE PTR [r8], al

; 241  :                                 } while (--op);

  0030f	ff c9		 dec	 ecx
  00311	75 ed		 jne	 SHORT $LL27@inflate_fa

; 242  :                                 from = out - dist;      /* rest from output */
; 243  :                             }
; 244  :                         }
; 245  :                     }
; 246  :                     else {                      /* contiguous in window */

  00313	eb 1e		 jmp	 SHORT $LN94@inflate_fa
$LN33@inflate_fa:

; 247  :                         from += wnext - op;

  00315	4c 03 c8	 add	 r9, rax

; 248  :                         if (op < len) {         /* some from window */

  00318	41 3b ca	 cmp	 ecx, r10d
  0031b	73 1e		 jae	 SHORT $LN69@inflate_fa

; 249  :                             len -= op;

  0031d	44 2b d1	 sub	 r10d, ecx
$LL22@inflate_fa:

; 250  :                             do {
; 251  :                                 PUP(out) = PUP(from);

  00320	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]
  00325	49 ff c0	 inc	 r8
  00328	4d 8d 49 01	 lea	 r9, QWORD PTR [r9+1]
  0032c	41 88 00	 mov	 BYTE PTR [r8], al

; 252  :                             } while (--op);

  0032f	ff c9		 dec	 ecx
  00331	75 ed		 jne	 SHORT $LL22@inflate_fa
$LN94@inflate_fa:

; 253  :                             from = out - dist;  /* rest from output */

  00333	8b c7		 mov	 eax, edi
  00335	4d 8b c8	 mov	 r9, r8
  00338	4c 2b c8	 sub	 r9, rax
$LN69@inflate_fa:

; 254  :                         }
; 255  :                     }
; 256  :                     while (len > 2) {

  0033b	41 83 fa 02	 cmp	 r10d, 2
  0033f	76 3a		 jbe	 SHORT $LN18@inflate_fa
  00341	41 8d 4a fd	 lea	 ecx, DWORD PTR [r10-3]
  00345	b8 ab aa aa aa	 mov	 eax, -1431655765	; aaaaaaabH
  0034a	f7 e1		 mul	 ecx
  0034c	d1 ea		 shr	 edx, 1
  0034e	8d 4a 01	 lea	 ecx, DWORD PTR [rdx+1]
$LL19@inflate_fa:

; 257  :                         PUP(out) = PUP(from);

  00351	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]

; 258  :                         PUP(out) = PUP(from);
; 259  :                         PUP(out) = PUP(from);

  00356	49 83 c1 03	 add	 r9, 3
  0035a	49 83 c0 03	 add	 r8, 3
  0035e	41 88 40 fe	 mov	 BYTE PTR [r8-2], al
  00362	41 0f b6 41 ff	 movzx	 eax, BYTE PTR [r9-1]

; 260  :                         len -= 3;

  00367	41 83 c2 fd	 add	 r10d, -3		; fffffffdH
  0036b	41 88 40 ff	 mov	 BYTE PTR [r8-1], al
  0036f	41 0f b6 01	 movzx	 eax, BYTE PTR [r9]
  00373	41 88 00	 mov	 BYTE PTR [r8], al
  00376	48 ff c9	 dec	 rcx
  00379	75 d6		 jne	 SHORT $LL19@inflate_fa
$LN18@inflate_fa:

; 261  :                     }
; 262  :                     if (len) {

  0037b	45 85 d2	 test	 r10d, r10d
  0037e	74 7c		 je	 SHORT $LN88@inflate_fa

; 263  :                         PUP(out) = PUP(from);

  00380	41 0f b6 41 01	 movzx	 eax, BYTE PTR [r9+1]

; 266  :                     }
; 267  :                 }
; 268  :                 else {

  00385	48 8b 3c 24	 mov	 rdi, QWORD PTR dcode$1$[rsp]
  00389	49 ff c0	 inc	 r8
  0038c	41 88 00	 mov	 BYTE PTR [r8], al
  0038f	44 3b d5	 cmp	 r10d, ebp
  00392	76 0b		 jbe	 SHORT $LN89@inflate_fa

; 264  :                         if (len > 1)
; 265  :                             PUP(out) = PUP(from);

  00394	41 0f b6 41 02	 movzx	 eax, BYTE PTR [r9+2]
  00399	49 ff c0	 inc	 r8
  0039c	41 88 00	 mov	 BYTE PTR [r8], al
$LN89@inflate_fa:

; 266  :                     }
; 267  :                 }
; 268  :                 else {

  0039f	4c 8b 4c 24 08	 mov	 r9, QWORD PTR lcode$1$[rsp]
  003a4	eb 5f		 jmp	 SHORT $LN54@inflate_fa
$LN42@inflate_fa:

; 269  :                     from = out - dist;          /* copy direct from output */

  003a6	8b c7		 mov	 eax, edi
  003a8	49 8b c8	 mov	 rcx, r8
  003ab	48 2b c8	 sub	 rcx, rax
  003ae	66 90		 npad	 2
$LL14@inflate_fa:

; 270  :                     do {                        /* minimum length is three */
; 271  :                         PUP(out) = PUP(from);

  003b0	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 272  :                         PUP(out) = PUP(from);
; 273  :                         PUP(out) = PUP(from);

  003b4	49 83 c0 03	 add	 r8, 3
  003b8	48 8d 49 03	 lea	 rcx, QWORD PTR [rcx+3]
  003bc	41 88 40 fe	 mov	 BYTE PTR [r8-2], al
  003c0	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]

; 274  :                         len -= 3;

  003c4	41 83 c2 fd	 add	 r10d, -3		; fffffffdH
  003c8	41 88 40 ff	 mov	 BYTE PTR [r8-1], al
  003cc	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
  003cf	41 88 00	 mov	 BYTE PTR [r8], al

; 275  :                     } while (len > 2);

  003d2	41 83 fa 02	 cmp	 r10d, 2
  003d6	77 d8		 ja	 SHORT $LL14@inflate_fa

; 276  :                     if (len) {

  003d8	45 85 d2	 test	 r10d, r10d
  003db	74 24		 je	 SHORT $LN91@inflate_fa

; 277  :                         PUP(out) = PUP(from);

  003dd	0f b6 41 01	 movzx	 eax, BYTE PTR [rcx+1]

; 278  :                         if (len > 1)
; 279  :                             PUP(out) = PUP(from);

  003e1	48 8b 3c 24	 mov	 rdi, QWORD PTR dcode$1$[rsp]
  003e5	49 ff c0	 inc	 r8
  003e8	41 88 00	 mov	 BYTE PTR [r8], al
  003eb	44 3b d5	 cmp	 r10d, ebp
  003ee	76 15		 jbe	 SHORT $LN54@inflate_fa
  003f0	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  003f4	49 ff c0	 inc	 r8
  003f7	41 88 00	 mov	 BYTE PTR [r8], al
  003fa	eb 09		 jmp	 SHORT $LN54@inflate_fa
$LN88@inflate_fa:
  003fc	4c 8b 4c 24 08	 mov	 r9, QWORD PTR lcode$1$[rsp]
$LN91@inflate_fa:
  00401	48 8b 3c 24	 mov	 rdi, QWORD PTR dcode$1$[rsp]
$LN54@inflate_fa:

; 305  :             break;
; 306  :         }
; 307  :     } while (in < last && out < end);

  00405	49 3b f5	 cmp	 rsi, r13
  00408	73 61		 jae	 SHORT $LN93@inflate_fa
  0040a	4d 3b c7	 cmp	 r8, r15
  0040d	73 5c		 jae	 SHORT $LN93@inflate_fa
  0040f	48 8b 54 24 20	 mov	 rdx, QWORD PTR tv445[rsp]
  00414	e9 a7 fc ff ff	 jmp	 $LL55@inflate_fa
$LN5@inflate_fa:

; 295  :             goto dolen;
; 296  :         }
; 297  :         else if (op & 32) {                     /* end-of-block */

  00419	f6 c2 20	 test	 dl, 32			; 00000020H

; 300  :             break;

  0041c	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  00424	74 0a		 je	 SHORT $LN3@inflate_fa

; 298  :             Tracevv((stderr, "inflate:         end of block\n"));
; 299  :             state->mode = TYPE;

  00426	41 c7 04 24 0b
	00 00 00	 mov	 DWORD PTR [r12], 11

; 300  :             break;

  0042e	eb 43		 jmp	 SHORT $LN53@inflate_fa
$LN3@inflate_fa:

; 301  :         }
; 302  :         else {
; 303  :             strm->msg = (char *)"invalid literal/length code";

  00430	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  00437	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax

; 304  :             state->mode = BAD;

  0043b	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29
  00443	eb 2e		 jmp	 SHORT $LN53@inflate_fa
$LN8@inflate_fa:

; 285  :                 goto dodist;
; 286  :             }
; 287  :             else {
; 288  :                 strm->msg = (char *)"invalid distance code";

  00445	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
$LN95@inflate_fa:
  0044c	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  00454	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax

; 289  :                 state->mode = BAD;

  00458	41 c7 04 24 1d
	00 00 00	 mov	 DWORD PTR [r12], 29

; 290  :                 break;

  00460	eb 11		 jmp	 SHORT $LN53@inflate_fa
$LN75@inflate_fa:

; 191  :                             strm->msg =
; 192  :                                 (char *)"invalid distance too far back";

  00462	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 193  :                             state->mode = BAD;

  00469	eb e1		 jmp	 SHORT $LN95@inflate_fa
$LN93@inflate_fa:
  0046b	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
$LN53@inflate_fa:

; 308  : 
; 309  :     /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
; 310  :     len = bits >> 3;

  00473	41 8b cb	 mov	 ecx, r11d
  00476	c1 e9 03	 shr	 ecx, 3

; 311  :     in -= len;

  00479	8b c1		 mov	 eax, ecx
  0047b	48 2b f0	 sub	 rsi, rax

; 312  :     bits -= len << 3;

  0047e	8d 04 cd 00 00
	00 00		 lea	 eax, DWORD PTR [rcx*8]
  00485	44 2b d8	 sub	 r11d, eax

; 313  :     hold &= (1U << bits) - 1;
; 314  : 
; 315  :     /* update state and return */
; 316  :     strm->next_in = in + OFF;

  00488	48 8d 46 01	 lea	 rax, QWORD PTR [rsi+1]

; 317  :     strm->next_out = out + OFF;
; 318  :     strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));

  0048c	4c 2b ee	 sub	 r13, rsi
  0048f	48 89 02	 mov	 QWORD PTR [rdx], rax
  00492	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]
  00496	41 8b cb	 mov	 ecx, r11d
  00499	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax
  0049d	d3 e5		 shl	 ebp, cl
  0049f	49 8d 45 05	 lea	 rax, QWORD PTR [r13+5]
  004a3	89 42 08	 mov	 DWORD PTR [rdx+8], eax
  004a6	ff cd		 dec	 ebp
  004a8	23 dd		 and	 ebx, ebp

; 319  :     strm->avail_out = (unsigned)(out < end ?
; 320  :                                  257 + (end - out) : 257 - (out - end));

  004aa	4d 2b f8	 sub	 r15, r8
  004ad	49 8d 87 01 01
	00 00		 lea	 rax, QWORD PTR [r15+257]
  004b4	89 42 18	 mov	 DWORD PTR [rdx+24], eax

; 321  :     state->hold = hold;

  004b7	41 89 5c 24 40	 mov	 DWORD PTR [r12+64], ebx

; 322  :     state->bits = bits;

  004bc	45 89 5c 24 44	 mov	 DWORD PTR [r12+68], r11d

; 323  :     return;
; 324  : }

  004c1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  004c5	41 5f		 pop	 r15
  004c7	41 5e		 pop	 r14
  004c9	41 5d		 pop	 r13
  004cb	41 5c		 pop	 r12
  004cd	5f		 pop	 rdi
  004ce	5e		 pop	 rsi
  004cf	5d		 pop	 rbp
  004d0	5b		 pop	 rbx
  004d1	c3		 ret	 0
inflate_fast ENDP
_TEXT	ENDS
END
