; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	gzread
PUBLIC	gzgets
PUBLIC	gzgetc
PUBLIC	gzungetc
PUBLIC	gzdirect
PUBLIC	gzclose_r
PUBLIC	??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@		; `string'
PUBLIC	??_C@_05DFCKICEH@1?42?45?$AA@			; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ ; `string'
PUBLIC	??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ ; `string'
PUBLIC	??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
PUBLIC	??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ ; `string'
PUBLIC	??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ ; `string'
EXTRN	__imp_memchr:PROC
EXTRN	__imp_strerror:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	inflate:PROC
EXTRN	inflateEnd:PROC
EXTRN	inflateReset:PROC
EXTRN	crc32:PROC
EXTRN	inflateInit2_:PROC
EXTRN	__imp_close:PROC
EXTRN	__imp_read:PROC
EXTRN	gz_error:PROC
EXTRN	memcpy:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzread DD imagerel $LN40
	DD	imagerel $LN40+84
	DD	imagerel $unwind$gzread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gzread DD imagerel $LN40+84
	DD	imagerel $LN40+131
	DD	imagerel $chain$0$gzread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$gzread DD imagerel $LN40+131
	DD	imagerel $LN40+394
	DD	imagerel $chain$5$gzread
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgets DD imagerel $LN30
	DD	imagerel $LN30+99
	DD	imagerel $unwind$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gzgets DD imagerel $LN30+99
	DD	imagerel $LN30+276
	DD	imagerel $chain$3$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$gzgets DD imagerel $LN30+276
	DD	imagerel $LN30+285
	DD	imagerel $chain$5$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$gzgets DD imagerel $LN30+285
	DD	imagerel $LN30+297
	DD	imagerel $chain$6$gzgets
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgetc DD imagerel $LN10
	DD	imagerel $LN10+101
	DD	imagerel $unwind$gzgetc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzungetc DD imagerel $LN18
	DD	imagerel $LN18+244
	DD	imagerel $unwind$gzungetc
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzdirect DD imagerel $LN8
	DD	imagerel $LN8+56
	DD	imagerel $unwind$gzdirect
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzclose_r DD imagerel $LN8
	DD	imagerel $LN8+131
	DD	imagerel $unwind$gzclose_r
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_load DD imagerel gz_load
	DD	imagerel gz_load+149
	DD	imagerel $unwind$gz_load
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_avail DD imagerel gz_avail
	DD	imagerel gz_avail+68
	DD	imagerel $unwind$gz_avail
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_next4 DD imagerel gz_next4
	DD	imagerel gz_next4+285
	DD	imagerel $unwind$gz_next4
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_head DD imagerel gz_head
	DD	imagerel gz_head+421
	DD	imagerel $unwind$gz_head
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$gz_head DD imagerel gz_head+421
	DD	imagerel gz_head+512
	DD	imagerel $chain$0$gz_head
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$gz_head DD imagerel gz_head+512
	DD	imagerel gz_head+531
	DD	imagerel $chain$1$gz_head
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$gz_head DD imagerel gz_head+531
	DD	imagerel gz_head+1152
	DD	imagerel $chain$2$gz_head
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$gz_head DD imagerel gz_head+1152
	DD	imagerel gz_head+1264
	DD	imagerel $chain$3$gz_head
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_decomp DD imagerel gz_decomp
	DD	imagerel gz_decomp+368
	DD	imagerel $unwind$gz_decomp
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_make DD imagerel gz_make
	DD	imagerel gz_make+140
	DD	imagerel $unwind$gz_make
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_skip DD imagerel gz_skip
	DD	imagerel gz_skip+115
	DD	imagerel $unwind$gz_skip
pdata	ENDS
;	COMDAT ??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
CONST	SEGMENT
??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@ DB 'out of ro'
	DB	'om to push characters', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
CONST	SEGMENT
??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@ DB 'requested l'
	DB	'ength does not fit in int', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
CONST	SEGMENT
??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@ DB 'compressed data error'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
CONST	SEGMENT
??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@ DB 'internal er'
	DB	'ror: inflate stream corrupt', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
CONST	SEGMENT
??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@ DB 'unexpected end of f'
	DB	'ile', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05DFCKICEH@1?42?45?$AA@
CONST	SEGMENT
??_C@_05DFCKICEH@1?42?45?$AA@ DB '1.2.5', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
CONST	SEGMENT
??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@ DB 'out of memory', 00H ; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_skip DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_make DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_decomp DD 061601H
	DD	0a3416H
	DD	070043208H
	DD	050026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gz_head DD 021H
	DD	imagerel gz_head
	DD	imagerel gz_head+421
	DD	imagerel $unwind$gz_head
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$gz_head DD 020021H
	DD	08e400H
	DD	imagerel gz_head
	DD	imagerel gz_head+421
	DD	imagerel $unwind$gz_head
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$gz_head DD 021H
	DD	imagerel gz_head
	DD	imagerel gz_head+421
	DD	imagerel $unwind$gz_head
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gz_head DD 020521H
	DD	08e405H
	DD	imagerel gz_head
	DD	imagerel gz_head+421
	DD	imagerel $unwind$gz_head
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_head DD 081201H
	DD	0a5412H
	DD	093412H
	DD	0f00e3212H
	DD	0600b700cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_next4 DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_avail DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_load DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclose_r DD 042a01H
	DD	06342aH
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzdirect DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzungetc DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgetc DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$gzgets DD 021H
	DD	imagerel $LN30
	DD	imagerel $LN30+99
	DD	imagerel $unwind$gzgets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$gzgets DD 080021H
	DD	0bc400H
	DD	0a7400H
	DD	095400H
	DD	083400H
	DD	imagerel $LN30
	DD	imagerel $LN30+99
	DD	imagerel $unwind$gzgets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$gzgets DD 081421H
	DD	0bc414H
	DD	0a740fH
	DD	09540aH
	DD	083405H
	DD	imagerel $LN30
	DD	imagerel $LN30+99
	DD	imagerel $unwind$gzgets
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgets DD 040a01H
	DD	0f006320aH
	DD	06002e004H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$gzread DD 081221H
	DD	0c7412H
	DD	04f40aH
	DD	0b6405H
	DD	05c400H
	DD	imagerel $LN40
	DD	imagerel $LN40+84
	DD	imagerel $unwind$gzread
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$gzread DD 020521H
	DD	05c405H
	DD	imagerel $LN40
	DD	imagerel $LN40+84
	DD	imagerel $unwind$gzread
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzread DD 040901H
	DD	0e0055209H
	DD	030025003H
xdata	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzread.c
;	COMDAT gz_skip
_TEXT	SEGMENT
state$ = 48
len$ = 56
gz_skip	PROC						; COMDAT

; 333  : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b fa		 mov	 edi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 334  :     unsigned n;
; 335  : 
; 336  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 337  :     while (len)

  0000f	85 d2		 test	 edx, edx
  00011	74 45		 je	 SHORT $LN6@gz_skip
$LL7@gz_skip:

; 338  :         /* skip over whatever is in output buffer */
; 339  :         if (state->have) {

  00013	8b 43 38	 mov	 eax, DWORD PTR [rbx+56]
  00016	85 c0		 test	 eax, eax
  00018	74 21		 je	 SHORT $LN5@gz_skip

; 340  :             n = GT_OFF(state->have) || (z_off64_t)state->have > len ?
; 341  :                 (unsigned)len : state->have;

  0001a	3d ff ff ff 7f	 cmp	 eax, 2147483647		; 7fffffffH
  0001f	77 06		 ja	 SHORT $LN11@gz_skip
  00021	8b c8		 mov	 ecx, eax
  00023	3b c7		 cmp	 eax, edi
  00025	7e 02		 jle	 SHORT $LN12@gz_skip
$LN11@gz_skip:
  00027	8b cf		 mov	 ecx, edi
$LN12@gz_skip:

; 342  :             state->have -= n;
; 343  :             state->next += n;
; 344  :             state->pos += n;

  00029	01 4b 10	 add	 DWORD PTR [rbx+16], ecx
  0002c	2b c1		 sub	 eax, ecx
  0002e	89 43 38	 mov	 DWORD PTR [rbx+56], eax
  00031	8b c1		 mov	 eax, ecx
  00033	48 01 43 30	 add	 QWORD PTR [rbx+48], rax

; 345  :             len -= n;

  00037	2b f9		 sub	 edi, ecx
  00039	eb 19		 jmp	 SHORT $LN1@gz_skip
$LN5@gz_skip:

; 346  :         }
; 347  : 
; 348  :         /* output buffer empty -- return if we're at the end of the input */
; 349  :         else if (state->eof && state->strm.avail_in == 0)

  0003b	83 7b 3c 00	 cmp	 DWORD PTR [rbx+60], 0
  0003f	74 06		 je	 SHORT $LN3@gz_skip
  00041	83 7b 78 00	 cmp	 DWORD PTR [rbx+120], 0
  00045	74 11		 je	 SHORT $LN6@gz_skip
$LN3@gz_skip:

; 350  :             break;
; 351  : 
; 352  :         /* need more data to skip -- load up output buffer */
; 353  :         else {
; 354  :             /* get more output, looking for header if required */
; 355  :             if (gz_make(state) == -1)

  00047	48 8b cb	 mov	 rcx, rbx
  0004a	e8 00 00 00 00	 call	 gz_make
  0004f	83 f8 ff	 cmp	 eax, -1
  00052	74 11		 je	 SHORT $LN15@gz_skip
$LN1@gz_skip:

; 334  :     unsigned n;
; 335  : 
; 336  :     /* skip over len bytes or reach end-of-file, whichever comes first */
; 337  :     while (len)

  00054	85 ff		 test	 edi, edi
  00056	75 bb		 jne	 SHORT $LL7@gz_skip
$LN6@gz_skip:

; 357  :         }
; 358  :     return 0;

  00058	33 c0		 xor	 eax, eax

; 359  : }

  0005a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0005f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00063	5f		 pop	 rdi
  00064	c3		 ret	 0
$LN15@gz_skip:

; 356  :                 return -1;

  00065	83 c8 ff	 or	 eax, -1

; 359  : }

  00068	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0006d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00071	5f		 pop	 rdi
  00072	c3		 ret	 0
gz_skip	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzread.c
;	COMDAT gz_make
_TEXT	SEGMENT
state$ = 48
gz_make	PROC						; COMDAT

; 306  : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 307  :     z_streamp strm = &(state->strm);
; 308  : 
; 309  :     if (state->how == LOOK) {           /* look for gzip header */

  00006	83 79 48 00	 cmp	 DWORD PTR [rcx+72], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	75 19		 jne	 SHORT $LN6@gz_make

; 310  :         if (gz_head(state) == -1)

  0000f	e8 00 00 00 00	 call	 gz_head
  00014	83 f8 ff	 cmp	 eax, -1
  00017	75 09		 jne	 SHORT $LN7@gz_make
$LN11@gz_make:

; 311  :             return -1;

  00019	83 c8 ff	 or	 eax, -1

; 327  : }

  0001c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00020	5b		 pop	 rbx
  00021	c3		 ret	 0
$LN7@gz_make:

; 312  :         if (state->have)                /* got some data from gz_head() */

  00022	83 7b 38 00	 cmp	 DWORD PTR [rbx+56], 0
  00026	75 5c		 jne	 SHORT $LN1@gz_make
$LN6@gz_make:

; 313  :             return 0;
; 314  :     }
; 315  :     if (state->how == COPY) {           /* straight copy */

  00028	8b 43 48	 mov	 eax, DWORD PTR [rbx+72]
  0002b	83 f8 01	 cmp	 eax, 1
  0002e	75 2c		 jne	 SHORT $LN5@gz_make

; 316  :         if (gz_load(state, state->out, state->size << 1, &(state->have)) == -1)

  00030	44 8b 43 14	 mov	 r8d, DWORD PTR [rbx+20]
  00034	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
  00038	4c 8d 4b 38	 lea	 r9, QWORD PTR [rbx+56]
  0003c	45 03 c0	 add	 r8d, r8d
  0003f	48 8b cb	 mov	 rcx, rbx
  00042	e8 00 00 00 00	 call	 gz_load
  00047	83 f8 ff	 cmp	 eax, -1
  0004a	74 cd		 je	 SHORT $LN11@gz_make

; 317  :             return -1;
; 318  :         state->next = state->out;

  0004c	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00050	48 89 43 30	 mov	 QWORD PTR [rbx+48], rax

; 324  :             return -1;
; 325  :     }
; 326  :     return 0;

  00054	33 c0		 xor	 eax, eax

; 327  : }

  00056	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005a	5b		 pop	 rbx
  0005b	c3		 ret	 0
$LN5@gz_make:

; 319  :     }
; 320  :     else if (state->how == GZIP) {      /* decompress */

  0005c	83 f8 02	 cmp	 eax, 2
  0005f	75 23		 jne	 SHORT $LN1@gz_make

; 321  :         strm->avail_out = state->size << 1;

  00061	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]

; 322  :         strm->next_out = state->out;
; 323  :         if (gz_decomp(state) == -1)

  00064	48 8b cb	 mov	 rcx, rbx
  00067	03 c0		 add	 eax, eax
  00069	89 83 88 00 00
	00		 mov	 DWORD PTR [rbx+136], eax
  0006f	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  00073	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax
  0007a	e8 00 00 00 00	 call	 gz_decomp
  0007f	83 f8 ff	 cmp	 eax, -1
  00082	74 95		 je	 SHORT $LN11@gz_make
$LN1@gz_make:

; 324  :             return -1;
; 325  :     }
; 326  :     return 0;

  00084	33 c0		 xor	 eax, eax

; 327  : }

  00086	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008a	5b		 pop	 rbx
  0008b	c3		 ret	 0
gz_make	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzread.c
;	COMDAT gz_decomp
_TEXT	SEGMENT
crc$ = 64
state$ = 64
len$ = 72
gz_decomp PROC						; COMDAT

; 235  : {

  00000	40 55		 push	 rbp
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 236  :     int ret;
; 237  :     unsigned had;
; 238  :     unsigned long crc, len;
; 239  :     z_streamp strm = &(state->strm);
; 240  : 
; 241  :     /* fill output buffer up to end of deflate stream */
; 242  :     had = strm->avail_out;

  00008	8b a9 88 00 00
	00		 mov	 ebp, DWORD PTR [rcx+136]
  0000e	48 8b f1	 mov	 rsi, rcx
  00011	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
$LL15@gz_decomp:

; 243  :     do {
; 244  :         /* get more input for inflate() */
; 245  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  00016	83 7e 78 00	 cmp	 DWORD PTR [rsi+120], 0
  0001a	75 1b		 jne	 SHORT $LN27@gz_decomp
  0001c	48 8b ce	 mov	 rcx, rsi
  0001f	e8 00 00 00 00	 call	 gz_avail
  00024	83 f8 ff	 cmp	 eax, -1
  00027	0f 84 33 01 00
	00		 je	 $LN21@gz_decomp

; 246  :             return -1;
; 247  :         if (strm->avail_in == 0) {

  0002d	83 7e 78 00	 cmp	 DWORD PTR [rsi+120], 0
  00031	0f 84 ad 00 00
	00		 je	 $LN22@gz_decomp
$LN27@gz_decomp:

; 250  :         }
; 251  : 
; 252  :         /* decompress and handle errors */
; 253  :         ret = inflate(strm, Z_NO_FLUSH);

  00037	48 8d 4e 70	 lea	 rcx, QWORD PTR [rsi+112]
  0003b	33 d2		 xor	 edx, edx
  0003d	e8 00 00 00 00	 call	 inflate
  00042	8b d8		 mov	 ebx, eax

; 254  :         if (ret == Z_STREAM_ERROR || ret == Z_NEED_DICT) {

  00044	83 f8 fe	 cmp	 eax, -2
  00047	0f 84 ff 00 00
	00		 je	 $LN9@gz_decomp
  0004d	83 f8 02	 cmp	 eax, 2
  00050	0f 84 f6 00 00
	00		 je	 $LN9@gz_decomp

; 258  :         }
; 259  :         if (ret == Z_MEM_ERROR) {

  00056	83 f8 fc	 cmp	 eax, -4
  00059	0f 84 df 00 00
	00		 je	 $LN24@gz_decomp

; 262  :         }
; 263  :         if (ret == Z_DATA_ERROR) {              /* deflate stream invalid */

  0005f	83 f8 fd	 cmp	 eax, -3
  00062	0f 84 ba 00 00
	00		 je	 $LN25@gz_decomp

; 267  :         }
; 268  :     } while (strm->avail_out && ret != Z_STREAM_END);

  00068	83 be 88 00 00
	00 00		 cmp	 DWORD PTR [rsi+136], 0
  0006f	74 05		 je	 SHORT $LN6@gz_decomp
  00071	83 f8 01	 cmp	 eax, 1
  00074	75 a0		 jne	 SHORT $LL15@gz_decomp
$LN6@gz_decomp:

; 269  : 
; 270  :     /* update available output and crc check value */
; 271  :     state->have = had - strm->avail_out;

  00076	2b ae 88 00 00
	00		 sub	 ebp, DWORD PTR [rsi+136]
  0007c	8b c5		 mov	 eax, ebp

; 272  :     state->next = strm->next_out - state->have;
; 273  :     strm->adler = crc32(strm->adler, state->next, state->have);

  0007e	44 8b c5	 mov	 r8d, ebp
  00081	89 46 38	 mov	 DWORD PTR [rsi+56], eax
  00084	48 8b 96 80 00
	00 00		 mov	 rdx, QWORD PTR [rsi+128]
  0008b	48 2b d0	 sub	 rdx, rax
  0008e	48 89 56 30	 mov	 QWORD PTR [rsi+48], rdx
  00092	8b 8e bc 00 00
	00		 mov	 ecx, DWORD PTR [rsi+188]
  00098	e8 00 00 00 00	 call	 crc32
  0009d	89 86 bc 00 00
	00		 mov	 DWORD PTR [rsi+188], eax

; 274  : 
; 275  :     /* check gzip trailer if at end of deflate stream */
; 276  :     if (ret == Z_STREAM_END) {

  000a3	83 fb 01	 cmp	 ebx, 1
  000a6	75 6b		 jne	 SHORT $LN5@gz_decomp

; 277  :         if (gz_next4(state, &crc) == -1 || gz_next4(state, &len) == -1) {

  000a8	48 8d 54 24 40	 lea	 rdx, QWORD PTR crc$[rsp]
  000ad	48 8b ce	 mov	 rcx, rsi
  000b0	e8 00 00 00 00	 call	 gz_next4
  000b5	83 f8 ff	 cmp	 eax, -1
  000b8	74 2a		 je	 SHORT $LN22@gz_decomp
  000ba	48 8d 54 24 48	 lea	 rdx, QWORD PTR len$[rsp]
  000bf	48 8b ce	 mov	 rcx, rsi
  000c2	e8 00 00 00 00	 call	 gz_next4
  000c7	83 f8 ff	 cmp	 eax, -1
  000ca	74 18		 je	 SHORT $LN22@gz_decomp

; 278  :             gz_error(state, Z_DATA_ERROR, "unexpected end of file");
; 279  :             return -1;
; 280  :         }
; 281  :         if (crc != strm->adler) {

  000cc	8b 86 bc 00 00
	00		 mov	 eax, DWORD PTR [rsi+188]
  000d2	39 44 24 40	 cmp	 DWORD PTR crc$[rsp], eax
  000d6	74 1a		 je	 SHORT $LN2@gz_decomp

; 282  :             gz_error(state, Z_DATA_ERROR, "incorrect data check");

  000d8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
  000df	8d 53 fc	 lea	 edx, QWORD PTR [rbx-4]

; 283  :             return -1;

  000e2	eb 74		 jmp	 SHORT $LN28@gz_decomp
$LN22@gz_decomp:

; 248  :             gz_error(state, Z_DATA_ERROR, "unexpected end of file");

  000e4	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BH@CFIIDOJD@unexpected?5end?5of?5file?$AA@
  000eb	ba fd ff ff ff	 mov	 edx, -3

; 249  :             return -1;

  000f0	eb 66		 jmp	 SHORT $LN28@gz_decomp
$LN2@gz_decomp:

; 284  :         }
; 285  :         if (len != (strm->total_out & 0xffffffffL)) {

  000f2	8b 86 8c 00 00
	00		 mov	 eax, DWORD PTR [rsi+140]
  000f8	39 44 24 48	 cmp	 DWORD PTR len$[rsp], eax
  000fc	74 0e		 je	 SHORT $LN1@gz_decomp

; 286  :             gz_error(state, Z_DATA_ERROR, "incorrect length check");

  000fe	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
  00105	ba fd ff ff ff	 mov	 edx, -3

; 287  :             return -1;

  0010a	eb 4c		 jmp	 SHORT $LN28@gz_decomp
$LN1@gz_decomp:

; 288  :         }
; 289  :         state->how = LOOK;      /* ready for next stream, once have is 0 (leave

  0010c	c7 46 48 00 00
	00 00		 mov	 DWORD PTR [rsi+72], 0
$LN5@gz_decomp:

; 290  :                                    state->direct unchanged to remember how) */
; 291  :     }
; 292  : 
; 293  :     /* good decompression */
; 294  :     return 0;

  00113	33 c0		 xor	 eax, eax
  00115	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 295  : }

  0011a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011e	5f		 pop	 rdi
  0011f	5e		 pop	 rsi
  00120	5d		 pop	 rbp
  00121	c3		 ret	 0
$LN25@gz_decomp:

; 264  :             gz_error(state, Z_DATA_ERROR,
; 265  :                       strm->msg == NULL ? "compressed data error" : strm->msg);

  00122	48 8b 86 90 00
	00 00		 mov	 rax, QWORD PTR [rsi+144]
  00129	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BG@HCKBMIHF@compressed?5data?5error?$AA@
  00130	ba fd ff ff ff	 mov	 edx, -3
  00135	48 85 c0	 test	 rax, rax
  00138	4c 0f 45 c0	 cmovne	 r8, rax

; 266  :             return -1;

  0013c	eb 1a		 jmp	 SHORT $LN28@gz_decomp
$LN24@gz_decomp:

; 260  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  0013e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  00145	ba fc ff ff ff	 mov	 edx, -4

; 261  :             return -1;

  0014a	eb 0c		 jmp	 SHORT $LN28@gz_decomp
$LN9@gz_decomp:

; 255  :             gz_error(state, Z_STREAM_ERROR,
; 256  :                       "internal error: inflate stream corrupt");

  0014c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CH@CPOLIEKA@internal?5error?3?5inflate?5stream?5c@
  00153	ba fe ff ff ff	 mov	 edx, -2
$LN28@gz_decomp:
  00158	48 8b ce	 mov	 rcx, rsi
  0015b	e8 00 00 00 00	 call	 gz_error
$LN21@gz_decomp:

; 257  :             return -1;

  00160	83 c8 ff	 or	 eax, -1
  00163	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]

; 295  : }

  00168	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0016c	5f		 pop	 rdi
  0016d	5e		 pop	 rsi
  0016e	5d		 pop	 rbp
  0016f	c3		 ret	 0
gz_decomp ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzread.c
;	COMDAT gz_head
_TEXT	SEGMENT
state$ = 64
gz_head	PROC						; COMDAT

; 106  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	56		 push	 rsi
  0000b	57		 push	 rdi
  0000c	41 57		 push	 r15
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 107  :     z_streamp strm = &(state->strm);
; 108  :     int flags;
; 109  :     unsigned len;
; 110  : 
; 111  :     /* allocate read buffers and inflate memory */
; 112  :     if (state->size == 0) {

  00012	45 33 ff	 xor	 r15d, r15d
  00015	48 8b f1	 mov	 rsi, rcx
  00018	44 39 79 14	 cmp	 DWORD PTR [rcx+20], r15d
  0001c	0f 85 d5 00 00
	00		 jne	 $LN22@gz_head

; 113  :         /* allocate buffers */
; 114  :         state->in = malloc(state->want);

  00022	8b 69 18	 mov	 ebp, DWORD PTR [rcx+24]
  00025	8b cd		 mov	 ecx, ebp
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc

; 115  :         state->out = malloc(state->want << 1);

  0002d	8d 0c 6d 00 00
	00 00		 lea	 ecx, DWORD PTR [rbp*2]
  00034	48 8b f8	 mov	 rdi, rax
  00037	48 89 46 20	 mov	 QWORD PTR [rsi+32], rax
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00041	48 89 46 28	 mov	 QWORD PTR [rsi+40], rax

; 116  :         if (state->in == NULL || state->out == NULL) {

  00045	48 85 ff	 test	 rdi, rdi
  00048	74 74		 je	 SHORT $LN25@gz_head
  0004a	48 85 c0	 test	 rax, rax
  0004d	74 7d		 je	 SHORT $LN24@gz_head

; 123  :         }
; 124  :         state->size = state->want;
; 125  : 
; 126  :         /* allocate inflate memory */
; 127  :         state->strm.zalloc = Z_NULL;
; 128  :         state->strm.zfree = Z_NULL;
; 129  :         state->strm.opaque = Z_NULL;
; 130  :         state->strm.avail_in = 0;
; 131  :         state->strm.next_in = Z_NULL;
; 132  :         if (inflateInit2(&(state->strm), -15) != Z_OK) {    /* raw inflate */

  0004f	45 8d 4f 58	 lea	 r9d, QWORD PTR [r15+88]
  00053	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05DFCKICEH@1?42?45?$AA@
  0005a	41 8d 57 f1	 lea	 edx, QWORD PTR [r15-15]
  0005e	48 8d 4e 70	 lea	 rcx, QWORD PTR [rsi+112]
  00062	89 6e 14	 mov	 DWORD PTR [rsi+20], ebp
  00065	4c 89 be a0 00
	00 00		 mov	 QWORD PTR [rsi+160], r15
  0006c	4c 89 be a8 00
	00 00		 mov	 QWORD PTR [rsi+168], r15
  00073	4c 89 be b0 00
	00 00		 mov	 QWORD PTR [rsi+176], r15
  0007a	44 89 7e 78	 mov	 DWORD PTR [rsi+120], r15d
  0007e	4c 89 7e 70	 mov	 QWORD PTR [rsi+112], r15
  00082	e8 00 00 00 00	 call	 inflateInit2_
  00087	85 c0		 test	 eax, eax
  00089	74 6c		 je	 SHORT $LN22@gz_head

; 133  :             free(state->out);

  0008b	48 8b 4e 28	 mov	 rcx, QWORD PTR [rsi+40]
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 134  :             free(state->in);

  00095	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 135  :             state->size = 0;
; 136  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  0009f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000a6	41 8d 57 fc	 lea	 edx, QWORD PTR [r15-4]
  000aa	48 8b ce	 mov	 rcx, rsi
  000ad	44 89 7e 14	 mov	 DWORD PTR [rsi+20], r15d
  000b1	e8 00 00 00 00	 call	 gz_error

; 137  :             return -1;

  000b6	83 c8 ff	 or	 eax, -1
  000b9	e9 42 01 00 00	 jmp	 $LN28@gz_head
$LN25@gz_head:

; 117  :             if (state->out != NULL)

  000be	48 85 c0	 test	 rax, rax
  000c1	74 09		 je	 SHORT $LN24@gz_head

; 118  :                 free(state->out);

  000c3	48 8b c8	 mov	 rcx, rax
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN24@gz_head:

; 119  :             if (state->in != NULL)

  000cc	48 8b 4e 20	 mov	 rcx, QWORD PTR [rsi+32]
  000d0	48 85 c9	 test	 rcx, rcx
  000d3	74 06		 je	 SHORT $LN23@gz_head

; 120  :                 free(state->in);

  000d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN23@gz_head:

; 121  :             gz_error(state, Z_MEM_ERROR, "out of memory");

  000db	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0O@BNNCBLEN@out?5of?5memory?$AA@
  000e2	ba fc ff ff ff	 mov	 edx, -4
  000e7	48 8b ce	 mov	 rcx, rsi
  000ea	e8 00 00 00 00	 call	 gz_error
$LN114@gz_head:

; 122  :             return -1;

  000ef	83 c8 ff	 or	 eax, -1
  000f2	e9 09 01 00 00	 jmp	 $LN28@gz_head
$LN22@gz_head:

; 138  :         }
; 139  :     }
; 140  : 
; 141  :     /* get some data in the input buffer */
; 142  :     if (strm->avail_in == 0) {

  000f7	8b 4e 78	 mov	 ecx, DWORD PTR [rsi+120]
  000fa	85 c9		 test	 ecx, ecx
  000fc	75 18		 jne	 SHORT $LN19@gz_head

; 143  :         if (gz_avail(state) == -1)

  000fe	48 8b ce	 mov	 rcx, rsi
  00101	e8 00 00 00 00	 call	 gz_avail
  00106	83 f8 ff	 cmp	 eax, -1
  00109	74 e4		 je	 SHORT $LN114@gz_head

; 144  :             return -1;
; 145  :         if (strm->avail_in == 0)

  0010b	8b 4e 78	 mov	 ecx, DWORD PTR [rsi+120]
  0010e	85 c9		 test	 ecx, ecx
  00110	0f 84 d3 03 00
	00		 je	 $LN115@gz_head
$LN19@gz_head:

; 146  :             return 0;
; 147  :     }
; 148  : 
; 149  :     /* look for the gzip magic header bytes 31 and 139 */
; 150  :     if (strm->next_in[0] == 31) {

  00116	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  0011a	80 38 1f	 cmp	 BYTE PTR [rax], 31
  0011d	0f 85 87 03 00
	00		 jne	 $LN2@gz_head

; 151  :         strm->avail_in--;

  00123	ff c9		 dec	 ecx

; 152  :         strm->next_in++;

  00125	48 ff c0	 inc	 rax
  00128	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax
  0012c	89 4e 78	 mov	 DWORD PTR [rsi+120], ecx

; 153  :         if (strm->avail_in == 0 && gz_avail(state) == -1)

  0012f	85 c9		 test	 ecx, ecx
  00131	75 0d		 jne	 SHORT $LN17@gz_head
  00133	48 8b ce	 mov	 rcx, rsi
  00136	e8 00 00 00 00	 call	 gz_avail
  0013b	83 f8 ff	 cmp	 eax, -1
  0013e	74 af		 je	 SHORT $LN114@gz_head
$LN17@gz_head:

; 154  :             return -1;
; 155  :         if (strm->avail_in && strm->next_in[0] == 139) {

  00140	8b 4e 78	 mov	 ecx, DWORD PTR [rsi+120]
  00143	85 c9		 test	 ecx, ecx
  00145	0f 84 51 03 00
	00		 je	 $LN16@gz_head
  0014b	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  0014f	80 38 8b	 cmp	 BYTE PTR [rax], 139	; 0000008bH
  00152	0f 85 44 03 00
	00		 jne	 $LN16@gz_head

; 156  :             /* we have a gzip header, woo hoo! */
; 157  :             strm->avail_in--;

  00158	ff c9		 dec	 ecx

; 158  :             strm->next_in++;

  0015a	48 ff c0	 inc	 rax
  0015d	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax
  00161	89 4e 78	 mov	 DWORD PTR [rsi+120], ecx

; 159  : 
; 160  :             /* skip rest of header */
; 161  :             if (NEXT() != 8) {      /* compression method */

  00164	85 c9		 test	 ecx, ecx
  00166	75 11		 jne	 SHORT $LN30@gz_head
  00168	48 8b ce	 mov	 rcx, rsi
  0016b	e8 00 00 00 00	 call	 gz_avail
  00170	83 f8 ff	 cmp	 eax, -1
  00173	0f 84 07 03 00
	00		 je	 $LN98@gz_head
$LN30@gz_head:
  00179	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  0017c	85 c0		 test	 eax, eax
  0017e	0f 84 fc 02 00
	00		 je	 $LN98@gz_head
  00184	8d 50 ff	 lea	 edx, DWORD PTR [rax-1]
  00187	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  0018b	48 ff c0	 inc	 rax
  0018e	89 56 78	 mov	 DWORD PTR [rsi+120], edx
  00191	0f b6 48 ff	 movzx	 ecx, BYTE PTR [rax-1]
  00195	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax
  00199	83 f9 08	 cmp	 ecx, 8
  0019c	0f 85 de 02 00
	00		 jne	 $LN98@gz_head

; 164  :             }
; 165  :             flags = NEXT();

  001a2	83 cf ff	 or	 edi, -1
  001a5	4c 89 74 24 40	 mov	 QWORD PTR [rsp+64], r14
  001aa	85 d2		 test	 edx, edx
  001ac	75 11		 jne	 SHORT $LN34@gz_head
  001ae	48 8b ce	 mov	 rcx, rsi
  001b1	e8 00 00 00 00	 call	 gz_avail
  001b6	3b c7		 cmp	 eax, edi
  001b8	75 05		 jne	 SHORT $LN34@gz_head
  001ba	44 8b f7	 mov	 r14d, edi
  001bd	eb 20		 jmp	 SHORT $LN36@gz_head
$LN34@gz_head:
  001bf	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  001c2	85 c0		 test	 eax, eax
  001c4	75 05		 jne	 SHORT $LN35@gz_head
  001c6	44 8b f7	 mov	 r14d, edi
  001c9	eb 14		 jmp	 SHORT $LN36@gz_head
$LN35@gz_head:
  001cb	ff c8		 dec	 eax
  001cd	89 46 78	 mov	 DWORD PTR [rsi+120], eax
  001d0	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  001d4	44 0f b6 30	 movzx	 r14d, BYTE PTR [rax]
  001d8	48 ff c0	 inc	 rax
  001db	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax
$LN36@gz_head:

; 166  :             if (flags & 0xe0) {     /* reserved flag bits */

  001df	41 f6 c6 e0	 test	 r14b, -32		; ffffffffffffffe0H
  001e3	74 2e		 je	 SHORT $LN14@gz_head

; 167  :                 gz_error(state, Z_DATA_ERROR, "unknown header flags set");

  001e5	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
  001ec	ba fd ff ff ff	 mov	 edx, -3
  001f1	48 8b ce	 mov	 rcx, rsi
  001f4	e8 00 00 00 00	 call	 gz_error

; 168  :                 return -1;

  001f9	8b c7		 mov	 eax, edi
$LN113@gz_head:
  001fb	4c 8b 74 24 40	 mov	 r14, QWORD PTR [rsp+64]
$LN28@gz_head:

; 223  : }

  00200	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00205	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  0020a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0020e	41 5f		 pop	 r15
  00210	5f		 pop	 rdi
  00211	5e		 pop	 rsi
  00212	c3		 ret	 0
$LN14@gz_head:

; 169  :             }
; 170  :             NEXT();                 /* modification time */

  00213	44 39 7e 78	 cmp	 DWORD PTR [rsi+120], r15d
  00217	75 0d		 jne	 SHORT $LN38@gz_head
  00219	48 8b ce	 mov	 rcx, rsi
  0021c	e8 00 00 00 00	 call	 gz_avail
  00221	83 f8 ff	 cmp	 eax, -1
  00224	74 10		 je	 SHORT $LN40@gz_head
$LN38@gz_head:
  00226	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  00229	85 c0		 test	 eax, eax
  0022b	74 09		 je	 SHORT $LN40@gz_head
  0022d	ff c8		 dec	 eax
  0022f	48 ff 46 70	 inc	 QWORD PTR [rsi+112]
  00233	89 46 78	 mov	 DWORD PTR [rsi+120], eax
$LN40@gz_head:

; 171  :             NEXT();

  00236	44 39 7e 78	 cmp	 DWORD PTR [rsi+120], r15d
  0023a	75 0d		 jne	 SHORT $LN42@gz_head
  0023c	48 8b ce	 mov	 rcx, rsi
  0023f	e8 00 00 00 00	 call	 gz_avail
  00244	83 f8 ff	 cmp	 eax, -1
  00247	74 10		 je	 SHORT $LN44@gz_head
$LN42@gz_head:
  00249	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  0024c	85 c0		 test	 eax, eax
  0024e	74 09		 je	 SHORT $LN44@gz_head
  00250	ff c8		 dec	 eax
  00252	48 ff 46 70	 inc	 QWORD PTR [rsi+112]
  00256	89 46 78	 mov	 DWORD PTR [rsi+120], eax
$LN44@gz_head:

; 172  :             NEXT();

  00259	44 39 7e 78	 cmp	 DWORD PTR [rsi+120], r15d
  0025d	75 0d		 jne	 SHORT $LN46@gz_head
  0025f	48 8b ce	 mov	 rcx, rsi
  00262	e8 00 00 00 00	 call	 gz_avail
  00267	83 f8 ff	 cmp	 eax, -1
  0026a	74 10		 je	 SHORT $LN48@gz_head
$LN46@gz_head:
  0026c	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  0026f	85 c0		 test	 eax, eax
  00271	74 09		 je	 SHORT $LN48@gz_head
  00273	ff c8		 dec	 eax
  00275	48 ff 46 70	 inc	 QWORD PTR [rsi+112]
  00279	89 46 78	 mov	 DWORD PTR [rsi+120], eax
$LN48@gz_head:

; 173  :             NEXT();

  0027c	44 39 7e 78	 cmp	 DWORD PTR [rsi+120], r15d
  00280	75 0d		 jne	 SHORT $LN50@gz_head
  00282	48 8b ce	 mov	 rcx, rsi
  00285	e8 00 00 00 00	 call	 gz_avail
  0028a	83 f8 ff	 cmp	 eax, -1
  0028d	74 10		 je	 SHORT $LN52@gz_head
$LN50@gz_head:
  0028f	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  00292	85 c0		 test	 eax, eax
  00294	74 09		 je	 SHORT $LN52@gz_head
  00296	ff c8		 dec	 eax
  00298	48 ff 46 70	 inc	 QWORD PTR [rsi+112]
  0029c	89 46 78	 mov	 DWORD PTR [rsi+120], eax
$LN52@gz_head:

; 174  :             NEXT();                 /* extra flags */

  0029f	44 39 7e 78	 cmp	 DWORD PTR [rsi+120], r15d
  002a3	75 0d		 jne	 SHORT $LN54@gz_head
  002a5	48 8b ce	 mov	 rcx, rsi
  002a8	e8 00 00 00 00	 call	 gz_avail
  002ad	83 f8 ff	 cmp	 eax, -1
  002b0	74 10		 je	 SHORT $LN56@gz_head
$LN54@gz_head:
  002b2	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  002b5	85 c0		 test	 eax, eax
  002b7	74 09		 je	 SHORT $LN56@gz_head
  002b9	ff c8		 dec	 eax
  002bb	48 ff 46 70	 inc	 QWORD PTR [rsi+112]
  002bf	89 46 78	 mov	 DWORD PTR [rsi+120], eax
$LN56@gz_head:

; 175  :             NEXT();                 /* operating system */

  002c2	44 39 7e 78	 cmp	 DWORD PTR [rsi+120], r15d
  002c6	75 0d		 jne	 SHORT $LN58@gz_head
  002c8	48 8b ce	 mov	 rcx, rsi
  002cb	e8 00 00 00 00	 call	 gz_avail
  002d0	83 f8 ff	 cmp	 eax, -1
  002d3	74 10		 je	 SHORT $LN60@gz_head
$LN58@gz_head:
  002d5	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  002d8	85 c0		 test	 eax, eax
  002da	74 09		 je	 SHORT $LN60@gz_head
  002dc	ff c8		 dec	 eax
  002de	48 ff 46 70	 inc	 QWORD PTR [rsi+112]
  002e2	89 46 78	 mov	 DWORD PTR [rsi+120], eax
$LN60@gz_head:

; 176  :             if (flags & 4) {        /* extra field */

  002e5	41 f6 c6 04	 test	 r14b, 4
  002e9	0f 84 a9 00 00
	00		 je	 $LN110@gz_head

; 177  :                 len = (unsigned)NEXT();

  002ef	44 39 7e 78	 cmp	 DWORD PTR [rsi+120], r15d
  002f3	75 12		 jne	 SHORT $LN62@gz_head
  002f5	48 8b ce	 mov	 rcx, rsi
  002f8	e8 00 00 00 00	 call	 gz_avail
  002fd	83 f8 ff	 cmp	 eax, -1
  00300	75 05		 jne	 SHORT $LN62@gz_head
  00302	83 cd ff	 or	 ebp, -1			; ffffffffH
  00305	eb 1f		 jmp	 SHORT $LN64@gz_head
$LN62@gz_head:
  00307	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  0030a	85 c0		 test	 eax, eax
  0030c	75 05		 jne	 SHORT $LN63@gz_head
  0030e	83 cd ff	 or	 ebp, -1			; ffffffffH
  00311	eb 13		 jmp	 SHORT $LN64@gz_head
$LN63@gz_head:
  00313	ff c8		 dec	 eax
  00315	89 46 78	 mov	 DWORD PTR [rsi+120], eax
  00318	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  0031c	0f b6 28	 movzx	 ebp, BYTE PTR [rax]
  0031f	48 ff c0	 inc	 rax
  00322	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax
$LN64@gz_head:

; 178  :                 len += (unsigned)NEXT() << 8;

  00326	44 39 7e 78	 cmp	 DWORD PTR [rsi+120], r15d
  0032a	75 0d		 jne	 SHORT $LN66@gz_head
  0032c	48 8b ce	 mov	 rcx, rsi
  0032f	e8 00 00 00 00	 call	 gz_avail
  00334	83 f8 ff	 cmp	 eax, -1
  00337	74 1a		 je	 SHORT $LN68@gz_head
$LN66@gz_head:
  00339	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  0033c	85 c0		 test	 eax, eax
  0033e	74 13		 je	 SHORT $LN68@gz_head
  00340	ff c8		 dec	 eax
  00342	89 46 78	 mov	 DWORD PTR [rsi+120], eax
  00345	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  00349	0f b6 38	 movzx	 edi, BYTE PTR [rax]
  0034c	48 ff c0	 inc	 rax
  0034f	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax
$LN68@gz_head:
  00353	c1 e7 08	 shl	 edi, 8
  00356	03 ef		 add	 ebp, edi

; 179  :                 while (len--)

  00358	74 3e		 je	 SHORT $LN110@gz_head
  0035a	66 0f 1f 44 00
	00		 npad	 6
$LL12@gz_head:

; 180  :                     if (NEXT() < 0)

  00360	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  00363	ff cd		 dec	 ebp
  00365	85 c0		 test	 eax, eax
  00367	75 14		 jne	 SHORT $LN107@gz_head
  00369	48 8b ce	 mov	 rcx, rsi
  0036c	e8 00 00 00 00	 call	 gz_avail
  00371	83 f8 ff	 cmp	 eax, -1
  00374	74 22		 je	 SHORT $LN110@gz_head
  00376	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  00379	85 c0		 test	 eax, eax
  0037b	74 1b		 je	 SHORT $LN110@gz_head
$LN107@gz_head:
  0037d	ff c8		 dec	 eax
  0037f	89 46 78	 mov	 DWORD PTR [rsi+120], eax
  00382	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  00386	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00389	48 ff c0	 inc	 rax
  0038c	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax
  00390	85 c9		 test	 ecx, ecx
  00392	78 04		 js	 SHORT $LN110@gz_head

; 179  :                 while (len--)

  00394	85 ed		 test	 ebp, ebp
  00396	75 c8		 jne	 SHORT $LL12@gz_head
$LN110@gz_head:

; 181  :                         break;
; 182  :             }
; 183  :             if (flags & 8)          /* file name */

  00398	41 f6 c6 08	 test	 r14b, 8
  0039c	74 34		 je	 SHORT $LN111@gz_head
  0039e	66 90		 npad	 2
$LL8@gz_head:

; 184  :                 while (NEXT() > 0)

  003a0	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  003a3	85 c0		 test	 eax, eax
  003a5	75 14		 jne	 SHORT $LN108@gz_head
  003a7	48 8b ce	 mov	 rcx, rsi
  003aa	e8 00 00 00 00	 call	 gz_avail
  003af	83 f8 ff	 cmp	 eax, -1
  003b2	74 1e		 je	 SHORT $LN111@gz_head
  003b4	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  003b7	85 c0		 test	 eax, eax
  003b9	74 17		 je	 SHORT $LN111@gz_head
$LN108@gz_head:
  003bb	ff c8		 dec	 eax
  003bd	89 46 78	 mov	 DWORD PTR [rsi+120], eax
  003c0	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  003c4	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  003c7	48 ff c0	 inc	 rax
  003ca	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax
  003ce	85 c9		 test	 ecx, ecx
  003d0	7f ce		 jg	 SHORT $LL8@gz_head
$LN111@gz_head:

; 185  :                     ;
; 186  :             if (flags & 16)         /* comment */

  003d2	41 f6 c6 10	 test	 r14b, 16
  003d6	74 32		 je	 SHORT $LN112@gz_head
$LL5@gz_head:

; 187  :                 while (NEXT() > 0)

  003d8	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  003db	85 c0		 test	 eax, eax
  003dd	75 14		 jne	 SHORT $LN109@gz_head
  003df	48 8b ce	 mov	 rcx, rsi
  003e2	e8 00 00 00 00	 call	 gz_avail
  003e7	83 f8 ff	 cmp	 eax, -1
  003ea	74 1e		 je	 SHORT $LN112@gz_head
  003ec	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  003ef	85 c0		 test	 eax, eax
  003f1	74 17		 je	 SHORT $LN112@gz_head
$LN109@gz_head:
  003f3	ff c8		 dec	 eax
  003f5	89 46 78	 mov	 DWORD PTR [rsi+120], eax
  003f8	48 8b 46 70	 mov	 rax, QWORD PTR [rsi+112]
  003fc	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  003ff	48 ff c0	 inc	 rax
  00402	48 89 46 70	 mov	 QWORD PTR [rsi+112], rax
  00406	85 c9		 test	 ecx, ecx
  00408	7f ce		 jg	 SHORT $LL5@gz_head
$LN112@gz_head:

; 188  :                     ;
; 189  :             if (flags & 2) {        /* header crc */

  0040a	41 f6 c6 02	 test	 r14b, 2
  0040e	74 46		 je	 SHORT $LN88@gz_head

; 190  :                 NEXT();

  00410	44 39 7e 78	 cmp	 DWORD PTR [rsi+120], r15d
  00414	75 0d		 jne	 SHORT $LN82@gz_head
  00416	48 8b ce	 mov	 rcx, rsi
  00419	e8 00 00 00 00	 call	 gz_avail
  0041e	83 f8 ff	 cmp	 eax, -1
  00421	74 10		 je	 SHORT $LN84@gz_head
$LN82@gz_head:
  00423	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  00426	85 c0		 test	 eax, eax
  00428	74 09		 je	 SHORT $LN84@gz_head
  0042a	ff c8		 dec	 eax
  0042c	48 ff 46 70	 inc	 QWORD PTR [rsi+112]
  00430	89 46 78	 mov	 DWORD PTR [rsi+120], eax
$LN84@gz_head:

; 191  :                 NEXT();

  00433	44 39 7e 78	 cmp	 DWORD PTR [rsi+120], r15d
  00437	75 0d		 jne	 SHORT $LN86@gz_head
  00439	48 8b ce	 mov	 rcx, rsi
  0043c	e8 00 00 00 00	 call	 gz_avail
  00441	83 f8 ff	 cmp	 eax, -1
  00444	74 10		 je	 SHORT $LN88@gz_head
$LN86@gz_head:
  00446	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  00449	85 c0		 test	 eax, eax
  0044b	74 09		 je	 SHORT $LN88@gz_head
  0044d	ff c8		 dec	 eax
  0044f	48 ff 46 70	 inc	 QWORD PTR [rsi+112]
  00453	89 46 78	 mov	 DWORD PTR [rsi+120], eax
$LN88@gz_head:

; 192  :             }
; 193  :             /* an unexpected end of file is not checked for here -- it will be
; 194  :                noticed on the first request for uncompressed data */
; 195  : 
; 196  :             /* set up for decompression */
; 197  :             inflateReset(strm);

  00456	48 8d 4e 70	 lea	 rcx, QWORD PTR [rsi+112]
  0045a	e8 00 00 00 00	 call	 inflateReset

; 198  :             strm->adler = crc32(0L, Z_NULL, 0);

  0045f	45 33 c0	 xor	 r8d, r8d
  00462	33 d2		 xor	 edx, edx
  00464	33 c9		 xor	 ecx, ecx
  00466	e8 00 00 00 00	 call	 crc32
  0046b	89 86 bc 00 00
	00		 mov	 DWORD PTR [rsi+188], eax

; 199  :             state->how = GZIP;

  00471	48 c7 46 48 02
	00 00 00	 mov	 QWORD PTR [rsi+72], 2

; 200  :             state->direct = 0;
; 201  :             return 0;

  00479	33 c0		 xor	 eax, eax
  0047b	e9 7b fd ff ff	 jmp	 $LN113@gz_head
$LN98@gz_head:

; 162  :                 gz_error(state, Z_DATA_ERROR, "unknown compression method");

  00480	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  00487	ba fd ff ff ff	 mov	 edx, -3
  0048c	48 8b ce	 mov	 rcx, rsi
  0048f	e8 00 00 00 00	 call	 gz_error

; 163  :                 return -1;

  00494	83 c8 ff	 or	 eax, -1
  00497	e9 64 fd ff ff	 jmp	 $LN28@gz_head
$LN16@gz_head:

; 202  :         }
; 203  :         else {
; 204  :             /* not a gzip file -- save first byte (31) and fall to raw i/o */
; 205  :             state->out[0] = 31;

  0049c	48 8b 46 28	 mov	 rax, QWORD PTR [rsi+40]
  004a0	c6 00 1f	 mov	 BYTE PTR [rax], 31

; 206  :             state->have = 1;

  004a3	c7 46 38 01 00
	00 00		 mov	 DWORD PTR [rsi+56], 1
$LN2@gz_head:

; 207  :         }
; 208  :     }
; 209  : 
; 210  :     /* doing raw i/o, save start of raw data for seeking, copy any leftover
; 211  :        input to output -- this assumes that the output buffer is larger than
; 212  :        the input buffer, which also assures space for gzungetc() */
; 213  :     state->raw = state->pos;

  004aa	8b 46 10	 mov	 eax, DWORD PTR [rsi+16]
  004ad	89 46 44	 mov	 DWORD PTR [rsi+68], eax

; 214  :     state->next = state->out;

  004b0	48 8b 46 28	 mov	 rax, QWORD PTR [rsi+40]
  004b4	48 89 46 30	 mov	 QWORD PTR [rsi+48], rax

; 215  :     if (strm->avail_in) {

  004b8	8b 4e 78	 mov	 ecx, DWORD PTR [rsi+120]
  004bb	85 c9		 test	 ecx, ecx
  004bd	74 1c		 je	 SHORT $LN1@gz_head

; 216  :         memcpy(state->next + state->have, strm->next_in, strm->avail_in);

  004bf	48 8b 56 70	 mov	 rdx, QWORD PTR [rsi+112]
  004c3	44 8b c1	 mov	 r8d, ecx
  004c6	8b 4e 38	 mov	 ecx, DWORD PTR [rsi+56]
  004c9	48 03 c8	 add	 rcx, rax
  004cc	e8 00 00 00 00	 call	 memcpy

; 217  :         state->have += strm->avail_in;

  004d1	8b 46 78	 mov	 eax, DWORD PTR [rsi+120]
  004d4	01 46 38	 add	 DWORD PTR [rsi+56], eax

; 218  :         strm->avail_in = 0;

  004d7	44 89 7e 78	 mov	 DWORD PTR [rsi+120], r15d
$LN1@gz_head:

; 219  :     }
; 220  :     state->how = COPY;

  004db	c7 46 48 01 00
	00 00		 mov	 DWORD PTR [rsi+72], 1

; 221  :     state->direct = 1;

  004e2	c7 46 4c 01 00
	00 00		 mov	 DWORD PTR [rsi+76], 1
$LN115@gz_head:

; 222  :     return 0;

  004e9	33 c0		 xor	 eax, eax
  004eb	e9 10 fd ff ff	 jmp	 $LN28@gz_head
gz_head	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzread.c
;	COMDAT gz_next4
_TEXT	SEGMENT
state$ = 48
ret$ = 56
gz_next4 PROC						; COMDAT

; 76   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 77   :     int ch;
; 78   :     unsigned long val;
; 79   :     z_streamp strm = &(state->strm);
; 80   : 
; 81   :     val = NEXT();

  0000f	83 79 78 00	 cmp	 DWORD PTR [rcx+120], 0
  00013	48 8b f2	 mov	 rsi, rdx
  00016	48 8b d9	 mov	 rbx, rcx
  00019	75 0f		 jne	 SHORT $LN4@gz_next4
  0001b	e8 00 00 00 00	 call	 gz_avail
  00020	83 f8 ff	 cmp	 eax, -1
  00023	75 05		 jne	 SHORT $LN4@gz_next4
  00025	83 cf ff	 or	 edi, -1			; ffffffffH
  00028	eb 1f		 jmp	 SHORT $LN6@gz_next4
$LN4@gz_next4:
  0002a	8b 43 78	 mov	 eax, DWORD PTR [rbx+120]
  0002d	85 c0		 test	 eax, eax
  0002f	75 05		 jne	 SHORT $LN5@gz_next4
  00031	83 cf ff	 or	 edi, -1			; ffffffffH
  00034	eb 13		 jmp	 SHORT $LN6@gz_next4
$LN5@gz_next4:
  00036	ff c8		 dec	 eax
  00038	89 43 78	 mov	 DWORD PTR [rbx+120], eax
  0003b	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  0003f	0f b6 38	 movzx	 edi, BYTE PTR [rax]
  00042	48 ff c0	 inc	 rax
  00045	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax
$LN6@gz_next4:

; 82   :     val += (unsigned)NEXT() << 8;

  00049	83 7b 78 00	 cmp	 DWORD PTR [rbx+120], 0
  0004d	75 11		 jne	 SHORT $LN8@gz_next4
  0004f	48 8b cb	 mov	 rcx, rbx
  00052	e8 00 00 00 00	 call	 gz_avail
  00057	83 f8 ff	 cmp	 eax, -1
  0005a	75 04		 jne	 SHORT $LN8@gz_next4
  0005c	0b c8		 or	 ecx, eax
  0005e	eb 1f		 jmp	 SHORT $LN10@gz_next4
$LN8@gz_next4:
  00060	8b 43 78	 mov	 eax, DWORD PTR [rbx+120]
  00063	85 c0		 test	 eax, eax
  00065	75 05		 jne	 SHORT $LN9@gz_next4
  00067	83 c9 ff	 or	 ecx, -1
  0006a	eb 13		 jmp	 SHORT $LN10@gz_next4
$LN9@gz_next4:
  0006c	ff c8		 dec	 eax
  0006e	89 43 78	 mov	 DWORD PTR [rbx+120], eax
  00071	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  00075	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00078	48 ff c0	 inc	 rax
  0007b	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax
$LN10@gz_next4:
  0007f	c1 e1 08	 shl	 ecx, 8
  00082	03 f9		 add	 edi, ecx

; 83   :     val += (unsigned long)NEXT() << 16;

  00084	83 7b 78 00	 cmp	 DWORD PTR [rbx+120], 0
  00088	75 11		 jne	 SHORT $LN12@gz_next4
  0008a	48 8b cb	 mov	 rcx, rbx
  0008d	e8 00 00 00 00	 call	 gz_avail
  00092	83 f8 ff	 cmp	 eax, -1
  00095	75 04		 jne	 SHORT $LN12@gz_next4
  00097	0b c8		 or	 ecx, eax
  00099	eb 1f		 jmp	 SHORT $LN14@gz_next4
$LN12@gz_next4:
  0009b	8b 43 78	 mov	 eax, DWORD PTR [rbx+120]
  0009e	85 c0		 test	 eax, eax
  000a0	75 05		 jne	 SHORT $LN13@gz_next4
  000a2	83 c9 ff	 or	 ecx, -1
  000a5	eb 13		 jmp	 SHORT $LN14@gz_next4
$LN13@gz_next4:
  000a7	ff c8		 dec	 eax
  000a9	89 43 78	 mov	 DWORD PTR [rbx+120], eax
  000ac	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  000b0	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000b3	48 ff c0	 inc	 rax
  000b6	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax
$LN14@gz_next4:
  000ba	c1 e1 10	 shl	 ecx, 16
  000bd	03 f9		 add	 edi, ecx

; 84   :     ch = NEXT();

  000bf	83 7b 78 00	 cmp	 DWORD PTR [rbx+120], 0
  000c3	75 0d		 jne	 SHORT $LN16@gz_next4
  000c5	48 8b cb	 mov	 rcx, rbx
  000c8	e8 00 00 00 00	 call	 gz_avail
  000cd	83 f8 ff	 cmp	 eax, -1
  000d0	74 38		 je	 SHORT $LN20@gz_next4
$LN16@gz_next4:
  000d2	8b 43 78	 mov	 eax, DWORD PTR [rbx+120]
  000d5	85 c0		 test	 eax, eax
  000d7	74 31		 je	 SHORT $LN20@gz_next4
  000d9	ff c8		 dec	 eax
  000db	89 43 78	 mov	 DWORD PTR [rbx+120], eax
  000de	48 8b 43 70	 mov	 rax, QWORD PTR [rbx+112]
  000e2	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000e5	48 ff c0	 inc	 rax
  000e8	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax

; 85   :     if (ch == -1)

  000ec	83 f9 ff	 cmp	 ecx, -1
  000ef	74 19		 je	 SHORT $LN20@gz_next4

; 86   :         return -1;
; 87   :     val += (unsigned long)ch << 24;

  000f1	c1 e1 18	 shl	 ecx, 24
  000f4	03 cf		 add	 ecx, edi

; 88   :     *ret = val;
; 89   :     return 0;

  000f6	33 c0		 xor	 eax, eax
  000f8	89 0e		 mov	 DWORD PTR [rsi], ecx

; 90   : }

  000fa	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ff	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00104	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00108	5f		 pop	 rdi
  00109	c3		 ret	 0
$LN20@gz_next4:
  0010a	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0010f	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00114	83 c8 ff	 or	 eax, -1
  00117	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011b	5f		 pop	 rdi
  0011c	c3		 ret	 0
gz_next4 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzread.c
;	COMDAT gz_avail
_TEXT	SEGMENT
state$ = 48
gz_avail PROC						; COMDAT

; 52   : {

  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 53   :     z_streamp strm = &(state->strm);
; 54   : 
; 55   :     if (state->err != Z_OK)

  00006	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	74 09		 je	 SHORT $LN3@gz_avail
$LN6@gz_avail:

; 56   :         return -1;

  0000f	83 c8 ff	 or	 eax, -1

; 64   : }

  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5b		 pop	 rbx
  00017	c3		 ret	 0
$LN3@gz_avail:

; 57   :     if (state->eof == 0) {

  00018	83 79 3c 00	 cmp	 DWORD PTR [rcx+60], 0
  0001c	75 1e		 jne	 SHORT $LN2@gz_avail

; 58   :         if (gz_load(state, state->in, state->size,
; 59   :                 (unsigned *)&(strm->avail_in)) == -1)

  0001e	44 8b 41 14	 mov	 r8d, DWORD PTR [rcx+20]
  00022	48 8b 51 20	 mov	 rdx, QWORD PTR [rcx+32]
  00026	4c 8d 49 78	 lea	 r9, QWORD PTR [rcx+120]
  0002a	e8 00 00 00 00	 call	 gz_load
  0002f	83 f8 ff	 cmp	 eax, -1
  00032	74 db		 je	 SHORT $LN6@gz_avail

; 60   :             return -1;
; 61   :         strm->next_in = state->in;

  00034	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00038	48 89 43 70	 mov	 QWORD PTR [rbx+112], rax
$LN2@gz_avail:

; 62   :     }
; 63   :     return 0;

  0003c	33 c0		 xor	 eax, eax

; 64   : }

  0003e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00042	5b		 pop	 rbx
  00043	c3		 ret	 0
gz_avail ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzread.c
;	COMDAT gz_load
_TEXT	SEGMENT
state$ = 48
buf$ = 56
len$ = 64
have$ = 72
gz_load	PROC						; COMDAT

; 26   : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	49 8b d9	 mov	 rbx, r9
  00017	41 8b f8	 mov	 edi, r8d
  0001a	48 8b ea	 mov	 rbp, rdx
  0001d	48 8b f1	 mov	 rsi, rcx

; 27   :     int ret;
; 28   : 
; 29   :     *have = 0;

  00020	41 c7 01 00 00
	00 00		 mov	 DWORD PTR [r9], 0
  00027	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL6@gz_load:

; 30   :     do {
; 31   :         ret = read(state->fd, buf + *have, len - *have);

  00030	8b 13		 mov	 edx, DWORD PTR [rbx]
  00032	8b 4e 04	 mov	 ecx, DWORD PTR [rsi+4]
  00035	44 8b c7	 mov	 r8d, edi
  00038	44 2b c2	 sub	 r8d, edx
  0003b	48 03 d5	 add	 rdx, rbp
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_read

; 32   :         if (ret <= 0)

  00044	85 c0		 test	 eax, eax
  00046	7e 08		 jle	 SHORT $LN12@gz_load

; 33   :             break;
; 34   :         *have += ret;

  00048	01 03		 add	 DWORD PTR [rbx], eax

; 35   :     } while (*have < len);

  0004a	39 3b		 cmp	 DWORD PTR [rbx], edi
  0004c	72 e2		 jb	 SHORT $LL6@gz_load

; 36   :     if (ret < 0) {

  0004e	85 c0		 test	 eax, eax
$LN12@gz_load:
  00050	79 21		 jns	 SHORT $LN2@gz_load

; 37   :         gz_error(state, Z_ERRNO, zstrerror());

  00052	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00058	8b 08		 mov	 ecx, DWORD PTR [rax]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00060	83 ca ff	 or	 edx, -1
  00063	48 8b ce	 mov	 rcx, rsi
  00066	4c 8b c0	 mov	 r8, rax
  00069	e8 00 00 00 00	 call	 gz_error

; 38   :         return -1;

  0006e	83 c8 ff	 or	 eax, -1
  00071	eb 0d		 jmp	 SHORT $LN7@gz_load
$LN2@gz_load:

; 39   :     }
; 40   :     if (ret == 0)

  00073	85 c0		 test	 eax, eax
  00075	75 07		 jne	 SHORT $LN1@gz_load

; 41   :         state->eof = 1;

  00077	c7 46 3c 01 00
	00 00		 mov	 DWORD PTR [rsi+60], 1
$LN1@gz_load:

; 42   :     return 0;

  0007e	33 c0		 xor	 eax, eax
$LN7@gz_load:

; 43   : }

  00080	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00085	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  0008a	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0008f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00093	5f		 pop	 rdi
  00094	c3		 ret	 0
gz_load	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzread.c
;	COMDAT gzclose_r
_TEXT	SEGMENT
file$ = 48
gzclose_r PROC						; COMDAT

; 629  : {

$LN8:
  00000	40 57		 push	 rdi
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b f9	 mov	 rdi, rcx

; 630  :     int ret;
; 631  :     gz_statep state;
; 632  : 
; 633  :     /* get internal structure */
; 634  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 0b		 jne	 SHORT $LN3@gzclose_r
$LN6@gzclose_r:

; 635  :         return Z_STREAM_ERROR;

  0000e	b8 fe ff ff ff	 mov	 eax, -2

; 653  : }

  00013	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00017	5f		 pop	 rdi
  00018	c3		 ret	 0
$LN3@gzclose_r:

; 636  :     state = (gz_statep)file;
; 637  : 
; 638  :     /* check that we're reading */
; 639  :     if (state->mode != GZ_READ)

  00019	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [rcx], 7247	; 00001c4fH
  0001f	75 ed		 jne	 SHORT $LN6@gzclose_r

; 640  :         return Z_STREAM_ERROR;
; 641  : 
; 642  :     /* free memory and close file */
; 643  :     if (state->size) {

  00021	83 79 14 00	 cmp	 DWORD PTR [rcx+20], 0
  00025	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  0002a	74 1d		 je	 SHORT $LN1@gzclose_r

; 644  :         inflateEnd(&(state->strm));

  0002c	48 83 c1 70	 add	 rcx, 112		; 00000070H
  00030	e8 00 00 00 00	 call	 inflateEnd

; 645  :         free(state->out);

  00035	48 8b 4f 28	 mov	 rcx, QWORD PTR [rdi+40]
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 646  :         free(state->in);

  0003f	48 8b 4f 20	 mov	 rcx, QWORD PTR [rdi+32]
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@gzclose_r:

; 647  :     }
; 648  :     gz_error(state, Z_OK, NULL);

  00049	45 33 c0	 xor	 r8d, r8d
  0004c	33 d2		 xor	 edx, edx
  0004e	48 8b cf	 mov	 rcx, rdi
  00051	e8 00 00 00 00	 call	 gz_error

; 649  :     free(state->path);

  00056	48 8b 4f 08	 mov	 rcx, QWORD PTR [rdi+8]
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 650  :     ret = close(state->fd);

  00060	8b 4f 04	 mov	 ecx, DWORD PTR [rdi+4]
  00063	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_close

; 651  :     free(state);

  00069	48 8b cf	 mov	 rcx, rdi
  0006c	8b d8		 mov	 ebx, eax
  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free

; 652  :     return ret ? Z_ERRNO : Z_OK;

  00074	f7 db		 neg	 ebx
  00076	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0007b	1b c0		 sbb	 eax, eax

; 653  : }

  0007d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00081	5f		 pop	 rdi
  00082	c3		 ret	 0
gzclose_r ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzread.c
;	COMDAT gzdirect
_TEXT	SEGMENT
file$ = 48
gzdirect PROC						; COMDAT

; 605  : {

$LN8:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 606  :     gz_statep state;
; 607  : 
; 608  :     /* get internal structure */
; 609  :     if (file == NULL)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	75 08		 jne	 SHORT $LN3@gzdirect
$LN6@gzdirect:

; 610  :         return 0;

  0000e	33 c0		 xor	 eax, eax

; 624  : }

  00010	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00014	5b		 pop	 rbx
  00015	c3		 ret	 0
$LN3@gzdirect:

; 611  :     state = (gz_statep)file;
; 612  : 
; 613  :     /* check that we're reading */
; 614  :     if (state->mode != GZ_READ)

  00016	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [rcx], 7247	; 00001c4fH
  0001c	75 f0		 jne	 SHORT $LN6@gzdirect

; 615  :         return 0;
; 616  : 
; 617  :     /* if the state is not known, but we can find out, then do so (this is
; 618  :        mainly for right after a gzopen() or gzdopen()) */
; 619  :     if (state->how == LOOK && state->have == 0)

  0001e	83 79 48 00	 cmp	 DWORD PTR [rcx+72], 0
  00022	75 0b		 jne	 SHORT $LN1@gzdirect
  00024	83 79 38 00	 cmp	 DWORD PTR [rcx+56], 0
  00028	75 05		 jne	 SHORT $LN1@gzdirect

; 620  :         (void)gz_head(state);

  0002a	e8 00 00 00 00	 call	 gz_head
$LN1@gzdirect:

; 621  : 
; 622  :     /* return 1 if reading direct, 0 if decompressing a gzip stream */
; 623  :     return state->direct;

  0002f	8b 43 4c	 mov	 eax, DWORD PTR [rbx+76]

; 624  : }

  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5b		 pop	 rbx
  00037	c3		 ret	 0
gzdirect ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzread.c
;	COMDAT gzungetc
_TEXT	SEGMENT
c$ = 48
file$ = 56
gzungetc PROC						; COMDAT

; 485  : {

$LN18:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	8b f9		 mov	 edi, ecx

; 486  :     gz_statep state;
; 487  : 
; 488  :     /* get internal structure */
; 489  :     if (file == NULL)

  0000f	48 85 d2	 test	 rdx, rdx
  00012	74 7f		 je	 SHORT $LN9@gzungetc

; 490  :         return -1;
; 491  :     state = (gz_statep)file;
; 492  : 
; 493  :     /* check that we're reading and that there's no error */
; 494  :     if (state->mode != GZ_READ || state->err != Z_OK)

  00014	81 3a 4f 1c 00
	00		 cmp	 DWORD PTR [rdx], 7247	; 00001c4fH
  0001a	75 77		 jne	 SHORT $LN9@gzungetc
  0001c	83 7a 60 00	 cmp	 DWORD PTR [rdx+96], 0
  00020	75 71		 jne	 SHORT $LN9@gzungetc

; 496  : 
; 497  :     /* process a skip request */
; 498  :     if (state->seek) {

  00022	83 7a 5c 00	 cmp	 DWORD PTR [rdx+92], 0
  00026	74 17		 je	 SHORT $LN7@gzungetc

; 499  :         state->seek = 0;

  00028	c7 42 5c 00 00
	00 00		 mov	 DWORD PTR [rdx+92], 0

; 500  :         if (gz_skip(state, state->skip) == -1)

  0002f	8b 52 58	 mov	 edx, DWORD PTR [rdx+88]
  00032	48 8b cb	 mov	 rcx, rbx
  00035	e8 00 00 00 00	 call	 gz_skip
  0003a	83 f8 ff	 cmp	 eax, -1
  0003d	74 54		 je	 SHORT $LN9@gzungetc
$LN7@gzungetc:

; 501  :             return -1;
; 502  :     }
; 503  : 
; 504  :     /* can't push EOF */
; 505  :     if (c < 0)

  0003f	85 ff		 test	 edi, edi
  00041	78 50		 js	 SHORT $LN9@gzungetc

; 506  :         return -1;
; 507  : 
; 508  :     /* if output buffer empty, put byte at end (allows more pushing) */
; 509  :     if (state->have == 0) {

  00043	8b 4b 38	 mov	 ecx, DWORD PTR [rbx+56]

; 510  :         state->have = 1;
; 511  :         state->next = state->out + (state->size << 1) - 1;

  00046	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  00049	85 c9		 test	 ecx, ecx
  0004b	75 2b		 jne	 SHORT $LN5@gzungetc
  0004d	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
  00051	8d 0c 00	 lea	 ecx, DWORD PTR [rax+rax]
  00054	c7 43 38 01 00
	00 00		 mov	 DWORD PTR [rbx+56], 1
  0005b	48 ff ca	 dec	 rdx

; 512  :         state->next[0] = c;
; 513  :         state->pos--;
; 514  :         return c;

  0005e	8b c7		 mov	 eax, edi
  00060	48 03 d1	 add	 rdx, rcx
  00063	48 89 53 30	 mov	 QWORD PTR [rbx+48], rdx
  00067	40 88 3a	 mov	 BYTE PTR [rdx], dil
  0006a	ff 4b 10	 dec	 DWORD PTR [rbx+16]

; 535  :     return c;
; 536  : }

  0006d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00072	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00076	5f		 pop	 rdi
  00077	c3		 ret	 0
$LN5@gzungetc:

; 515  :     }
; 516  : 
; 517  :     /* if no room, give up (must have already done a gzungetc()) */
; 518  :     if (state->have == (state->size << 1)) {

  00078	8d 14 00	 lea	 edx, DWORD PTR [rax+rax]
  0007b	3b ca		 cmp	 ecx, edx
  0007d	75 22		 jne	 SHORT $LN4@gzungetc

; 519  :         gz_error(state, Z_BUF_ERROR, "out of room to push characters");

  0007f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BP@IIKIGMCC@out?5of?5room?5to?5push?5characters?$AA@
  00086	ba fb ff ff ff	 mov	 edx, -5
  0008b	48 8b cb	 mov	 rcx, rbx
  0008e	e8 00 00 00 00	 call	 gz_error
$LN9@gzungetc:

; 495  :         return -1;

  00093	83 c8 ff	 or	 eax, -1

; 535  :     return c;
; 536  : }

  00096	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0009b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009f	5f		 pop	 rdi
  000a0	c3		 ret	 0
$LN4@gzungetc:

; 520  :         return -1;
; 521  :     }
; 522  : 
; 523  :     /* slide output data if needed and insert byte before existing data */
; 524  :     if (state->next == state->out) {

  000a1	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  000a5	48 39 43 30	 cmp	 QWORD PTR [rbx+48], rax
  000a9	75 2b		 jne	 SHORT $LN3@gzungetc

; 525  :         unsigned char *src = state->out + state->have;

  000ab	48 03 c8	 add	 rcx, rax

; 526  :         unsigned char *dest = state->out + (state->size << 1);

  000ae	48 03 d0	 add	 rdx, rax

; 527  :         while (src > state->out)

  000b1	48 3b c8	 cmp	 rcx, rax
  000b4	76 1c		 jbe	 SHORT $LN1@gzungetc
  000b6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL2@gzungetc:

; 528  :             *--dest = *--src;

  000c0	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]
  000c4	48 ff c9	 dec	 rcx
  000c7	48 ff ca	 dec	 rdx
  000ca	88 02		 mov	 BYTE PTR [rdx], al
  000cc	48 3b 4b 28	 cmp	 rcx, QWORD PTR [rbx+40]
  000d0	77 ee		 ja	 SHORT $LL2@gzungetc
$LN1@gzungetc:

; 529  :         state->next = dest;

  000d2	48 89 53 30	 mov	 QWORD PTR [rbx+48], rdx
$LN3@gzungetc:

; 530  :     }
; 531  :     state->have++;
; 532  :     state->next--;

  000d6	48 ff 4b 30	 dec	 QWORD PTR [rbx+48]
  000da	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  000de	ff 43 38	 inc	 DWORD PTR [rbx+56]

; 533  :     state->next[0] = c;

  000e1	40 88 38	 mov	 BYTE PTR [rax], dil

; 534  :     state->pos--;

  000e4	ff 4b 10	 dec	 DWORD PTR [rbx+16]

; 535  :     return c;
; 536  : }

  000e7	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000ec	8b c7		 mov	 eax, edi
  000ee	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000f2	5f		 pop	 rdi
  000f3	c3		 ret	 0
gzungetc ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzread.c
;	COMDAT gzgetc
_TEXT	SEGMENT
buf$ = 48
file$ = 48
gzgetc	PROC						; COMDAT

; 455  : {

$LN10:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	4c 8b c9	 mov	 r9, rcx

; 456  :     int ret;
; 457  :     unsigned char buf[1];
; 458  :     gz_statep state;
; 459  : 
; 460  :     /* get internal structure */
; 461  :     if (file == NULL)

  00007	48 85 c9	 test	 rcx, rcx
  0000a	74 51		 je	 SHORT $LN2@gzgetc

; 462  :         return -1;
; 463  :     state = (gz_statep)file;
; 464  : 
; 465  :     /* check that we're reading and that there's no error */
; 466  :     if (state->mode != GZ_READ || state->err != Z_OK)

  0000c	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [rcx], 7247	; 00001c4fH
  00012	75 49		 jne	 SHORT $LN2@gzgetc
  00014	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00018	75 43		 jne	 SHORT $LN2@gzgetc

; 468  : 
; 469  :     /* try output buffer (no need to check for skip request) */
; 470  :     if (state->have) {

  0001a	8b 41 38	 mov	 eax, DWORD PTR [rcx+56]
  0001d	85 c0		 test	 eax, eax
  0001f	74 1d		 je	 SHORT $LN1@gzgetc

; 471  :         state->have--;
; 472  :         state->pos++;

  00021	ff 41 10	 inc	 DWORD PTR [rcx+16]
  00024	ff c8		 dec	 eax
  00026	89 41 38	 mov	 DWORD PTR [rcx+56], eax

; 473  :         return *(state->next)++;

  00029	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
  0002d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00030	48 ff c0	 inc	 rax
  00033	49 89 41 30	 mov	 QWORD PTR [r9+48], rax
  00037	8b c1		 mov	 eax, ecx

; 479  : }

  00039	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003d	c3		 ret	 0
$LN1@gzgetc:

; 474  :     }
; 475  : 
; 476  :     /* nothing there -- try gzread() */
; 477  :     ret = gzread(file, buf, 1);

  0003e	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00043	41 b8 01 00 00
	00		 mov	 r8d, 1
  00049	e8 00 00 00 00	 call	 gzread

; 478  :     return ret < 1 ? -1 : buf[0];

  0004e	83 f8 01	 cmp	 eax, 1
  00051	7c 0a		 jl	 SHORT $LN2@gzgetc
  00053	0f b6 44 24 30	 movzx	 eax, BYTE PTR buf$[rsp]

; 479  : }

  00058	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005c	c3		 ret	 0
$LN2@gzgetc:

; 467  :         return -1;

  0005d	83 c8 ff	 or	 eax, -1

; 479  : }

  00060	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00064	c3		 ret	 0
gzgetc	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzread.c
;	COMDAT gzgets
_TEXT	SEGMENT
file$ = 64
buf$ = 72
len$ = 80
gzgets	PROC						; COMDAT

; 543  : {

$LN30:
  00000	40 56		 push	 rsi
  00002	41 56		 push	 r14
  00004	41 57		 push	 r15
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	45 8b f8	 mov	 r15d, r8d
  0000d	4c 8b f2	 mov	 r14, rdx
  00010	48 8b f1	 mov	 rsi, rcx

; 544  :     unsigned left, n;
; 545  :     char *str;
; 546  :     unsigned char *eol;
; 547  :     gz_statep state;
; 548  : 
; 549  :     /* check parameters and get internal structure */
; 550  :     if (file == NULL || buf == NULL || len < 1)

  00013	48 85 c9	 test	 rcx, rcx
  00016	0f 84 01 01 00
	00		 je	 $LN13@gzgets
  0001c	48 85 d2	 test	 rdx, rdx
  0001f	0f 84 f8 00 00
	00		 je	 $LN13@gzgets
  00025	41 83 f8 01	 cmp	 r8d, 1
  00029	0f 8c ee 00 00
	00		 jl	 $LN13@gzgets

; 551  :         return NULL;
; 552  :     state = (gz_statep)file;
; 553  : 
; 554  :     /* check that we're reading and that there's no error */
; 555  :     if (state->mode != GZ_READ || state->err != Z_OK)

  0002f	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [rcx], 7247	; 00001c4fH
  00035	0f 85 e2 00 00
	00		 jne	 $LN13@gzgets
  0003b	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  0003f	0f 85 d8 00 00
	00		 jne	 $LN13@gzgets

; 557  : 
; 558  :     /* process a skip request */
; 559  :     if (state->seek) {

  00045	83 79 5c 00	 cmp	 DWORD PTR [rcx+92], 0
  00049	74 18		 je	 SHORT $LN11@gzgets

; 560  :         state->seek = 0;
; 561  :         if (gz_skip(state, state->skip) == -1)

  0004b	8b 51 58	 mov	 edx, DWORD PTR [rcx+88]
  0004e	c7 41 5c 00 00
	00 00		 mov	 DWORD PTR [rcx+92], 0
  00055	e8 00 00 00 00	 call	 gz_skip
  0005a	83 f8 ff	 cmp	 eax, -1
  0005d	0f 84 ba 00 00
	00		 je	 $LN13@gzgets
$LN11@gzgets:
  00063	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00068	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  0006d	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00072	4c 89 64 24 58	 mov	 QWORD PTR [rsp+88], r12

; 562  :             return NULL;
; 563  :     }
; 564  : 
; 565  :     /* copy output bytes up to new line or len - 1, whichever comes first --
; 566  :        append a terminating zero to the string (we don't check for a zero in
; 567  :        the contents, let the user worry about that) */
; 568  :     str = buf;

  00077	4d 8b e6	 mov	 r12, r14

; 569  :     left = (unsigned)len - 1;

  0007a	41 ff cf	 dec	 r15d

; 570  :     if (left) do {

  0007d	74 70		 je	 SHORT $LN7@gzgets
  0007f	90		 npad	 1
$LL9@gzgets:

; 571  :         /* assure that something is in the output buffer */
; 572  :         if (state->have == 0) {

  00080	8b 5e 38	 mov	 ebx, DWORD PTR [rsi+56]
  00083	85 db		 test	 ebx, ebx
  00085	75 18		 jne	 SHORT $LN4@gzgets

; 573  :             if (gz_make(state) == -1)

  00087	48 8b ce	 mov	 rcx, rsi
  0008a	e8 00 00 00 00	 call	 gz_make
  0008f	83 f8 ff	 cmp	 eax, -1
  00092	0f 84 81 00 00
	00		 je	 $LN22@gzgets

; 574  :                 return NULL;            /* error */
; 575  :             if (state->have == 0) {     /* end of file */

  00098	8b 5e 38	 mov	 ebx, DWORD PTR [rsi+56]
  0009b	85 db		 test	 ebx, ebx
  0009d	74 75		 je	 SHORT $LN23@gzgets
$LN4@gzgets:

; 578  :                 break;                  /* got something -- return it */
; 579  :             }
; 580  :         }
; 581  : 
; 582  :         /* look for end-of-line in current output buffer */
; 583  :         n = state->have > left ? left : state->have;
; 584  :         eol = memchr(state->next, '\n', n);

  0009f	48 8b 4e 30	 mov	 rcx, QWORD PTR [rsi+48]
  000a3	41 3b df	 cmp	 ebx, r15d
  000a6	ba 0a 00 00 00	 mov	 edx, 10
  000ab	41 0f 47 df	 cmova	 ebx, r15d
  000af	44 8b c3	 mov	 r8d, ebx
  000b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000b8	48 8b e8	 mov	 rbp, rax

; 585  :         if (eol != NULL)

  000bb	48 85 c0	 test	 rax, rax
  000be	74 07		 je	 SHORT $LN2@gzgets

; 586  :             n = (unsigned)(eol - state->next) + 1;

  000c0	8b d8		 mov	 ebx, eax
  000c2	2b 5e 30	 sub	 ebx, DWORD PTR [rsi+48]
  000c5	ff c3		 inc	 ebx
$LN2@gzgets:

; 587  : 
; 588  :         /* copy through end-of-line, or remainder if not found */
; 589  :         memcpy(buf, state->next, n);

  000c7	48 8b 56 30	 mov	 rdx, QWORD PTR [rsi+48]
  000cb	44 8b c3	 mov	 r8d, ebx
  000ce	49 8b ce	 mov	 rcx, r14
  000d1	8b fb		 mov	 edi, ebx
  000d3	e8 00 00 00 00	 call	 memcpy

; 590  :         state->have -= n;

  000d8	29 5e 38	 sub	 DWORD PTR [rsi+56], ebx

; 591  :         state->next += n;

  000db	48 01 7e 30	 add	 QWORD PTR [rsi+48], rdi

; 592  :         state->pos += n;

  000df	01 5e 10	 add	 DWORD PTR [rsi+16], ebx

; 593  :         left -= n;
; 594  :         buf += n;

  000e2	4c 03 f7	 add	 r14, rdi
  000e5	44 2b fb	 sub	 r15d, ebx

; 595  :     } while (left && eol == NULL);

  000e8	74 05		 je	 SHORT $LN7@gzgets
  000ea	48 85 ed	 test	 rbp, rbp
  000ed	74 91		 je	 SHORT $LL9@gzgets
$LN7@gzgets:

; 596  : 
; 597  :     /* found end-of-line or out of space -- terminate string and return it */
; 598  :     buf[0] = 0;

  000ef	41 c6 06 00	 mov	 BYTE PTR [r14], 0

; 599  :     return str;

  000f3	49 8b c4	 mov	 rax, r12
$LN28@gzgets:
  000f6	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  000fb	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  00100	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00105	4c 8b 64 24 58	 mov	 r12, QWORD PTR [rsp+88]

; 600  : }

  0010a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010e	41 5f		 pop	 r15
  00110	41 5e		 pop	 r14
  00112	5e		 pop	 rsi
  00113	c3		 ret	 0
$LN23@gzgets:

; 576  :                 if (buf == str)         /* got bupkus */

  00114	4d 3b f4	 cmp	 r14, r12
  00117	75 d6		 jne	 SHORT $LN7@gzgets
$LN22@gzgets:

; 577  :                     return NULL;

  00119	33 c0		 xor	 eax, eax
  0011b	eb d9		 jmp	 SHORT $LN28@gzgets
$LN13@gzgets:

; 556  :         return NULL;

  0011d	33 c0		 xor	 eax, eax

; 600  : }

  0011f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00123	41 5f		 pop	 r15
  00125	41 5e		 pop	 r14
  00127	5e		 pop	 rsi
  00128	c3		 ret	 0
gzgets	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\gzread.c
;	COMDAT gzread
_TEXT	SEGMENT
n$ = 80
file$ = 80
buf$ = 88
len$ = 96
gzread	PROC						; COMDAT

; 366  : {

$LN40:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	41 56		 push	 r14
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00009	41 8b e8	 mov	 ebp, r8d
  0000c	4c 8b f2	 mov	 r14, rdx
  0000f	48 8b d9	 mov	 rbx, rcx

; 367  :     unsigned got, n;
; 368  :     gz_statep state;
; 369  :     z_streamp strm;
; 370  : 
; 371  :     /* get internal structure */
; 372  :     if (file == NULL)

  00012	48 85 c9	 test	 rcx, rcx
  00015	74 24		 je	 SHORT $LN38@gzread

; 373  :         return -1;
; 374  :     state = (gz_statep)file;
; 375  :     strm = &(state->strm);
; 376  : 
; 377  :     /* check that we're reading and that there's no error */
; 378  :     if (state->mode != GZ_READ || state->err != Z_OK)

  00017	81 39 4f 1c 00
	00		 cmp	 DWORD PTR [rcx], 7247	; 00001c4fH
  0001d	75 1c		 jne	 SHORT $LN38@gzread
  0001f	83 79 60 00	 cmp	 DWORD PTR [rcx+96], 0
  00023	75 16		 jne	 SHORT $LN38@gzread

; 379  :         return -1;
; 380  : 
; 381  :     /* since an int is returned, make sure len fits in one, otherwise return
; 382  :        with an error (this avoids the flaw in the interface) */
; 383  :     if ((int)len < 0) {

  00025	45 85 c0	 test	 r8d, r8d
  00028	79 1d		 jns	 SHORT $LN37@gzread

; 384  :         gz_error(state, Z_BUF_ERROR, "requested length does not fit in int");

  0002a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CF@MLPJFDMM@requested?5length?5does?5not?5fit?5in@
  00031	ba fb ff ff ff	 mov	 edx, -5
  00036	e8 00 00 00 00	 call	 gz_error
$LN38@gzread:

; 385  :         return -1;

  0003b	83 c8 ff	 or	 eax, -1

; 450  : }

  0003e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00042	41 5e		 pop	 r14
  00044	5d		 pop	 rbp
  00045	5b		 pop	 rbx
  00046	c3		 ret	 0
$LN37@gzread:

; 386  :     }
; 387  : 
; 388  :     /* if len is zero, avoid unnecessary operations */
; 389  :     if (len == 0)

  00047	75 0b		 jne	 SHORT $LN18@gzread

; 390  :         return 0;

  00049	33 c0		 xor	 eax, eax

; 450  : }

  0004b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0004f	41 5e		 pop	 r14
  00051	5d		 pop	 rbp
  00052	5b		 pop	 rbx
  00053	c3		 ret	 0
$LN18@gzread:
  00054	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12

; 391  : 
; 392  :     /* process a skip request */
; 393  :     if (state->seek) {

  00059	45 33 e4	 xor	 r12d, r12d
  0005c	44 39 61 5c	 cmp	 DWORD PTR [rcx+92], r12d
  00060	74 21		 je	 SHORT $LN16@gzread

; 394  :         state->seek = 0;
; 395  :         if (gz_skip(state, state->skip) == -1)

  00062	8b 51 58	 mov	 edx, DWORD PTR [rcx+88]
  00065	44 89 61 5c	 mov	 DWORD PTR [rcx+92], r12d
  00069	e8 00 00 00 00	 call	 gz_skip
  0006e	83 f8 ff	 cmp	 eax, -1
  00071	75 10		 jne	 SHORT $LN16@gzread

; 396  :             return -1;

  00073	0b c0		 or	 eax, eax
  00075	4c 8b 64 24 28	 mov	 r12, QWORD PTR [rsp+40]

; 450  : }

  0007a	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007e	41 5e		 pop	 r14
  00080	5d		 pop	 rbp
  00081	5b		 pop	 rbx
  00082	c3		 ret	 0
$LN16@gzread:
  00083	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  00088	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15

; 397  :     }
; 398  : 
; 399  :     /* get len bytes to buf, or less than len if at the end */
; 400  :     got = 0;

  0008d	45 8b fc	 mov	 r15d, r12d
  00090	48 89 7c 24 60	 mov	 QWORD PTR [rsp+96], rdi
$LL15@gzread:

; 401  :     do {
; 402  :         /* first just try copying data from the output buffer */
; 403  :         if (state->have) {

  00095	8b 73 38	 mov	 esi, DWORD PTR [rbx+56]
  00098	85 f6		 test	 esi, esi
  0009a	74 33		 je	 SHORT $LN12@gzread

; 404  :             n = state->have > len ? len : state->have;
; 405  :             memcpy(buf, state->next, n);

  0009c	48 8b 53 30	 mov	 rdx, QWORD PTR [rbx+48]
  000a0	3b f5		 cmp	 esi, ebp
  000a2	49 8b ce	 mov	 rcx, r14
  000a5	0f 47 f5	 cmova	 esi, ebp
  000a8	44 8b c6	 mov	 r8d, esi
  000ab	89 74 24 50	 mov	 DWORD PTR n$[rsp], esi
  000af	8b fe		 mov	 edi, esi
  000b1	e8 00 00 00 00	 call	 memcpy

; 406  :             state->next += n;

  000b6	48 01 7b 30	 add	 QWORD PTR [rbx+48], rdi

; 407  :             state->have -= n;

  000ba	29 73 38	 sub	 DWORD PTR [rbx+56], esi

; 439  :         }
; 440  : 
; 441  :         /* update progress */
; 442  :         len -= n;
; 443  :         buf = (char *)buf + n;

  000bd	8b c6		 mov	 eax, esi
  000bf	2b ee		 sub	 ebp, esi

; 444  :         got += n;

  000c1	44 03 fe	 add	 r15d, esi
  000c4	4c 03 f0	 add	 r14, rax

; 445  :         state->pos += n;

  000c7	01 73 10	 add	 DWORD PTR [rbx+16], esi
  000ca	e9 8e 00 00 00	 jmp	 $LN14@gzread
$LN12@gzread:

; 408  :         }
; 409  : 
; 410  :         /* output buffer empty -- return if we're at the end of the input */
; 411  :         else if (state->eof && strm->avail_in == 0)

  000cf	44 39 63 3c	 cmp	 DWORD PTR [rbx+60], r12d
  000d3	74 0a		 je	 SHORT $LN10@gzread
  000d5	44 39 63 78	 cmp	 DWORD PTR [rbx+120], r12d
  000d9	0f 84 86 00 00
	00		 je	 $LN13@gzread
$LN10@gzread:

; 412  :             break;
; 413  : 
; 414  :         /* need output data -- for small len or new stream load up our output
; 415  :            buffer */
; 416  :         else if (state->how == LOOK || len < (state->size << 1)) {

  000df	8b 4b 48	 mov	 ecx, DWORD PTR [rbx+72]
  000e2	85 c9		 test	 ecx, ecx
  000e4	74 6a		 je	 SHORT $LN7@gzread
  000e6	8b 43 14	 mov	 eax, DWORD PTR [rbx+20]
  000e9	03 c0		 add	 eax, eax
  000eb	3b e8		 cmp	 ebp, eax
  000ed	72 61		 jb	 SHORT $LN7@gzread

; 420  :             continue;       /* no progress yet -- go back to memcpy() above */
; 421  :             /* the copy above assures that we will leave with space in the
; 422  :                output buffer, allowing at least one gzungetc() to succeed */
; 423  :         }
; 424  : 
; 425  :         /* large len -- read directly into user buffer */
; 426  :         else if (state->how == COPY) {      /* read directly */

  000ef	83 f9 01	 cmp	 ecx, 1

; 427  :             if (gz_load(state, buf, len, &n) == -1)

  000f2	48 8b cb	 mov	 rcx, rbx
  000f5	75 28		 jne	 SHORT $LN4@gzread
  000f7	4c 8d 4c 24 50	 lea	 r9, QWORD PTR n$[rsp]
  000fc	44 8b c5	 mov	 r8d, ebp
  000ff	49 8b d6	 mov	 rdx, r14
  00102	e8 00 00 00 00	 call	 gz_load
  00107	83 f8 ff	 cmp	 eax, -1
  0010a	74 5e		 je	 SHORT $LN31@gzread

; 428  :                 return -1;
; 429  :         }
; 430  : 
; 431  :         /* large len -- decompress directly into user buffer */
; 432  :         else {  /* state->how == GZIP */

  0010c	8b 74 24 50	 mov	 esi, DWORD PTR n$[rsp]

; 439  :         }
; 440  : 
; 441  :         /* update progress */
; 442  :         len -= n;
; 443  :         buf = (char *)buf + n;

  00110	8b c6		 mov	 eax, esi
  00112	2b ee		 sub	 ebp, esi

; 444  :         got += n;

  00114	44 03 fe	 add	 r15d, esi
  00117	4c 03 f0	 add	 r14, rax

; 445  :         state->pos += n;

  0011a	01 73 10	 add	 DWORD PTR [rbx+16], esi
  0011d	eb 3e		 jmp	 SHORT $LN14@gzread
$LN4@gzread:

; 433  :             strm->avail_out = len;

  0011f	89 ab 88 00 00
	00		 mov	 DWORD PTR [rbx+136], ebp

; 434  :             strm->next_out = buf;

  00125	4c 89 b3 80 00
	00 00		 mov	 QWORD PTR [rbx+128], r14

; 435  :             if (gz_decomp(state) == -1)

  0012c	e8 00 00 00 00	 call	 gz_decomp
  00131	83 f8 ff	 cmp	 eax, -1
  00134	74 34		 je	 SHORT $LN31@gzread

; 436  :                 return -1;
; 437  :             n = state->have;

  00136	8b 73 38	 mov	 esi, DWORD PTR [rbx+56]

; 438  :             state->have = 0;

  00139	44 89 63 38	 mov	 DWORD PTR [rbx+56], r12d

; 439  :         }
; 440  : 
; 441  :         /* update progress */
; 442  :         len -= n;
; 443  :         buf = (char *)buf + n;

  0013d	8b c6		 mov	 eax, esi
  0013f	2b ee		 sub	 ebp, esi

; 444  :         got += n;

  00141	44 03 fe	 add	 r15d, esi
  00144	4c 03 f0	 add	 r14, rax

; 445  :         state->pos += n;

  00147	01 73 10	 add	 DWORD PTR [rbx+16], esi
  0014a	89 74 24 50	 mov	 DWORD PTR n$[rsp], esi
  0014e	eb 0d		 jmp	 SHORT $LN14@gzread
$LN7@gzread:

; 417  :             /* get more output, looking for header if required */
; 418  :             if (gz_make(state) == -1)

  00150	48 8b cb	 mov	 rcx, rbx
  00153	e8 00 00 00 00	 call	 gz_make
  00158	83 f8 ff	 cmp	 eax, -1
  0015b	74 0d		 je	 SHORT $LN31@gzread
$LN14@gzread:

; 446  :     } while (len);

  0015d	85 ed		 test	 ebp, ebp
  0015f	0f 85 30 ff ff
	ff		 jne	 $LL15@gzread
$LN13@gzread:

; 447  : 
; 448  :     /* return number of bytes read into user buffer (will fit in int) */
; 449  :     return (int)got;

  00165	41 8b c7	 mov	 eax, r15d
  00168	eb 03		 jmp	 SHORT $LN36@gzread
$LN31@gzread:

; 419  :                 return -1;

  0016a	83 c8 ff	 or	 eax, -1
$LN36@gzread:
  0016d	48 8b 7c 24 60	 mov	 rdi, QWORD PTR [rsp+96]
  00172	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00177	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  0017c	4c 8b 64 24 28	 mov	 r12, QWORD PTR [rsp+40]

; 450  : }

  00181	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00185	41 5e		 pop	 r14
  00187	5d		 pop	 rbp
  00188	5b		 pop	 rbx
  00189	c3		 ret	 0
gzread	ENDP
_TEXT	ENDS
END
