; Listing generated by Microsoft (R) Optimizing Compiler Version 17.00.50727.1 

include listing.inc

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

CONST	SEGMENT
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
CONST	ENDS
PUBLIC	inflate
PUBLIC	inflateEnd
PUBLIC	inflateSetDictionary
PUBLIC	inflateSync
PUBLIC	inflateCopy
PUBLIC	inflateReset
PUBLIC	inflateReset2
PUBLIC	inflatePrime
PUBLIC	inflateMark
PUBLIC	inflateGetHeader
PUBLIC	inflateInit_
PUBLIC	inflateInit2_
PUBLIC	inflateSyncPoint
PUBLIC	inflateUndermine
PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
EXTRN	adler32:PROC
EXTRN	crc32:PROC
EXTRN	zcalloc:PROC
EXTRN	zcfree:PROC
EXTRN	inflate_table:PROC
EXTRN	inflate_fast:PROC
EXTRN	memcpy:PROC
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate DD imagerel $LN885
	DD	imagerel $LN885+81
	DD	imagerel $unwind$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflate DD imagerel $LN885+81
	DD	imagerel $LN885+2311
	DD	imagerel $chain$4$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$inflate DD imagerel $LN885+2311
	DD	imagerel $LN885+5724
	DD	imagerel $chain$6$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$inflate DD imagerel $LN885+5724
	DD	imagerel $LN885+5744
	DD	imagerel $chain$7$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$inflate DD imagerel $LN885+5744
	DD	imagerel $LN885+5868
	DD	imagerel $chain$8$inflate
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateEnd DD imagerel $LN7
	DD	imagerel $LN7+86
	DD	imagerel $unwind$inflateEnd
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSetDictionary DD imagerel $LN13
	DD	imagerel $LN13+232
	DD	imagerel $unwind$inflateSetDictionary
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSync DD imagerel $LN16
	DD	imagerel $LN16+66
	DD	imagerel $unwind$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateSync DD imagerel $LN16+66
	DD	imagerel $LN16+225
	DD	imagerel $chain$1$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateSync DD imagerel $LN16+225
	DD	imagerel $LN16+252
	DD	imagerel $chain$3$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateSync DD imagerel $LN16+252
	DD	imagerel $LN16+268
	DD	imagerel $chain$4$inflateSync
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateCopy DD imagerel $LN17
	DD	imagerel $LN17+74
	DD	imagerel $unwind$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateCopy DD imagerel $LN17+74
	DD	imagerel $LN17+114
	DD	imagerel $chain$1$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateCopy DD imagerel $LN17+114
	DD	imagerel $LN17+171
	DD	imagerel $chain$2$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateCopy DD imagerel $LN17+171
	DD	imagerel $LN17+190
	DD	imagerel $chain$3$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$inflateCopy DD imagerel $LN17+190
	DD	imagerel $LN17+624
	DD	imagerel $chain$5$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$inflateCopy DD imagerel $LN17+624
	DD	imagerel $LN17+638
	DD	imagerel $chain$6$inflateCopy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset2 DD imagerel $LN14
	DD	imagerel $LN14+34
	DD	imagerel $unwind$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$inflateReset2 DD imagerel $LN14+34
	DD	imagerel $LN14+102
	DD	imagerel $chain$0$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$inflateReset2 DD imagerel $LN14+102
	DD	imagerel $LN14+147
	DD	imagerel $chain$2$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateReset2 DD imagerel $LN14+147
	DD	imagerel $LN14+168
	DD	imagerel $chain$3$inflateReset2
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit2_ DD imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$inflateInit2_ DD imagerel $LN13+63
	DD	imagerel $LN13+167
	DD	imagerel $chain$1$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$inflateInit2_ DD imagerel $LN13+167
	DD	imagerel $LN13+209
	DD	imagerel $chain$3$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$inflateInit2_ DD imagerel $LN13+209
	DD	imagerel $LN13+225
	DD	imagerel $chain$4$inflateInit2_
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$updatewindow DD imagerel updatewindow
	DD	imagerel updatewindow+74
	DD	imagerel $unwind$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$updatewindow DD imagerel updatewindow+74
	DD	imagerel updatewindow+233
	DD	imagerel $chain$0$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$updatewindow DD imagerel updatewindow+233
	DD	imagerel updatewindow+254
	DD	imagerel $chain$1$updatewindow
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$syncsearch DD imagerel syncsearch
	DD	imagerel syncsearch+104
	DD	imagerel $unwind$syncsearch
pdata	ENDS
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
CONST	SEGMENT
??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@ DB 'invalid '
	DB	'code -- missing end-of-block', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$syncsearch DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$updatewindow DD 021H
	DD	imagerel updatewindow
	DD	imagerel updatewindow+74
	DD	imagerel $unwind$updatewindow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$updatewindow DD 020521H
	DD	06e405H
	DD	imagerel updatewindow
	DD	imagerel updatewindow+74
	DD	imagerel $unwind$updatewindow
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$updatewindow DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateInit2_ DD 021H
	DD	imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateInit2_ DD 040021H
	DD	077400H
	DD	065400H
	DD	imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateInit2_ DD 040c21H
	DD	07740cH
	DD	065405H
	DD	imagerel $LN13
	DD	imagerel $LN13+63
	DD	imagerel $unwind$inflateInit2_
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit2_ DD 040a01H
	DD	08340aH
	DD	06006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateReset2 DD 021H
	DD	imagerel $LN14
	DD	imagerel $LN14+34
	DD	imagerel $unwind$inflateReset2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateReset2 DD 020021H
	DD	066400H
	DD	imagerel $LN14
	DD	imagerel $LN14+34
	DD	imagerel $unwind$inflateReset2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$inflateReset2 DD 020521H
	DD	066405H
	DD	imagerel $LN14
	DD	imagerel $LN14+34
	DD	imagerel $unwind$inflateReset2
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset2 DD 060f01H
	DD	08540fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$inflateCopy DD 021H
	DD	imagerel $LN17
	DD	imagerel $LN17+74
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$inflateCopy DD 060021H
	DD	0af400H
	DD	096400H
	DD	085400H
	DD	imagerel $LN17
	DD	imagerel $LN17+74
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateCopy DD 021H
	DD	imagerel $LN17+74
	DD	imagerel $LN17+114
	DD	imagerel $chain$1$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$inflateCopy DD 020521H
	DD	085405H
	DD	imagerel $LN17+74
	DD	imagerel $LN17+114
	DD	imagerel $chain$1$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateCopy DD 040a21H
	DD	0af40aH
	DD	096405H
	DD	imagerel $LN17
	DD	imagerel $LN17+74
	DD	imagerel $unwind$inflateCopy
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCopy DD 040901H
	DD	0e0053209H
	DD	030027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflateSync DD 021H
	DD	imagerel $LN16
	DD	imagerel $LN16+66
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$inflateSync DD 040021H
	DD	085400H
	DD	073400H
	DD	imagerel $LN16
	DD	imagerel $LN16+66
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$inflateSync DD 040a21H
	DD	08540aH
	DD	073405H
	DD	imagerel $LN16
	DD	imagerel $LN16+66
	DD	imagerel $unwind$inflateSync
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSync DD 040a01H
	DD	09640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSetDictionary DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateEnd DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$inflate DD 0a0021H
	DD	0bf400H
	DD	0ce400H
	DD	0d7400H
	DD	0e6400H
	DD	0f3400H
	DD	imagerel $LN885
	DD	imagerel $LN885+81
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$inflate DD 021H
	DD	imagerel $LN885
	DD	imagerel $LN885+81
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$inflate DD 0a0021H
	DD	0bf400H
	DD	0ce400H
	DD	0d7400H
	DD	0e6400H
	DD	0f3400H
	DD	imagerel $LN885
	DD	imagerel $LN885+81
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$inflate DD 0a1921H
	DD	0bf419H
	DD	0ce414H
	DD	0d740fH
	DD	0e640aH
	DD	0f3405H
	DD	imagerel $LN885
	DD	imagerel $LN885+81
	DD	imagerel $unwind$inflate
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate DD 041801H
	DD	0d00ef218H
	DD	0500ac00cH
xdata	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT syncsearch
_TEXT	SEGMENT
have$ = 8
buf$ = 16
len$ = 24
syncsearch PROC						; COMDAT

; 1326 : {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx

; 1327 :     unsigned got;
; 1328 :     unsigned next;
; 1329 : 
; 1330 :     got = *have;

  00005	8b 01		 mov	 eax, DWORD PTR [rcx]

; 1331 :     next = 0;

  00007	33 db		 xor	 ebx, ebx
  00009	45 8b d8	 mov	 r11d, r8d
  0000c	4c 8b d1	 mov	 r10, rcx
  0000f	44 8b cb	 mov	 r9d, ebx

; 1332 :     while (next < len && got < 4) {

  00012	45 85 c0	 test	 r8d, r8d
  00015	74 46		 je	 SHORT $LN12@syncsearch
$LL6@syncsearch:
  00017	83 f8 04	 cmp	 eax, 4
  0001a	73 35		 jae	 SHORT $LN13@syncsearch

; 1333 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  0001c	44 0f b6 02	 movzx	 r8d, BYTE PTR [rdx]
  00020	83 f8 02	 cmp	 eax, 2
  00023	b9 ff 00 00 00	 mov	 ecx, 255		; 000000ffH
  00028	0f 42 cb	 cmovb	 ecx, ebx
  0002b	44 3b c1	 cmp	 r8d, ecx
  0002e	75 04		 jne	 SHORT $LN4@syncsearch

; 1334 :             got++;

  00030	ff c0		 inc	 eax
  00032	eb 12		 jmp	 SHORT $LN1@syncsearch
$LN4@syncsearch:

; 1335 :         else if (buf[next])

  00034	45 84 c0	 test	 r8b, r8b
  00037	74 04		 je	 SHORT $LN2@syncsearch

; 1336 :             got = 0;

  00039	8b c3		 mov	 eax, ebx

; 1337 :         else

  0003b	eb 09		 jmp	 SHORT $LN1@syncsearch
$LN2@syncsearch:

; 1338 :             got = 4 - got;

  0003d	b9 04 00 00 00	 mov	 ecx, 4
  00042	2b c8		 sub	 ecx, eax
  00044	8b c1		 mov	 eax, ecx
$LN1@syncsearch:

; 1339 :         next++;

  00046	41 ff c1	 inc	 r9d
  00049	48 ff c2	 inc	 rdx
  0004c	45 3b cb	 cmp	 r9d, r11d
  0004f	72 c6		 jb	 SHORT $LL6@syncsearch
$LN13@syncsearch:

; 1340 :     }
; 1341 :     *have = got;

  00051	41 89 02	 mov	 DWORD PTR [r10], eax

; 1342 :     return next;

  00054	41 8b c1	 mov	 eax, r9d

; 1343 : }

  00057	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  0005c	c3		 ret	 0
$LN12@syncsearch:
  0005d	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  00062	89 01		 mov	 DWORD PTR [rcx], eax
  00064	41 8b c1	 mov	 eax, r9d
  00067	c3		 ret	 0
syncsearch ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT updatewindow
_TEXT	SEGMENT
strm$ = 48
out$ = 56
updatewindow PROC					; COMDAT

; 361  : {

  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 362  :     struct inflate_state FAR *state;
; 363  :     unsigned copy, dist;
; 364  : 
; 365  :     state = (struct inflate_state FAR *)strm->state;

  00014	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00018	8b f2		 mov	 esi, edx
  0001a	48 8b e9	 mov	 rbp, rcx

; 366  : 
; 367  :     /* if it hasn't been done already, allocate space for the window */
; 368  :     if (state->window == Z_NULL) {

  0001d	48 83 7b 38 00	 cmp	 QWORD PTR [rbx+56], 0
  00022	bf 01 00 00 00	 mov	 edi, 1
  00027	75 21		 jne	 SHORT $LN9@updatewind

; 369  :         state->window = (unsigned char FAR *)
; 370  :                         ZALLOC(strm, 1U << state->wbits,
; 371  :                                sizeof(unsigned char));

  00029	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]
  0002c	8b d7		 mov	 edx, edi
  0002e	44 8b c7	 mov	 r8d, edi
  00031	d3 e2		 shl	 edx, cl
  00033	48 8b 4d 40	 mov	 rcx, QWORD PTR [rbp+64]
  00037	ff 55 30	 call	 QWORD PTR [rbp+48]
  0003a	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 372  :         if (state->window == Z_NULL) return 1;

  0003e	48 85 c0	 test	 rax, rax
  00041	75 07		 jne	 SHORT $LN9@updatewind
  00043	8b c7		 mov	 eax, edi
  00045	e9 9f 00 00 00	 jmp	 $LN11@updatewind
$LN9@updatewind:
  0004a	4c 89 74 24 30	 mov	 QWORD PTR [rsp+48], r14

; 373  :     }
; 374  : 
; 375  :     /* if window not in use yet, initialize */
; 376  :     if (state->wsize == 0) {

  0004f	45 33 f6	 xor	 r14d, r14d
  00052	44 39 73 2c	 cmp	 DWORD PTR [rbx+44], r14d
  00056	75 0c		 jne	 SHORT $LN8@updatewind

; 377  :         state->wsize = 1U << state->wbits;

  00058	8b 4b 28	 mov	 ecx, DWORD PTR [rbx+40]

; 378  :         state->wnext = 0;
; 379  :         state->whave = 0;

  0005b	4c 89 73 30	 mov	 QWORD PTR [rbx+48], r14
  0005f	d3 e7		 shl	 edi, cl
  00061	89 7b 2c	 mov	 DWORD PTR [rbx+44], edi
$LN8@updatewind:

; 380  :     }
; 381  : 
; 382  :     /* copy state->wsize or less output bytes into the circular window */
; 383  :     copy = out - strm->avail_out;

  00064	2b 75 18	 sub	 esi, DWORD PTR [rbp+24]

; 384  :     if (copy >= state->wsize) {

  00067	8b 7b 2c	 mov	 edi, DWORD PTR [rbx+44]

; 385  :         zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);

  0006a	48 8b 55 10	 mov	 rdx, QWORD PTR [rbp+16]
  0006e	3b f7		 cmp	 esi, edi
  00070	72 18		 jb	 SHORT $LN7@updatewind
  00072	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00076	44 8b c7	 mov	 r8d, edi
  00079	48 2b d7	 sub	 rdx, rdi
  0007c	e8 00 00 00 00	 call	 memcpy

; 386  :         state->wnext = 0;
; 387  :         state->whave = state->wsize;

  00081	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  00084	44 89 73 34	 mov	 DWORD PTR [rbx+52], r14d

; 388  :     }
; 389  :     else {

  00088	eb 55		 jmp	 SHORT $LN13@updatewind
$LN7@updatewind:

; 390  :         dist = state->wsize - state->wnext;

  0008a	2b 7b 34	 sub	 edi, DWORD PTR [rbx+52]

; 391  :         if (dist > copy) dist = copy;
; 392  :         zmemcpy(state->window + state->wnext, strm->next_out - copy, dist);

  0008d	8b 4b 34	 mov	 ecx, DWORD PTR [rbx+52]
  00090	8b c6		 mov	 eax, esi
  00092	3b fe		 cmp	 edi, esi
  00094	0f 47 fe	 cmova	 edi, esi
  00097	48 03 4b 38	 add	 rcx, QWORD PTR [rbx+56]
  0009b	48 2b d0	 sub	 rdx, rax
  0009e	44 8b c7	 mov	 r8d, edi
  000a1	e8 00 00 00 00	 call	 memcpy

; 393  :         copy -= dist;

  000a6	2b f7		 sub	 esi, edi

; 394  :         if (copy) {

  000a8	74 1b		 je	 SHORT $LN4@updatewind

; 395  :             zmemcpy(state->window, strm->next_out - copy, copy);

  000aa	48 8b 55 10	 mov	 rdx, QWORD PTR [rbp+16]
  000ae	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  000b2	44 8b c6	 mov	 r8d, esi
  000b5	49 2b d0	 sub	 rdx, r8
  000b8	e8 00 00 00 00	 call	 memcpy

; 396  :             state->wnext = copy;
; 397  :             state->whave = state->wsize;

  000bd	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]
  000c0	89 73 34	 mov	 DWORD PTR [rbx+52], esi

; 398  :         }
; 399  :         else {

  000c3	eb 1a		 jmp	 SHORT $LN13@updatewind
$LN4@updatewind:

; 400  :             state->wnext += dist;

  000c5	01 7b 34	 add	 DWORD PTR [rbx+52], edi

; 401  :             if (state->wnext == state->wsize) state->wnext = 0;

  000c8	8b 43 34	 mov	 eax, DWORD PTR [rbx+52]
  000cb	3b 43 2c	 cmp	 eax, DWORD PTR [rbx+44]
  000ce	41 0f 44 c6	 cmove	 eax, r14d
  000d2	89 43 34	 mov	 DWORD PTR [rbx+52], eax

; 402  :             if (state->whave < state->wsize) state->whave += dist;

  000d5	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]
  000d8	3b 43 2c	 cmp	 eax, DWORD PTR [rbx+44]
  000db	73 05		 jae	 SHORT $LN1@updatewind
  000dd	03 c7		 add	 eax, edi
$LN13@updatewind:
  000df	89 43 30	 mov	 DWORD PTR [rbx+48], eax
$LN1@updatewind:
  000e2	4c 8b 74 24 30	 mov	 r14, QWORD PTR [rsp+48]

; 403  :         }
; 404  :     }
; 405  :     return 0;

  000e7	33 c0		 xor	 eax, eax
$LN11@updatewind:

; 406  : }

  000e9	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000ee	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000f3	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000f8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000fc	5f		 pop	 rdi
  000fd	c3		 ret	 0
updatewindow ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 243  : #ifdef BUILDFIXED
; 244  :     static int virgin = 1;
; 245  :     static code *lenfix, *distfix;
; 246  :     static code fixed[544];
; 247  : 
; 248  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 249  :     if (virgin) {
; 250  :         unsigned sym, bits;
; 251  :         static code *next;
; 252  : 
; 253  :         /* literal/length table */
; 254  :         sym = 0;
; 255  :         while (sym < 144) state->lens[sym++] = 8;
; 256  :         while (sym < 256) state->lens[sym++] = 9;
; 257  :         while (sym < 280) state->lens[sym++] = 7;
; 258  :         while (sym < 288) state->lens[sym++] = 8;
; 259  :         next = fixed;
; 260  :         lenfix = next;
; 261  :         bits = 9;
; 262  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 263  : 
; 264  :         /* distance table */
; 265  :         sym = 0;
; 266  :         while (sym < 32) state->lens[sym++] = 5;
; 267  :         distfix = next;
; 268  :         bits = 5;
; 269  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 270  : 
; 271  :         /* do this just once */
; 272  :         virgin = 0;
; 273  :     }
; 274  : #else /* !BUILDFIXED */
; 275  : #   include "inffixed.h"
; 276  : #endif /* BUILDFIXED */
; 277  :     state->lencode = lenfix;

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9

; 278  :     state->lenbits = 9;

  00007	c7 41 68 09 00
	00 00		 mov	 DWORD PTR [rcx+104], 9

; 279  :     state->distcode = distfix;
; 280  :     state->distbits = 5;

  0000e	c7 41 6c 05 00
	00 00		 mov	 DWORD PTR [rcx+108], 5
  00015	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax
  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  00020	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 281  : }

  00024	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT inflateUndermine
_TEXT	SEGMENT
strm$ = 8
subvert$ = 16
inflateUndermine PROC					; COMDAT

; 1457 :     struct inflate_state FAR *state;
; 1458 : 
; 1459 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 19		 je	 SHORT $LN1@inflateUnd
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 10		 je	 SHORT $LN1@inflateUnd

; 1460 :     state = (struct inflate_state FAR *)strm->state;
; 1461 :     state->sane = !subvert;
; 1462 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1463 :     return Z_OK;
; 1464 : #else
; 1465 :     state->sane = 1;

  0000e	c7 80 d8 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+7128], 1

; 1466 :     return Z_DATA_ERROR;

  00018	b8 fd ff ff ff	 mov	 eax, -3

; 1467 : #endif
; 1468 : }

  0001d	c3		 ret	 0
$LN1@inflateUnd:

; 1457 :     struct inflate_state FAR *state;
; 1458 : 
; 1459 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0001e	b8 fe ff ff ff	 mov	 eax, -2

; 1467 : #endif
; 1468 : }

  00023	c3		 ret	 0
inflateUndermine ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT inflateSyncPoint
_TEXT	SEGMENT
strm$ = 8
inflateSyncPoint PROC					; COMDAT

; 1399 :     struct inflate_state FAR *state;
; 1400 : 
; 1401 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 1d		 je	 SHORT $LN1@inflateSyn
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 14		 je	 SHORT $LN1@inflateSyn

; 1402 :     state = (struct inflate_state FAR *)strm->state;
; 1403 :     return state->mode == STORED && state->bits == 0;

  0000e	83 38 0d	 cmp	 DWORD PTR [rax], 13
  00011	75 0c		 jne	 SHORT $LN5@inflateSyn
  00013	83 78 44 00	 cmp	 DWORD PTR [rax+68], 0
  00017	75 06		 jne	 SHORT $LN5@inflateSyn
  00019	b8 01 00 00 00	 mov	 eax, 1

; 1404 : }

  0001e	c3		 ret	 0
$LN5@inflateSyn:

; 1402 :     state = (struct inflate_state FAR *)strm->state;
; 1403 :     return state->mode == STORED && state->bits == 0;

  0001f	33 c0		 xor	 eax, eax

; 1404 : }

  00021	c3		 ret	 0
$LN1@inflateSyn:

; 1399 :     struct inflate_state FAR *state;
; 1400 : 
; 1401 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00022	b8 fe ff ff ff	 mov	 eax, -2

; 1404 : }

  00027	c3		 ret	 0
inflateSyncPoint ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT inflateInit2_
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
version$ = 64
stream_size$ = 72
inflateInit2_ PROC					; COMDAT

; 173  : {

$LN13:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	56		 push	 rsi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b f2		 mov	 esi, edx
  0000c	48 8b d9	 mov	 rbx, rcx

; 174  :     int ret;
; 175  :     struct inflate_state FAR *state;
; 176  : 
; 177  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 178  :         stream_size != (int)(sizeof(z_stream)))

  0000f	4d 85 c0	 test	 r8, r8
  00012	0f 84 b9 00 00
	00		 je	 $LN6@inflateIni
  00018	41 80 38 31	 cmp	 BYTE PTR [r8], 49	; 00000031H
  0001c	0f 85 af 00 00
	00		 jne	 $LN6@inflateIni
  00022	41 83 f9 58	 cmp	 r9d, 88			; 00000058H
  00026	0f 85 a5 00 00
	00		 jne	 $LN6@inflateIni

; 180  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  0002c	48 85 c9	 test	 rcx, rcx
  0002f	75 0e		 jne	 SHORT $LN5@inflateIni
  00031	8d 41 fe	 lea	 eax, QWORD PTR [rcx-2]

; 199  : }

  00034	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5e		 pop	 rsi
  0003e	c3		 ret	 0
$LN5@inflateIni:
  0003f	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp

; 181  :     strm->msg = Z_NULL;                 /* in case we return an error */

  00044	33 ed		 xor	 ebp, ebp
  00046	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi
  0004b	48 89 69 20	 mov	 QWORD PTR [rcx+32], rbp

; 182  :     if (strm->zalloc == (alloc_func)0) {

  0004f	48 39 69 30	 cmp	 QWORD PTR [rcx+48], rbp
  00053	75 0f		 jne	 SHORT $LN4@inflateIni

; 183  :         strm->zalloc = zcalloc;

  00055	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc

; 184  :         strm->opaque = (voidpf)0;

  0005c	48 89 69 40	 mov	 QWORD PTR [rcx+64], rbp
  00060	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax
$LN4@inflateIni:

; 185  :     }
; 186  :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  00064	48 39 69 38	 cmp	 QWORD PTR [rcx+56], rbp
  00068	75 0b		 jne	 SHORT $LN3@inflateIni
  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcfree
  00071	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN3@inflateIni:

; 187  :     state = (struct inflate_state FAR *)
; 188  :             ZALLOC(strm, 1, sizeof(struct inflate_state));

  00075	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00079	ba 01 00 00 00	 mov	 edx, 1
  0007e	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  00084	ff 53 30	 call	 QWORD PTR [rbx+48]
  00087	48 8b f8	 mov	 rdi, rax

; 189  :     if (state == Z_NULL) return Z_MEM_ERROR;

  0008a	48 85 c0	 test	 rax, rax
  0008d	75 18		 jne	 SHORT $LN2@inflateIni
  0008f	8d 47 fc	 lea	 eax, QWORD PTR [rdi-4]
$LN11@inflateIni:
  00092	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
  00097	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 199  : }

  0009c	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000a1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a5	5e		 pop	 rsi
  000a6	c3		 ret	 0
$LN2@inflateIni:

; 190  :     Tracev((stderr, "inflate: allocated\n"));
; 191  :     strm->state = (struct internal_state FAR *)state;

  000a7	48 89 43 28	 mov	 QWORD PTR [rbx+40], rax

; 192  :     state->window = Z_NULL;
; 193  :     ret = inflateReset2(strm, windowBits);

  000ab	8b d6		 mov	 edx, esi
  000ad	48 8b cb	 mov	 rcx, rbx
  000b0	48 89 68 38	 mov	 QWORD PTR [rax+56], rbp
  000b4	e8 00 00 00 00	 call	 inflateReset2
  000b9	8b f0		 mov	 esi, eax

; 194  :     if (ret != Z_OK) {

  000bb	85 c0		 test	 eax, eax
  000bd	74 0e		 je	 SHORT $LN1@inflateIni

; 195  :         ZFREE(strm, state);

  000bf	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  000c3	48 8b d7	 mov	 rdx, rdi
  000c6	ff 53 38	 call	 QWORD PTR [rbx+56]

; 196  :         strm->state = Z_NULL;

  000c9	48 89 6b 28	 mov	 QWORD PTR [rbx+40], rbp
$LN1@inflateIni:

; 197  :     }
; 198  :     return ret;

  000cd	8b c6		 mov	 eax, esi
  000cf	eb c1		 jmp	 SHORT $LN11@inflateIni
$LN6@inflateIni:

; 179  :         return Z_VERSION_ERROR;

  000d1	b8 fa ff ff ff	 mov	 eax, -6

; 199  : }

  000d6	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000db	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000df	5e		 pop	 rsi
  000e0	c3		 ret	 0
inflateInit2_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT inflateInit_
_TEXT	SEGMENT
strm$ = 8
version$ = 16
stream_size$ = 24
inflateInit_ PROC					; COMDAT

; 206  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00000	45 8b c8	 mov	 r9d, r8d
  00003	4c 8b c2	 mov	 r8, rdx
  00006	ba 0f 00 00 00	 mov	 edx, 15
  0000b	e9 00 00 00 00	 jmp	 inflateInit2_
inflateInit_ ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT inflateGetHeader
_TEXT	SEGMENT
strm$ = 8
head$ = 16
inflateGetHeader PROC					; COMDAT

; 1298 :     struct inflate_state FAR *state;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 1d		 je	 SHORT $LN2@inflateGet
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 14		 je	 SHORT $LN2@inflateGet

; 1302 :     state = (struct inflate_state FAR *)strm->state;
; 1303 :     if ((state->wrap & 2) == 0) return Z_STREAM_ERROR;

  0000e	f6 40 08 02	 test	 BYTE PTR [rax+8], 2
  00012	74 0e		 je	 SHORT $LN2@inflateGet

; 1304 : 
; 1305 :     /* save header structure */
; 1306 :     state->head = head;

  00014	48 89 50 20	 mov	 QWORD PTR [rax+32], rdx

; 1307 :     head->done = 0;

  00018	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [rdx+64], 0

; 1308 :     return Z_OK;

  0001f	33 c0		 xor	 eax, eax

; 1309 : }

  00021	c3		 ret	 0
$LN2@inflateGet:

; 1298 :     struct inflate_state FAR *state;
; 1299 : 
; 1300 :     /* check state */
; 1301 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00022	b8 fe ff ff ff	 mov	 eax, -2

; 1309 : }

  00027	c3		 ret	 0
inflateGetHeader ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT inflateMark
_TEXT	SEGMENT
strm$ = 8
inflateMark PROC					; COMDAT

; 1473 :     struct inflate_state FAR *state;
; 1474 : 
; 1475 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 47		 je	 SHORT $LN1@inflateMar
  00005	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00009	48 85 c0	 test	 rax, rax
  0000c	74 3e		 je	 SHORT $LN1@inflateMar

; 1476 :     state = (struct inflate_state FAR *)strm->state;
; 1477 :     return ((long)(state->back) << 16) +
; 1478 :         (state->mode == COPY ? state->length :
; 1479 :             (state->mode == MATCH ? state->was - state->length : 0));

  0000e	8b 08		 mov	 ecx, DWORD PTR [rax]
  00010	83 f9 0f	 cmp	 ecx, 15
  00013	75 0f		 jne	 SHORT $LN7@inflateMar
  00015	8b 48 48	 mov	 ecx, DWORD PTR [rax+72]
  00018	8b 80 dc 1b 00
	00		 mov	 eax, DWORD PTR [rax+7132]
  0001e	c1 e0 10	 shl	 eax, 16
  00021	03 c1		 add	 eax, ecx

; 1480 : }

  00023	c3		 ret	 0
$LN7@inflateMar:

; 1476 :     state = (struct inflate_state FAR *)strm->state;
; 1477 :     return ((long)(state->back) << 16) +
; 1478 :         (state->mode == COPY ? state->length :
; 1479 :             (state->mode == MATCH ? state->was - state->length : 0));

  00024	83 f9 18	 cmp	 ecx, 24
  00027	75 15		 jne	 SHORT $LN5@inflateMar
  00029	8b 88 e0 1b 00
	00		 mov	 ecx, DWORD PTR [rax+7136]
  0002f	2b 48 48	 sub	 ecx, DWORD PTR [rax+72]
  00032	8b 80 dc 1b 00
	00		 mov	 eax, DWORD PTR [rax+7132]
  00038	c1 e0 10	 shl	 eax, 16
  0003b	03 c1		 add	 eax, ecx

; 1480 : }

  0003d	c3		 ret	 0
$LN5@inflateMar:

; 1476 :     state = (struct inflate_state FAR *)strm->state;
; 1477 :     return ((long)(state->back) << 16) +
; 1478 :         (state->mode == COPY ? state->length :
; 1479 :             (state->mode == MATCH ? state->was - state->length : 0));

  0003e	8b 80 dc 1b 00
	00		 mov	 eax, DWORD PTR [rax+7132]
  00044	33 c9		 xor	 ecx, ecx
  00046	c1 e0 10	 shl	 eax, 16
  00049	03 c1		 add	 eax, ecx

; 1480 : }

  0004b	c3		 ret	 0
$LN1@inflateMar:

; 1473 :     struct inflate_state FAR *state;
; 1474 : 
; 1475 :     if (strm == Z_NULL || strm->state == Z_NULL) return -1L << 16;

  0004c	b8 00 00 ff ff	 mov	 eax, -65536		; ffffffffffff0000H

; 1480 : }

  00051	c3		 ret	 0
inflateMark ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT inflatePrime
_TEXT	SEGMENT
strm$ = 8
bits$ = 16
value$ = 24
inflatePrime PROC					; COMDAT

; 213  : {

  00000	45 8b d8	 mov	 r11d, r8d

; 214  :     struct inflate_state FAR *state;
; 215  : 
; 216  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00003	48 85 c9	 test	 rcx, rcx
  00006	74 45		 je	 SHORT $LN4@inflatePri
  00008	4c 8b 49 28	 mov	 r9, QWORD PTR [rcx+40]
  0000c	4d 85 c9	 test	 r9, r9
  0000f	74 3c		 je	 SHORT $LN4@inflatePri

; 217  :     state = (struct inflate_state FAR *)strm->state;
; 218  :     if (bits < 0) {

  00011	85 d2		 test	 edx, edx
  00013	79 07		 jns	 SHORT $LN3@inflatePri

; 219  :         state->hold = 0;

  00015	33 c0		 xor	 eax, eax
  00017	49 89 41 40	 mov	 QWORD PTR [r9+64], rax

; 228  : }

  0001b	c3		 ret	 0
$LN3@inflatePri:

; 220  :         state->bits = 0;
; 221  :         return Z_OK;
; 222  :     }
; 223  :     if (bits > 16 || state->bits + bits > 32) return Z_STREAM_ERROR;

  0001c	83 fa 10	 cmp	 edx, 16
  0001f	7f 2c		 jg	 SHORT $LN4@inflatePri
  00021	45 8b 41 44	 mov	 r8d, DWORD PTR [r9+68]
  00025	45 8d 14 10	 lea	 r10d, DWORD PTR [r8+rdx]
  00029	41 83 fa 20	 cmp	 r10d, 32		; 00000020H
  0002d	77 1e		 ja	 SHORT $LN4@inflatePri

; 224  :     value &= (1L << bits) - 1;

  0002f	8b ca		 mov	 ecx, edx
  00031	b8 01 00 00 00	 mov	 eax, 1

; 225  :     state->hold += value << state->bits;
; 226  :     state->bits += bits;

  00036	45 89 51 44	 mov	 DWORD PTR [r9+68], r10d
  0003a	d3 e0		 shl	 eax, cl
  0003c	41 8b c8	 mov	 ecx, r8d
  0003f	ff c8		 dec	 eax
  00041	41 23 c3	 and	 eax, r11d
  00044	d3 e0		 shl	 eax, cl
  00046	41 01 41 40	 add	 DWORD PTR [r9+64], eax

; 227  :     return Z_OK;

  0004a	33 c0		 xor	 eax, eax

; 228  : }

  0004c	c3		 ret	 0
$LN4@inflatePri:

; 214  :     struct inflate_state FAR *state;
; 215  : 
; 216  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0004d	b8 fe ff ff ff	 mov	 eax, -2

; 228  : }

  00052	c3		 ret	 0
inflatePrime ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT inflateReset2
_TEXT	SEGMENT
strm$ = 48
windowBits$ = 56
inflateReset2 PROC					; COMDAT

; 133  : {

$LN14:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	8b da		 mov	 ebx, edx
  00011	48 8b e9	 mov	 rbp, rcx

; 134  :     int wrap;
; 135  :     struct inflate_state FAR *state;
; 136  : 
; 137  :     /* get the state */
; 138  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00014	48 85 c9	 test	 rcx, rcx
  00017	74 7a		 je	 SHORT $LN7@inflateRes
  00019	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  0001d	48 85 ff	 test	 rdi, rdi
  00020	74 71		 je	 SHORT $LN7@inflateRes

; 139  :     state = (struct inflate_state FAR *)strm->state;
; 140  : 
; 141  :     /* extract wrap request from windowBits parameter */
; 142  :     if (windowBits < 0) {

  00022	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00027	85 d2		 test	 edx, edx
  00029	79 06		 jns	 SHORT $LN6@inflateRes

; 143  :         wrap = 0;

  0002b	33 f6		 xor	 esi, esi

; 144  :         windowBits = -windowBits;

  0002d	f7 db		 neg	 ebx

; 145  :     }
; 146  :     else {

  0002f	eb 0f		 jmp	 SHORT $LN4@inflateRes
$LN6@inflateRes:

; 147  :         wrap = (windowBits >> 4) + 1;

  00031	8b f2		 mov	 esi, edx
  00033	c1 fe 04	 sar	 esi, 4
  00036	ff c6		 inc	 esi

; 148  : #ifdef GUNZIP
; 149  :         if (windowBits < 48)

  00038	83 fa 30	 cmp	 edx, 48			; 00000030H
  0003b	7d 03		 jge	 SHORT $LN4@inflateRes

; 150  :             windowBits &= 15;

  0003d	83 e3 0f	 and	 ebx, 15
$LN4@inflateRes:
  00040	85 db		 test	 ebx, ebx
  00042	74 22		 je	 SHORT $LN3@inflateRes
  00044	8d 43 f8	 lea	 eax, DWORD PTR [rbx-8]
  00047	83 f8 07	 cmp	 eax, 7
  0004a	76 1a		 jbe	 SHORT $LN3@inflateRes

; 151  : #endif
; 152  :     }
; 153  : 
; 154  :     /* set number of window bits, free window if different */
; 155  :     if (windowBits && (windowBits < 8 || windowBits > 15))
; 156  :         return Z_STREAM_ERROR;

  0004c	b8 fe ff ff ff	 mov	 eax, -2
$LN12@inflateRes:
  00051	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 166  : }

  00056	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0005b	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00060	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
$LN3@inflateRes:

; 157  :     if (state->window != Z_NULL && state->wbits != (unsigned)windowBits) {

  00066	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  0006a	48 85 d2	 test	 rdx, rdx
  0006d	74 14		 je	 SHORT $LN1@inflateRes
  0006f	39 5f 28	 cmp	 DWORD PTR [rdi+40], ebx
  00072	74 0f		 je	 SHORT $LN1@inflateRes

; 158  :         ZFREE(strm, state->window);

  00074	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00078	ff 55 38	 call	 QWORD PTR [rbp+56]

; 159  :         state->window = Z_NULL;

  0007b	48 c7 47 38 00
	00 00 00	 mov	 QWORD PTR [rdi+56], 0
$LN1@inflateRes:

; 160  :     }
; 161  : 
; 162  :     /* update state and reset the rest of it */
; 163  :     state->wrap = wrap;
; 164  :     state->wbits = (unsigned)windowBits;
; 165  :     return inflateReset(strm);

  00083	48 8b cd	 mov	 rcx, rbp
  00086	89 77 08	 mov	 DWORD PTR [rdi+8], esi
  00089	89 5f 28	 mov	 DWORD PTR [rdi+40], ebx
  0008c	e8 00 00 00 00	 call	 inflateReset
  00091	eb be		 jmp	 SHORT $LN12@inflateRes
$LN7@inflateRes:

; 166  : }

  00093	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00098	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0009d	b8 fe ff ff ff	 mov	 eax, -2
  000a2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a6	5f		 pop	 rdi
  000a7	c3		 ret	 0
inflateReset2 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT inflateReset
_TEXT	SEGMENT
strm$ = 8
inflateReset PROC					; COMDAT

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00000	48 85 c9	 test	 rcx, rcx
  00003	74 68		 je	 SHORT $LN1@inflateRes
  00005	48 8b 51 28	 mov	 rdx, QWORD PTR [rcx+40]
  00009	48 85 d2	 test	 rdx, rdx
  0000c	74 5f		 je	 SHORT $LN1@inflateRes

; 109  :     state = (struct inflate_state FAR *)strm->state;
; 110  :     strm->total_in = strm->total_out = state->total = 0;

  0000e	33 c0		 xor	 eax, eax
  00010	89 42 1c	 mov	 DWORD PTR [rdx+28], eax
  00013	89 41 1c	 mov	 DWORD PTR [rcx+28], eax
  00016	89 41 0c	 mov	 DWORD PTR [rcx+12], eax

; 111  :     strm->msg = Z_NULL;

  00019	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 112  :     strm->adler = 1;        /* to support ill-conceived Java test suite */

  0001d	c7 41 4c 01 00
	00 00		 mov	 DWORD PTR [rcx+76], 1

; 113  :     state->mode = HEAD;

  00024	48 89 02	 mov	 QWORD PTR [rdx], rax

; 114  :     state->last = 0;
; 115  :     state->havedict = 0;

  00027	89 42 0c	 mov	 DWORD PTR [rdx+12], eax

; 116  :     state->dmax = 32768U;
; 117  :     state->head = Z_NULL;

  0002a	48 89 42 20	 mov	 QWORD PTR [rdx+32], rax

; 118  :     state->wsize = 0;

  0002e	48 89 42 2c	 mov	 QWORD PTR [rdx+44], rax

; 119  :     state->whave = 0;
; 120  :     state->wnext = 0;

  00032	89 42 34	 mov	 DWORD PTR [rdx+52], eax

; 121  :     state->hold = 0;

  00035	48 89 42 40	 mov	 QWORD PTR [rdx+64], rax

; 122  :     state->bits = 0;
; 123  :     state->lencode = state->distcode = state->next = state->codes;

  00039	48 8d 82 48 05
	00 00		 lea	 rax, QWORD PTR [rdx+1352]
  00040	48 89 82 80 00
	00 00		 mov	 QWORD PTR [rdx+128], rax
  00047	48 89 42 60	 mov	 QWORD PTR [rdx+96], rax
  0004b	48 89 42 58	 mov	 QWORD PTR [rdx+88], rax

; 124  :     state->sane = 1;
; 125  :     state->back = -1;
; 126  :     Tracev((stderr, "inflate: reset\n"));
; 127  :     return Z_OK;

  0004f	33 c0		 xor	 eax, eax
  00051	c7 42 14 00 80
	00 00		 mov	 DWORD PTR [rdx+20], 32768 ; 00008000H
  00058	c7 82 d8 1b 00
	00 01 00 00 00	 mov	 DWORD PTR [rdx+7128], 1
  00062	c7 82 dc 1b 00
	00 ff ff ff ff	 mov	 DWORD PTR [rdx+7132], -1

; 128  : }

  0006c	c3		 ret	 0
$LN1@inflateRes:

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0006d	b8 fe ff ff ff	 mov	 eax, -2

; 128  : }

  00072	c3		 ret	 0
inflateReset ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT inflateCopy
_TEXT	SEGMENT
dest$ = 64
source$ = 72
inflateCopy PROC					; COMDAT

; 1409 : {

$LN17:
  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 56		 push	 r14
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00009	48 8b da	 mov	 rbx, rdx
  0000c	4c 8b f1	 mov	 r14, rcx

; 1410 :     struct inflate_state FAR *state;
; 1411 :     struct inflate_state FAR *copy;
; 1412 :     unsigned char FAR *window;
; 1413 :     unsigned wsize;
; 1414 : 
; 1415 :     /* check input */
; 1416 :     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
; 1417 :         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)

  0000f	48 85 c9	 test	 rcx, rcx
  00012	0f 84 58 02 00
	00		 je	 $LN6@inflateCop
  00018	48 85 d2	 test	 rdx, rdx
  0001b	0f 84 4f 02 00
	00		 je	 $LN6@inflateCop
  00021	48 8b 7a 28	 mov	 rdi, QWORD PTR [rdx+40]
  00025	48 85 ff	 test	 rdi, rdi
  00028	0f 84 42 02 00
	00		 je	 $LN6@inflateCop
  0002e	48 8b 42 30	 mov	 rax, QWORD PTR [rdx+48]
  00032	48 85 c0	 test	 rax, rax
  00035	0f 84 35 02 00
	00		 je	 $LN6@inflateCop
  0003b	48 83 7a 38 00	 cmp	 QWORD PTR [rdx+56], 0
  00040	0f 84 2a 02 00
	00		 je	 $LN6@inflateCop

; 1419 :     state = (struct inflate_state FAR *)source->state;
; 1420 : 
; 1421 :     /* allocate space */
; 1422 :     copy = (struct inflate_state FAR *)
; 1423 :            ZALLOC(source, 1, sizeof(struct inflate_state));

  00046	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0004a	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  0004f	4c 89 7c 24 50	 mov	 QWORD PTR [rsp+80], r15
  00054	41 bf 01 00 00
	00		 mov	 r15d, 1
  0005a	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  00060	41 8b d7	 mov	 edx, r15d
  00063	ff d0		 call	 rax
  00065	48 8b f0	 mov	 rsi, rax

; 1424 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  00068	48 85 c0	 test	 rax, rax
  0006b	75 05		 jne	 SHORT $LN5@inflateCop
  0006d	8d 46 fc	 lea	 eax, QWORD PTR [rsi-4]
  00070	eb 39		 jmp	 SHORT $LN14@inflateCop
$LN5@inflateCop:
  00072	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp

; 1425 :     window = Z_NULL;

  00077	33 ed		 xor	 ebp, ebp

; 1426 :     if (state->window != Z_NULL) {

  00079	48 39 6f 38	 cmp	 QWORD PTR [rdi+56], rbp
  0007d	74 3f		 je	 SHORT $LN3@inflateCop

; 1427 :         window = (unsigned char FAR *)
; 1428 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));

  0007f	8b 4f 28	 mov	 ecx, DWORD PTR [rdi+40]
  00082	41 8b d7	 mov	 edx, r15d
  00085	45 8b c7	 mov	 r8d, r15d
  00088	d3 e2		 shl	 edx, cl
  0008a	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0008e	ff 53 30	 call	 QWORD PTR [rbx+48]
  00091	48 8b e8	 mov	 rbp, rax

; 1429 :         if (window == Z_NULL) {

  00094	48 85 c0	 test	 rax, rax
  00097	75 25		 jne	 SHORT $LN3@inflateCop

; 1430 :             ZFREE(source, copy);

  00099	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  0009d	48 8b d6	 mov	 rdx, rsi
  000a0	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1431 :             return Z_MEM_ERROR;

  000a3	8d 45 fc	 lea	 eax, QWORD PTR [rbp-4]
$LN15@inflateCop:
  000a6	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
$LN14@inflateCop:
  000ab	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000b0	4c 8b 7c 24 50	 mov	 r15, QWORD PTR [rsp+80]

; 1451 : }

  000b5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b9	41 5e		 pop	 r14
  000bb	5f		 pop	 rdi
  000bc	5b		 pop	 rbx
  000bd	c3		 ret	 0
$LN3@inflateCop:

; 1432 :         }
; 1433 :     }
; 1434 : 
; 1435 :     /* copy state */
; 1436 :     zmemcpy(dest, source, sizeof(z_stream));

  000be	48 8b 03	 mov	 rax, QWORD PTR [rbx]

; 1437 :     zmemcpy(copy, state, sizeof(struct inflate_state));

  000c1	48 8b cf	 mov	 rcx, rdi
  000c4	48 8b d6	 mov	 rdx, rsi
  000c7	49 89 06	 mov	 QWORD PTR [r14], rax
  000ca	48 8b 43 08	 mov	 rax, QWORD PTR [rbx+8]
  000ce	48 0b ce	 or	 rcx, rsi
  000d1	49 89 46 08	 mov	 QWORD PTR [r14+8], rax
  000d5	48 8b 43 10	 mov	 rax, QWORD PTR [rbx+16]
  000d9	49 89 46 10	 mov	 QWORD PTR [r14+16], rax
  000dd	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  000e1	49 89 46 18	 mov	 QWORD PTR [r14+24], rax
  000e5	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  000e9	49 89 46 20	 mov	 QWORD PTR [r14+32], rax
  000ed	48 8b 43 28	 mov	 rax, QWORD PTR [rbx+40]
  000f1	49 89 46 28	 mov	 QWORD PTR [r14+40], rax
  000f5	48 8b 43 30	 mov	 rax, QWORD PTR [rbx+48]
  000f9	49 89 46 30	 mov	 QWORD PTR [r14+48], rax
  000fd	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00101	49 89 46 38	 mov	 QWORD PTR [r14+56], rax
  00105	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  00109	49 89 46 40	 mov	 QWORD PTR [r14+64], rax
  0010d	48 8b 43 48	 mov	 rax, QWORD PTR [rbx+72]
  00111	49 89 46 48	 mov	 QWORD PTR [r14+72], rax
  00115	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00119	49 89 46 50	 mov	 QWORD PTR [r14+80], rax
  0011d	48 8b c7	 mov	 rax, rdi
  00120	83 e1 0f	 and	 ecx, 15
  00123	0f 85 91 00 00
	00		 jne	 $LN10@inflateCop
  00129	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  0012e	66 90		 npad	 2
$LL11@inflateCop:
  00130	0f 28 00	 movaps	 xmm0, XMMWORD PTR [rax]
  00133	48 8d 92 80 00
	00 00		 lea	 rdx, QWORD PTR [rdx+128]
  0013a	48 8d 80 80 00
	00 00		 lea	 rax, QWORD PTR [rax+128]
  00141	0f 29 42 80	 movaps	 XMMWORD PTR [rdx-128], xmm0
  00145	0f 28 48 90	 movaps	 xmm1, XMMWORD PTR [rax-112]
  00149	0f 29 4a 90	 movaps	 XMMWORD PTR [rdx-112], xmm1
  0014d	0f 28 40 a0	 movaps	 xmm0, XMMWORD PTR [rax-96]
  00151	0f 29 42 a0	 movaps	 XMMWORD PTR [rdx-96], xmm0
  00155	0f 28 48 b0	 movaps	 xmm1, XMMWORD PTR [rax-80]
  00159	0f 29 4a b0	 movaps	 XMMWORD PTR [rdx-80], xmm1
  0015d	0f 28 40 c0	 movaps	 xmm0, XMMWORD PTR [rax-64]
  00161	0f 29 42 c0	 movaps	 XMMWORD PTR [rdx-64], xmm0
  00165	0f 28 48 d0	 movaps	 xmm1, XMMWORD PTR [rax-48]
  00169	0f 29 4a d0	 movaps	 XMMWORD PTR [rdx-48], xmm1
  0016d	0f 28 40 e0	 movaps	 xmm0, XMMWORD PTR [rax-32]
  00171	0f 29 42 e0	 movaps	 XMMWORD PTR [rdx-32], xmm0
  00175	0f 28 48 f0	 movaps	 xmm1, XMMWORD PTR [rax-16]
  00179	0f 29 4a f0	 movaps	 XMMWORD PTR [rdx-16], xmm1
  0017d	48 ff c9	 dec	 rcx
  00180	75 ae		 jne	 SHORT $LL11@inflateCop
  00182	0f 28 00	 movaps	 xmm0, XMMWORD PTR [rax]
  00185	0f 29 02	 movaps	 XMMWORD PTR [rdx], xmm0
  00188	0f 28 48 10	 movaps	 xmm1, XMMWORD PTR [rax+16]
  0018c	0f 29 4a 10	 movaps	 XMMWORD PTR [rdx+16], xmm1
  00190	0f 28 40 20	 movaps	 xmm0, XMMWORD PTR [rax+32]
  00194	0f 29 42 20	 movaps	 XMMWORD PTR [rdx+32], xmm0
  00198	0f 28 48 30	 movaps	 xmm1, XMMWORD PTR [rax+48]
  0019c	0f 29 4a 30	 movaps	 XMMWORD PTR [rdx+48], xmm1
  001a0	0f 28 40 40	 movaps	 xmm0, XMMWORD PTR [rax+64]
  001a4	0f 29 42 40	 movaps	 XMMWORD PTR [rdx+64], xmm0
  001a8	0f 28 48 50	 movaps	 xmm1, XMMWORD PTR [rax+80]
  001ac	0f 29 4a 50	 movaps	 XMMWORD PTR [rdx+80], xmm1
  001b0	48 8b 48 60	 mov	 rcx, QWORD PTR [rax+96]
  001b4	48 89 4a 60	 mov	 QWORD PTR [rdx+96], rcx
  001b8	eb 11		 jmp	 SHORT $LN12@inflateCop
$LN10@inflateCop:
  001ba	41 b8 e8 1b 00
	00		 mov	 r8d, 7144		; 00001be8H
  001c0	48 8b d7	 mov	 rdx, rdi
  001c3	48 8b ce	 mov	 rcx, rsi
  001c6	e8 00 00 00 00	 call	 memcpy
$LN12@inflateCop:

; 1438 :     if (state->lencode >= state->codes &&
; 1439 :         state->lencode <= state->codes + ENOUGH - 1) {

  001cb	48 8b 4f 58	 mov	 rcx, QWORD PTR [rdi+88]
  001cf	48 8d 87 48 05
	00 00		 lea	 rax, QWORD PTR [rdi+1352]
  001d6	48 3b c8	 cmp	 rcx, rax
  001d9	72 47		 jb	 SHORT $LN2@inflateCop
  001db	48 8d 87 d4 1b
	00 00		 lea	 rax, QWORD PTR [rdi+7124]
  001e2	48 3b c8	 cmp	 rcx, rax
  001e5	77 3b		 ja	 SHORT $LN2@inflateCop

; 1440 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  001e7	48 2b cf	 sub	 rcx, rdi
  001ea	48 8d 81 b8 fa
	ff ff		 lea	 rax, QWORD PTR [rcx-1352]
  001f1	48 c1 f8 02	 sar	 rax, 2
  001f5	48 05 52 01 00
	00		 add	 rax, 338		; 00000152H
  001fb	48 8d 04 86	 lea	 rax, QWORD PTR [rsi+rax*4]
  001ff	48 89 46 58	 mov	 QWORD PTR [rsi+88], rax

; 1441 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  00203	48 8b 47 60	 mov	 rax, QWORD PTR [rdi+96]
  00207	48 2b c7	 sub	 rax, rdi
  0020a	48 2d 48 05 00
	00		 sub	 rax, 1352		; 00000548H
  00210	48 c1 f8 02	 sar	 rax, 2
  00214	48 05 52 01 00
	00		 add	 rax, 338		; 00000152H
  0021a	48 8d 04 86	 lea	 rax, QWORD PTR [rsi+rax*4]
  0021e	48 89 46 60	 mov	 QWORD PTR [rsi+96], rax
$LN2@inflateCop:

; 1442 :     }
; 1443 :     copy->next = copy->codes + (state->next - state->codes);

  00222	48 8b 87 80 00
	00 00		 mov	 rax, QWORD PTR [rdi+128]
  00229	48 2b c7	 sub	 rax, rdi
  0022c	48 2d 48 05 00
	00		 sub	 rax, 1352		; 00000548H
  00232	48 c1 f8 02	 sar	 rax, 2
  00236	48 05 52 01 00
	00		 add	 rax, 338		; 00000152H
  0023c	48 8d 04 86	 lea	 rax, QWORD PTR [rsi+rax*4]
  00240	48 89 86 80 00
	00 00		 mov	 QWORD PTR [rsi+128], rax

; 1444 :     if (window != Z_NULL) {

  00247	48 85 ed	 test	 rbp, rbp
  0024a	74 15		 je	 SHORT $LN1@inflateCop

; 1445 :         wsize = 1U << state->wbits;

  0024c	8b 4f 28	 mov	 ecx, DWORD PTR [rdi+40]

; 1446 :         zmemcpy(window, state->window, wsize);

  0024f	48 8b 57 38	 mov	 rdx, QWORD PTR [rdi+56]
  00253	41 d3 e7	 shl	 r15d, cl
  00256	48 8b cd	 mov	 rcx, rbp
  00259	45 8b c7	 mov	 r8d, r15d
  0025c	e8 00 00 00 00	 call	 memcpy
$LN1@inflateCop:

; 1447 :     }
; 1448 :     copy->window = window;

  00261	48 89 6e 38	 mov	 QWORD PTR [rsi+56], rbp

; 1449 :     dest->state = (struct internal_state FAR *)copy;
; 1450 :     return Z_OK;

  00265	33 c0		 xor	 eax, eax
  00267	49 89 76 28	 mov	 QWORD PTR [r14+40], rsi
  0026b	e9 36 fe ff ff	 jmp	 $LN15@inflateCop
$LN6@inflateCop:

; 1418 :         return Z_STREAM_ERROR;

  00270	b8 fe ff ff ff	 mov	 eax, -2

; 1451 : }

  00275	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00279	41 5e		 pop	 r14
  0027b	5f		 pop	 rdi
  0027c	5b		 pop	 rbx
  0027d	c3		 ret	 0
inflateCopy ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT inflateSync
_TEXT	SEGMENT
buf$ = 48
strm$ = 48
inflateSync PROC					; COMDAT

; 1347 : {

$LN16:
  00000	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f1	 mov	 rsi, rcx

; 1348 :     unsigned len;               /* number of bytes to look at or looked at */
; 1349 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1350 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1351 :     struct inflate_state FAR *state;
; 1352 : 
; 1353 :     /* check parameters */
; 1354 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0000d	48 85 c9	 test	 rcx, rcx
  00010	0f 84 e6 00 00
	00		 je	 $LN6@inflateSyn
  00016	48 8b 79 28	 mov	 rdi, QWORD PTR [rcx+40]
  0001a	48 85 ff	 test	 rdi, rdi
  0001d	0f 84 d9 00 00
	00		 je	 $LN6@inflateSyn

; 1355 :     state = (struct inflate_state FAR *)strm->state;
; 1356 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  00023	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00027	75 16		 jne	 SHORT $LN5@inflateSyn
  00029	83 7f 44 08	 cmp	 DWORD PTR [rdi+68], 8
  0002d	73 10		 jae	 SHORT $LN5@inflateSyn
  0002f	b8 fb ff ff ff	 mov	 eax, -5

; 1386 : }

  00034	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00039	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003d	5f		 pop	 rdi
  0003e	c3		 ret	 0
$LN5@inflateSyn:

; 1357 : 
; 1358 :     /* if first time, start search in bit buffer */
; 1359 :     if (state->mode != SYNC) {

  0003f	83 3f 1f	 cmp	 DWORD PTR [rdi], 31
  00042	48 89 5c 24 38	 mov	 QWORD PTR [rsp+56], rbx
  00047	48 89 6c 24 40	 mov	 QWORD PTR [rsp+64], rbp
  0004c	74 55		 je	 SHORT $LN4@inflateSyn

; 1360 :         state->mode = SYNC;
; 1361 :         state->hold <<= state->bits & 7;

  0004e	8b 57 44	 mov	 edx, DWORD PTR [rdi+68]

; 1362 :         state->bits -= state->bits & 7;
; 1363 :         len = 0;

  00051	45 33 c0	 xor	 r8d, r8d
  00054	c7 07 1f 00 00
	00		 mov	 DWORD PTR [rdi], 31
  0005a	8b ca		 mov	 ecx, edx
  0005c	83 e1 07	 and	 ecx, 7
  0005f	d3 67 40	 shl	 DWORD PTR [rdi+64], cl
  00062	2b d1		 sub	 edx, ecx
  00064	89 57 44	 mov	 DWORD PTR [rdi+68], edx

; 1364 :         while (state->bits >= 8) {

  00067	83 fa 08	 cmp	 edx, 8
  0006a	72 23		 jb	 SHORT $LN2@inflateSyn
  0006c	44 8b 4f 40	 mov	 r9d, DWORD PTR [rdi+64]
$LL3@inflateSyn:

; 1365 :             buf[len++] = (unsigned char)(state->hold);

  00070	0f b6 47 40	 movzx	 eax, BYTE PTR [rdi+64]

; 1366 :             state->hold >>= 8;

  00074	41 c1 e9 08	 shr	 r9d, 8

; 1367 :             state->bits -= 8;

  00078	83 c2 f8	 add	 edx, -8			; fffffff8H
  0007b	42 88 44 04 30	 mov	 BYTE PTR buf$[rsp+r8], al
  00080	41 ff c0	 inc	 r8d
  00083	44 89 4f 40	 mov	 DWORD PTR [rdi+64], r9d
  00087	83 fa 08	 cmp	 edx, 8
  0008a	73 e4		 jae	 SHORT $LL3@inflateSyn
  0008c	89 57 44	 mov	 DWORD PTR [rdi+68], edx
$LN2@inflateSyn:

; 1368 :         }
; 1369 :         state->have = 0;

  0008f	48 8d 4f 7c	 lea	 rcx, QWORD PTR [rdi+124]

; 1370 :         syncsearch(&(state->have), buf, len);

  00093	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  00098	c7 01 00 00 00
	00		 mov	 DWORD PTR [rcx], 0
  0009e	e8 00 00 00 00	 call	 syncsearch
$LN4@inflateSyn:

; 1371 :     }
; 1372 : 
; 1373 :     /* search available input */
; 1374 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000a3	44 8b 46 08	 mov	 r8d, DWORD PTR [rsi+8]
  000a7	48 8b 16	 mov	 rdx, QWORD PTR [rsi]
  000aa	48 8d 4f 7c	 lea	 rcx, QWORD PTR [rdi+124]
  000ae	e8 00 00 00 00	 call	 syncsearch

; 1375 :     strm->avail_in -= len;
; 1376 :     strm->next_in += len;
; 1377 :     strm->total_in += len;

  000b3	01 46 0c	 add	 DWORD PTR [rsi+12], eax
  000b6	29 46 08	 sub	 DWORD PTR [rsi+8], eax
  000b9	8b 6e 0c	 mov	 ebp, DWORD PTR [rsi+12]
  000bc	8b c8		 mov	 ecx, eax
  000be	48 01 0e	 add	 QWORD PTR [rsi], rcx

; 1378 : 
; 1379 :     /* return no joy or set up to restart inflate() on a new block */
; 1380 :     if (state->have != 4) return Z_DATA_ERROR;

  000c1	83 7f 7c 04	 cmp	 DWORD PTR [rdi+124], 4
  000c5	74 1a		 je	 SHORT $LN1@inflateSyn
  000c7	b8 fd ff ff ff	 mov	 eax, -3
$LN14@inflateSyn:
  000cc	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  000d1	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]

; 1386 : }

  000d6	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000db	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000df	5f		 pop	 rdi
  000e0	c3		 ret	 0
$LN1@inflateSyn:

; 1381 :     in = strm->total_in;  out = strm->total_out;

  000e1	8b 5e 1c	 mov	 ebx, DWORD PTR [rsi+28]

; 1382 :     inflateReset(strm);

  000e4	48 8b ce	 mov	 rcx, rsi
  000e7	e8 00 00 00 00	 call	 inflateReset

; 1383 :     strm->total_in = in;  strm->total_out = out;

  000ec	89 6e 0c	 mov	 DWORD PTR [rsi+12], ebp
  000ef	89 5e 1c	 mov	 DWORD PTR [rsi+28], ebx

; 1384 :     state->mode = TYPE;

  000f2	c7 07 0b 00 00
	00		 mov	 DWORD PTR [rdi], 11

; 1385 :     return Z_OK;

  000f8	33 c0		 xor	 eax, eax
  000fa	eb d0		 jmp	 SHORT $LN14@inflateSyn
$LN6@inflateSyn:

; 1348 :     unsigned len;               /* number of bytes to look at or looked at */
; 1349 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1350 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1351 :     struct inflate_state FAR *state;
; 1352 : 
; 1353 :     /* check parameters */
; 1354 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  000fc	b8 fe ff ff ff	 mov	 eax, -2

; 1386 : }

  00101	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00106	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010a	5f		 pop	 rdi
  0010b	c3		 ret	 0
inflateSync ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT inflateSetDictionary
_TEXT	SEGMENT
strm$ = 48
dictionary$ = 56
dictLength$ = 64
inflateSetDictionary PROC				; COMDAT

; 1256 : {

$LN13:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00014	41 8b f0	 mov	 esi, r8d
  00017	48 8b ea	 mov	 rbp, rdx
  0001a	48 8b f9	 mov	 rdi, rcx

; 1257 :     struct inflate_state FAR *state;
; 1258 :     unsigned long id;
; 1259 : 
; 1260 :     /* check state */
; 1261 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0001d	48 85 c9	 test	 rcx, rcx
  00020	74 14		 je	 SHORT $LN7@inflateSet
  00022	48 8b 59 28	 mov	 rbx, QWORD PTR [rcx+40]
  00026	48 85 db	 test	 rbx, rbx
  00029	74 0b		 je	 SHORT $LN7@inflateSet

; 1262 :     state = (struct inflate_state FAR *)strm->state;
; 1263 :     if (state->wrap != 0 && state->mode != DICT)

  0002b	83 7b 08 00	 cmp	 DWORD PTR [rbx+8], 0
  0002f	74 1f		 je	 SHORT $LN6@inflateSet
  00031	83 3b 0a	 cmp	 DWORD PTR [rbx], 10
  00034	74 1f		 je	 SHORT $LN11@inflateSet
$LN7@inflateSet:

; 1257 :     struct inflate_state FAR *state;
; 1258 :     unsigned long id;
; 1259 : 
; 1260 :     /* check state */
; 1261 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00036	b8 fe ff ff ff	 mov	 eax, -2
$LN9@inflateSet:

; 1292 : }

  0003b	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00040	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00045	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
$LN6@inflateSet:

; 1264 :         return Z_STREAM_ERROR;
; 1265 : 
; 1266 :     /* check for correct dictionary id */
; 1267 :     if (state->mode == DICT) {

  00050	83 3b 0a	 cmp	 DWORD PTR [rbx], 10
  00053	75 25		 jne	 SHORT $LN4@inflateSet
$LN11@inflateSet:

; 1268 :         id = adler32(0L, Z_NULL, 0);

  00055	45 33 c0	 xor	 r8d, r8d
  00058	33 d2		 xor	 edx, edx
  0005a	33 c9		 xor	 ecx, ecx
  0005c	e8 00 00 00 00	 call	 adler32

; 1269 :         id = adler32(id, dictionary, dictLength);

  00061	44 8b c6	 mov	 r8d, esi
  00064	48 8b d5	 mov	 rdx, rbp
  00067	8b c8		 mov	 ecx, eax
  00069	e8 00 00 00 00	 call	 adler32

; 1270 :         if (id != state->check)

  0006e	3b 43 18	 cmp	 eax, DWORD PTR [rbx+24]
  00071	74 07		 je	 SHORT $LN4@inflateSet

; 1271 :             return Z_DATA_ERROR;

  00073	b8 fd ff ff ff	 mov	 eax, -3
  00078	eb c1		 jmp	 SHORT $LN9@inflateSet
$LN4@inflateSet:

; 1272 :     }
; 1273 : 
; 1274 :     /* copy dictionary to window */
; 1275 :     if (updatewindow(strm, strm->avail_out)) {

  0007a	8b 57 18	 mov	 edx, DWORD PTR [rdi+24]
  0007d	48 8b cf	 mov	 rcx, rdi
  00080	e8 00 00 00 00	 call	 updatewindow
  00085	85 c0		 test	 eax, eax
  00087	74 0d		 je	 SHORT $LN3@inflateSet

; 1276 :         state->mode = MEM;

  00089	c7 03 1e 00 00
	00		 mov	 DWORD PTR [rbx], 30

; 1277 :         return Z_MEM_ERROR;

  0008f	b8 fc ff ff ff	 mov	 eax, -4
  00094	eb a5		 jmp	 SHORT $LN9@inflateSet
$LN3@inflateSet:

; 1278 :     }
; 1279 :     if (dictLength > state->wsize) {

  00096	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]

; 1280 :         zmemcpy(state->window, dictionary + dictLength - state->wsize,
; 1281 :                 state->wsize);

  00099	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  0009d	3b f0		 cmp	 esi, eax
  0009f	76 25		 jbe	 SHORT $LN2@inflateSet
  000a1	48 8b d6	 mov	 rdx, rsi
  000a4	44 8b c0	 mov	 r8d, eax
  000a7	48 2b d0	 sub	 rdx, rax
  000aa	48 03 d5	 add	 rdx, rbp
  000ad	e8 00 00 00 00	 call	 memcpy

; 1282 :         state->whave = state->wsize;

  000b2	8b 43 2c	 mov	 eax, DWORD PTR [rbx+44]

; 1288 :     }
; 1289 :     state->havedict = 1;

  000b5	c7 43 0c 01 00
	00 00		 mov	 DWORD PTR [rbx+12], 1
  000bc	89 43 30	 mov	 DWORD PTR [rbx+48], eax

; 1290 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1291 :     return Z_OK;

  000bf	33 c0		 xor	 eax, eax
  000c1	e9 75 ff ff ff	 jmp	 $LN9@inflateSet
$LN2@inflateSet:

; 1283 :     }
; 1284 :     else {
; 1285 :         zmemcpy(state->window + state->wsize - dictLength, dictionary,
; 1286 :                 dictLength);

  000c6	48 2b ce	 sub	 rcx, rsi
  000c9	4c 8b c6	 mov	 r8, rsi
  000cc	48 8b d5	 mov	 rdx, rbp
  000cf	48 03 c8	 add	 rcx, rax
  000d2	e8 00 00 00 00	 call	 memcpy

; 1287 :         state->whave = dictLength;

  000d7	89 73 30	 mov	 DWORD PTR [rbx+48], esi

; 1288 :     }
; 1289 :     state->havedict = 1;

  000da	c7 43 0c 01 00
	00 00		 mov	 DWORD PTR [rbx+12], 1

; 1290 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1291 :     return Z_OK;

  000e1	33 c0		 xor	 eax, eax
  000e3	e9 53 ff ff ff	 jmp	 $LN9@inflateSet
inflateSetDictionary ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT inflateEnd
_TEXT	SEGMENT
strm$ = 48
inflateEnd PROC						; COMDAT

; 1240 : {

$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1241 :     struct inflate_state FAR *state;
; 1242 :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 85 c9	 test	 rcx, rcx
  0000c	74 3d		 je	 SHORT $LN2@inflateEnd
  0000e	48 8b 41 28	 mov	 rax, QWORD PTR [rcx+40]
  00012	48 85 c0	 test	 rax, rax
  00015	74 34		 je	 SHORT $LN2@inflateEnd
  00017	4c 8b 41 38	 mov	 r8, QWORD PTR [rcx+56]
  0001b	4d 85 c0	 test	 r8, r8
  0001e	74 2b		 je	 SHORT $LN2@inflateEnd

; 1244 :     state = (struct inflate_state FAR *)strm->state;
; 1245 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  00020	48 8b 50 38	 mov	 rdx, QWORD PTR [rax+56]
  00024	48 85 d2	 test	 rdx, rdx
  00027	74 07		 je	 SHORT $LN1@inflateEnd
  00029	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0002d	41 ff d0	 call	 r8
$LN1@inflateEnd:

; 1246 :     ZFREE(strm, strm->state);

  00030	48 8b 53 28	 mov	 rdx, QWORD PTR [rbx+40]
  00034	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00038	ff 53 38	 call	 QWORD PTR [rbx+56]

; 1247 :     strm->state = Z_NULL;

  0003b	48 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [rbx+40], 0

; 1248 :     Tracev((stderr, "inflate: end\n"));
; 1249 :     return Z_OK;

  00043	33 c0		 xor	 eax, eax

; 1250 : }

  00045	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00049	5b		 pop	 rbx
  0004a	c3		 ret	 0
$LN2@inflateEnd:

; 1243 :         return Z_STREAM_ERROR;

  0004b	b8 fe ff ff ff	 mov	 eax, -2

; 1250 : }

  00050	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00054	5b		 pop	 rbx
  00055	c3		 ret	 0
inflateEnd ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File e:\dev\simpleocr\zlib\inflate.c
;	COMDAT inflate
_TEXT	SEGMENT
hbuf$ = 48
last$ = 52
here$ = 52
out$1$ = 56
in$1$ = 60
put$1$ = 64
strm$ = 160
flush$ = 168
ret$1$ = 176
left$1$ = 184
inflate	PROC						; COMDAT

; 592  : {

$LN885:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	55		 push	 rbp
  0000a	41 54		 push	 r12
  0000c	41 55		 push	 r13
  0000e	48 8b ec	 mov	 rbp, rsp
  00011	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  00018	4c 8b e1	 mov	 r12, rcx

; 593  :     struct inflate_state FAR *state;
; 594  :     unsigned char FAR *next;    /* next input */
; 595  :     unsigned char FAR *put;     /* next output */
; 596  :     unsigned have, left;        /* available input and output */
; 597  :     unsigned long hold;         /* bit buffer */
; 598  :     unsigned bits;              /* bits in bit buffer */
; 599  :     unsigned in, out;           /* save starting available input and output */
; 600  :     unsigned copy;              /* number of stored or match bytes to copy */
; 601  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 602  :     code here;                  /* current decoding table entry */
; 603  :     code last;                  /* parent table entry */
; 604  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 605  :     int ret;                    /* return code */
; 606  : #ifdef GUNZIP
; 607  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 608  : #endif
; 609  :     static const unsigned short order[19] = /* permutation of code lengths */
; 610  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 611  : 
; 612  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
; 613  :         (strm->next_in == Z_NULL && strm->avail_in != 0))

  0001b	48 85 c9	 test	 rcx, rcx
  0001e	0f 84 38 16 00
	00		 je	 $LN506@inflate
  00024	4c 8b 69 28	 mov	 r13, QWORD PTR [rcx+40]
  00028	4d 85 ed	 test	 r13, r13
  0002b	0f 84 2b 16 00
	00		 je	 $LN506@inflate
  00031	48 83 79 10 00	 cmp	 QWORD PTR [rcx+16], 0
  00036	0f 84 20 16 00
	00		 je	 $LN506@inflate
  0003c	48 83 39 00	 cmp	 QWORD PTR [rcx], 0
  00040	75 0a		 jne	 SHORT $LN507@inflate
  00042	83 79 08 00	 cmp	 DWORD PTR [rcx+8], 0
  00046	0f 85 10 16 00
	00		 jne	 $LN506@inflate
$LN507@inflate:

; 615  : 
; 616  :     state = (struct inflate_state FAR *)strm->state;
; 617  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  0004c	41 83 7d 00 0b	 cmp	 DWORD PTR [r13], 11
  00051	48 89 5c 24 78	 mov	 QWORD PTR [rsp+120], rbx
  00056	48 89 74 24 70	 mov	 QWORD PTR [rsp+112], rsi
  0005b	48 89 7c 24 68	 mov	 QWORD PTR [rsp+104], rdi
  00060	4c 89 74 24 60	 mov	 QWORD PTR [rsp+96], r14
  00065	4c 89 7c 24 58	 mov	 QWORD PTR [rsp+88], r15
  0006a	75 08		 jne	 SHORT $LN504@inflate
  0006c	41 c7 45 00 0c
	00 00 00	 mov	 DWORD PTR [r13], 12
$LN504@inflate:

; 618  :     LOAD();

  00074	44 8b 51 18	 mov	 r10d, DWORD PTR [rcx+24]

; 619  :     in = have;
; 620  :     out = left;
; 621  :     ret = Z_OK;
; 622  :     for (;;)
; 623  :         switch (state->mode) {

  00078	41 8b 45 00	 mov	 eax, DWORD PTR [r13]
  0007c	4c 8b 49 10	 mov	 r9, QWORD PTR [rcx+16]
  00080	8b 71 08	 mov	 esi, DWORD PTR [rcx+8]
  00083	4c 8b 31	 mov	 r14, QWORD PTR [rcx]
  00086	45 8b 7d 40	 mov	 r15d, DWORD PTR [r13+64]
  0008a	41 8b 5d 44	 mov	 ebx, DWORD PTR [r13+68]
  0008e	33 ff		 xor	 edi, edi
  00090	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9
  00094	44 89 55 38	 mov	 DWORD PTR left$1$[rbp-128], r10d
  00098	89 75 bc	 mov	 DWORD PTR in$1$[rbp-128], esi
  0009b	45 8b c2	 mov	 r8d, r10d
  0009e	44 89 55 b8	 mov	 DWORD PTR out$1$[rbp-128], r10d
  000a2	89 7d 30	 mov	 DWORD PTR ret$1$[rbp-128], edi
  000a5	83 f8 1e	 cmp	 eax, 30
  000a8	0f 87 a4 15 00
	00		 ja	 $LN11@inflate
$LN882@inflate:
  000ae	4c 8d 1d 00 00
	00 00		 lea	 r11, OFFSET FLAT:__ImageBase
  000b5	48 98		 cdqe
  000b7	41 8b 8c 83 00
	00 00 00	 mov	 ecx, DWORD PTR $LN746@inflate[r11+rax*4]
  000bf	49 03 cb	 add	 rcx, r11
  000c2	ff e1		 jmp	 rcx
$LN497@inflate:

; 624  :         case HEAD:
; 625  :             if (state->wrap == 0) {

  000c4	41 8b 55 08	 mov	 edx, DWORD PTR [r13+8]
  000c8	85 d2		 test	 edx, edx
  000ca	75 0d		 jne	 SHORT $LN495@inflate

; 626  :                 state->mode = TYPEDO;

  000cc	41 c7 45 00 0c
	00 00 00	 mov	 DWORD PTR [r13], 12

; 627  :                 break;

  000d4	e9 28 06 00 00	 jmp	 $LN498@inflate
$LN495@inflate:

; 628  :             }
; 629  :             NEEDBITS(16);

  000d9	83 fb 10	 cmp	 ebx, 16
  000dc	73 22		 jae	 SHORT $LN494@inflate
  000de	66 90		 npad	 2
$LL492@inflate:
  000e0	85 f6		 test	 esi, esi
  000e2	0f 84 98 07 00
	00		 je	 $LN843@inflate
  000e8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  000ec	8b cb		 mov	 ecx, ebx
  000ee	83 c3 08	 add	 ebx, 8
  000f1	d3 e0		 shl	 eax, cl
  000f3	ff ce		 dec	 esi
  000f5	49 ff c6	 inc	 r14
  000f8	44 03 f8	 add	 r15d, eax
  000fb	83 fb 10	 cmp	 ebx, 16
  000fe	72 e0		 jb	 SHORT $LL492@inflate
$LN494@inflate:

; 630  : #ifdef GUNZIP
; 631  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  00100	f6 c2 02	 test	 dl, 2
  00103	74 47		 je	 SHORT $LN486@inflate
  00105	41 81 ff 1f 8b
	00 00		 cmp	 r15d, 35615		; 00008b1fH
  0010c	75 3e		 jne	 SHORT $LN486@inflate

; 632  :                 state->check = crc32(0L, Z_NULL, 0);

  0010e	45 33 c0	 xor	 r8d, r8d
  00111	33 d2		 xor	 edx, edx
  00113	33 c9		 xor	 ecx, ecx
  00115	e8 00 00 00 00	 call	 crc32

; 633  :                 CRC2(state->check, hold);

  0011a	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  0011e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00124	41 89 45 18	 mov	 DWORD PTR [r13+24], eax
  00128	66 44 89 7d b0	 mov	 WORD PTR hbuf$[rbp-128], r15w
  0012d	41 8b 4d 18	 mov	 ecx, DWORD PTR [r13+24]
  00131	e8 00 00 00 00	 call	 crc32

; 634  :                 INITBITS();

  00136	44 8b ff	 mov	 r15d, edi
  00139	8b df		 mov	 ebx, edi
  0013b	41 89 45 18	 mov	 DWORD PTR [r13+24], eax

; 635  :                 state->mode = FLAGS;

  0013f	41 c7 45 00 01
	00 00 00	 mov	 DWORD PTR [r13], 1

; 636  :                 break;

  00147	e9 ad 05 00 00	 jmp	 $LN807@inflate
$LN486@inflate:

; 637  :             }
; 638  :             state->flags = 0;           /* expect zlib header */
; 639  :             if (state->head != Z_NULL)

  0014c	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  00150	41 89 7d 10	 mov	 DWORD PTR [r13+16], edi
  00154	48 85 c0	 test	 rax, rax
  00157	74 07		 je	 SHORT $LN479@inflate

; 640  :                 state->head->done = -1;

  00159	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
$LN479@inflate:

; 641  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
; 642  : #else
; 643  :             if (
; 644  : #endif
; 645  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {

  00160	41 f6 45 08 01	 test	 BYTE PTR [r13+8], 1
  00165	0f 84 c4 00 00
	00		 je	 $LN477@inflate
  0016b	41 0f b6 cf	 movzx	 ecx, r15b
  0016f	41 8b c7	 mov	 eax, r15d
  00172	c1 e8 08	 shr	 eax, 8
  00175	c1 e1 08	 shl	 ecx, 8
  00178	03 c8		 add	 ecx, eax
  0017a	b8 85 10 42 08	 mov	 eax, 138547333		; 08421085H
  0017f	f7 e1		 mul	 ecx
  00181	8b c1		 mov	 eax, ecx
  00183	2b c2		 sub	 eax, edx
  00185	d1 e8		 shr	 eax, 1
  00187	03 c2		 add	 eax, edx
  00189	c1 e8 04	 shr	 eax, 4
  0018c	6b c0 1f	 imul	 eax, 31
  0018f	3b c8		 cmp	 ecx, eax
  00191	0f 85 98 00 00
	00		 jne	 $LN477@inflate

; 649  :             }
; 650  :             if (BITS(4) != Z_DEFLATED) {

  00197	41 8b c7	 mov	 eax, r15d
  0019a	24 0f		 and	 al, 15
  0019c	3c 08		 cmp	 al, 8
  0019e	74 19		 je	 SHORT $LN475@inflate

; 651  :                 strm->msg = (char *)"unknown compression method";

  001a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  001a7	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 652  :                 state->mode = BAD;

  001ac	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 653  :                 break;

  001b4	e9 48 05 00 00	 jmp	 $LN498@inflate
$LN475@inflate:

; 654  :             }
; 655  :             DROPBITS(4);
; 656  :             len = BITS(4) + 8;
; 657  :             if (state->wbits == 0)

  001b9	41 8b 45 28	 mov	 eax, DWORD PTR [r13+40]
  001bd	41 c1 ef 04	 shr	 r15d, 4
  001c1	83 c3 fc	 add	 ebx, -4			; fffffffcH
  001c4	41 8b cf	 mov	 ecx, r15d
  001c7	83 e1 0f	 and	 ecx, 15
  001ca	83 c1 08	 add	 ecx, 8
  001cd	85 c0		 test	 eax, eax
  001cf	75 41		 jne	 SHORT $LN472@inflate

; 658  :                 state->wbits = len;

  001d1	41 89 4d 28	 mov	 DWORD PTR [r13+40], ecx
$LN470@inflate:

; 663  :             }
; 664  :             state->dmax = 1U << len;

  001d5	b8 01 00 00 00	 mov	 eax, 1

; 665  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 666  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  001da	45 33 c0	 xor	 r8d, r8d
  001dd	33 d2		 xor	 edx, edx
  001df	d3 e0		 shl	 eax, cl
  001e1	33 c9		 xor	 ecx, ecx
  001e3	41 89 45 14	 mov	 DWORD PTR [r13+20], eax
  001e7	e8 00 00 00 00	 call	 adler32

; 667  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  001ec	41 c1 ef 08	 shr	 r15d, 8
  001f0	41 f7 d7	 not	 r15d
  001f3	41 89 45 18	 mov	 DWORD PTR [r13+24], eax
  001f7	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
  001fc	41 83 e7 02	 and	 r15d, 2

; 668  :             INITBITS();

  00200	8b df		 mov	 ebx, edi
  00202	41 83 cf 09	 or	 r15d, 9
  00206	45 89 7d 00	 mov	 DWORD PTR [r13], r15d
  0020a	44 8b ff	 mov	 r15d, edi

; 669  :             break;

  0020d	e9 e7 04 00 00	 jmp	 $LN807@inflate
$LN472@inflate:

; 659  :             else if (len > state->wbits) {

  00212	3b c8		 cmp	 ecx, eax
  00214	76 bf		 jbe	 SHORT $LN470@inflate

; 660  :                 strm->msg = (char *)"invalid window size";

  00216	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
  0021d	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 661  :                 state->mode = BAD;

  00222	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 662  :                 break;

  0022a	e9 d2 04 00 00	 jmp	 $LN498@inflate
$LN477@inflate:

; 646  :                 strm->msg = (char *)"incorrect header check";

  0022f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
  00236	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 647  :                 state->mode = BAD;

  0023b	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 648  :                 break;

  00243	e9 b9 04 00 00	 jmp	 $LN498@inflate
$LN465@inflate:

; 670  : #ifdef GUNZIP
; 671  :         case FLAGS:
; 672  :             NEEDBITS(16);

  00248	83 fb 10	 cmp	 ebx, 16
  0024b	73 23		 jae	 SHORT $LN464@inflate
  0024d	0f 1f 00	 npad	 3
$LL462@inflate:
  00250	85 f6		 test	 esi, esi
  00252	0f 84 28 06 00
	00		 je	 $LN843@inflate
  00258	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0025c	8b cb		 mov	 ecx, ebx
  0025e	83 c3 08	 add	 ebx, 8
  00261	d3 e0		 shl	 eax, cl
  00263	ff ce		 dec	 esi
  00265	49 ff c6	 inc	 r14
  00268	44 03 f8	 add	 r15d, eax
  0026b	83 fb 10	 cmp	 ebx, 16
  0026e	72 e0		 jb	 SHORT $LL462@inflate
$LN464@inflate:

; 673  :             state->flags = (int)(hold);

  00270	45 89 7d 10	 mov	 DWORD PTR [r13+16], r15d

; 674  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  00274	41 80 ff 08	 cmp	 r15b, 8
  00278	74 19		 je	 SHORT $LN456@inflate

; 675  :                 strm->msg = (char *)"unknown compression method";

  0027a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  00281	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 676  :                 state->mode = BAD;

  00286	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 677  :                 break;

  0028e	e9 6e 04 00 00	 jmp	 $LN498@inflate
$LN456@inflate:

; 678  :             }
; 679  :             if (state->flags & 0xe000) {

  00293	41 f7 c7 00 e0
	00 00		 test	 r15d, 57344		; 0000e000H
  0029a	74 19		 je	 SHORT $LN455@inflate

; 680  :                 strm->msg = (char *)"unknown header flags set";

  0029c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
  002a3	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 681  :                 state->mode = BAD;

  002a8	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 682  :                 break;

  002b0	e9 4c 04 00 00	 jmp	 $LN498@inflate
$LN455@inflate:

; 683  :             }
; 684  :             if (state->head != Z_NULL)

  002b5	49 8b 4d 20	 mov	 rcx, QWORD PTR [r13+32]
  002b9	48 85 c9	 test	 rcx, rcx
  002bc	74 0b		 je	 SHORT $LN454@inflate

; 685  :                 state->head->text = (int)((hold >> 8) & 1);

  002be	41 8b c7	 mov	 eax, r15d
  002c1	c1 e8 08	 shr	 eax, 8
  002c4	83 e0 01	 and	 eax, 1
  002c7	89 01		 mov	 DWORD PTR [rcx], eax
$LN454@inflate:

; 686  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  002c9	41 f7 45 10 00
	02 00 00	 test	 DWORD PTR [r13+16], 512	; 00000200H
  002d1	74 23		 je	 SHORT $LN450@inflate
  002d3	44 88 7d b0	 mov	 BYTE PTR hbuf$[rbp-128], r15b
  002d7	41 c1 ef 08	 shr	 r15d, 8
  002db	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  002df	44 88 7d b1	 mov	 BYTE PTR hbuf$[rbp-127], r15b
  002e3	41 8b 4d 18	 mov	 ecx, DWORD PTR [r13+24]
  002e7	41 b8 02 00 00
	00		 mov	 r8d, 2
  002ed	e8 00 00 00 00	 call	 crc32
  002f2	41 89 45 18	 mov	 DWORD PTR [r13+24], eax
$LN450@inflate:

; 687  :             INITBITS();

  002f6	44 8b ff	 mov	 r15d, edi
  002f9	8b df		 mov	 ebx, edi

; 688  :             state->mode = TIME;

  002fb	41 c7 45 00 02
	00 00 00	 mov	 DWORD PTR [r13], 2

; 689  :         case TIME:
; 690  :             NEEDBITS(32);

  00303	eb 0b		 jmp	 SHORT $LL442@inflate
$LN445@inflate:
  00305	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00308	73 26		 jae	 SHORT $LN444@inflate
  0030a	66 0f 1f 44 00
	00		 npad	 6
$LL442@inflate:
  00310	85 f6		 test	 esi, esi
  00312	0f 84 68 05 00
	00		 je	 $LN843@inflate
  00318	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0031c	8b cb		 mov	 ecx, ebx
  0031e	83 c3 08	 add	 ebx, 8
  00321	d3 e0		 shl	 eax, cl
  00323	ff ce		 dec	 esi
  00325	49 ff c6	 inc	 r14
  00328	44 03 f8	 add	 r15d, eax
  0032b	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0032e	72 e0		 jb	 SHORT $LL442@inflate
$LN444@inflate:

; 691  :             if (state->head != Z_NULL)

  00330	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  00334	48 85 c0	 test	 rax, rax
  00337	74 04		 je	 SHORT $LN436@inflate

; 692  :                 state->head->time = hold;

  00339	44 89 78 04	 mov	 DWORD PTR [rax+4], r15d
$LN436@inflate:

; 693  :             if (state->flags & 0x0200) CRC4(state->check, hold);

  0033d	41 f7 45 10 00
	02 00 00	 test	 DWORD PTR [r13+16], 512	; 00000200H
  00345	74 35		 je	 SHORT $LN432@inflate
  00347	41 8b c7	 mov	 eax, r15d
  0034a	44 88 7d b0	 mov	 BYTE PTR hbuf$[rbp-128], r15b
  0034e	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  00352	c1 e8 08	 shr	 eax, 8
  00355	41 b8 04 00 00
	00		 mov	 r8d, 4
  0035b	88 45 b1	 mov	 BYTE PTR hbuf$[rbp-127], al
  0035e	41 8b c7	 mov	 eax, r15d
  00361	41 c1 ef 18	 shr	 r15d, 24
  00365	c1 e8 10	 shr	 eax, 16
  00368	44 88 7d b3	 mov	 BYTE PTR hbuf$[rbp-125], r15b
  0036c	88 45 b2	 mov	 BYTE PTR hbuf$[rbp-126], al
  0036f	41 8b 4d 18	 mov	 ecx, DWORD PTR [r13+24]
  00373	e8 00 00 00 00	 call	 crc32
  00378	41 89 45 18	 mov	 DWORD PTR [r13+24], eax
$LN432@inflate:

; 694  :             INITBITS();

  0037c	44 8b ff	 mov	 r15d, edi
  0037f	8b df		 mov	 ebx, edi

; 695  :             state->mode = OS;

  00381	41 c7 45 00 03
	00 00 00	 mov	 DWORD PTR [r13], 3

; 696  :         case OS:
; 697  :             NEEDBITS(16);

  00389	eb 05		 jmp	 SHORT $LL424@inflate
$LN427@inflate:
  0038b	83 fb 10	 cmp	 ebx, 16
  0038e	73 20		 jae	 SHORT $LN426@inflate
$LL424@inflate:
  00390	85 f6		 test	 esi, esi
  00392	0f 84 e8 04 00
	00		 je	 $LN843@inflate
  00398	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0039c	8b cb		 mov	 ecx, ebx
  0039e	83 c3 08	 add	 ebx, 8
  003a1	d3 e0		 shl	 eax, cl
  003a3	ff ce		 dec	 esi
  003a5	49 ff c6	 inc	 r14
  003a8	44 03 f8	 add	 r15d, eax
  003ab	83 fb 10	 cmp	 ebx, 16
  003ae	72 e0		 jb	 SHORT $LL424@inflate
$LN426@inflate:

; 698  :             if (state->head != Z_NULL) {

  003b0	49 8b 4d 20	 mov	 rcx, QWORD PTR [r13+32]
  003b4	48 85 c9	 test	 rcx, rcx
  003b7	74 14		 je	 SHORT $LN418@inflate

; 699  :                 state->head->xflags = (int)(hold & 0xff);

  003b9	41 0f b6 c7	 movzx	 eax, r15b
  003bd	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 700  :                 state->head->os = (int)(hold >> 8);

  003c0	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  003c4	41 8b cf	 mov	 ecx, r15d
  003c7	c1 e9 08	 shr	 ecx, 8
  003ca	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN418@inflate:

; 701  :             }
; 702  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  003cd	41 f7 45 10 00
	02 00 00	 test	 DWORD PTR [r13+16], 512	; 00000200H
  003d5	74 23		 je	 SHORT $LN414@inflate
  003d7	44 88 7d b0	 mov	 BYTE PTR hbuf$[rbp-128], r15b
  003db	41 c1 ef 08	 shr	 r15d, 8
  003df	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  003e3	44 88 7d b1	 mov	 BYTE PTR hbuf$[rbp-127], r15b
  003e7	41 8b 4d 18	 mov	 ecx, DWORD PTR [r13+24]
  003eb	41 b8 02 00 00
	00		 mov	 r8d, 2
  003f1	e8 00 00 00 00	 call	 crc32
  003f6	41 89 45 18	 mov	 DWORD PTR [r13+24], eax
$LN414@inflate:

; 703  :             INITBITS();

  003fa	44 8b ff	 mov	 r15d, edi
  003fd	8b df		 mov	 ebx, edi

; 704  :             state->mode = EXLEN;

  003ff	41 c7 45 00 04
	00 00 00	 mov	 DWORD PTR [r13], 4
$LN410@inflate:

; 705  :         case EXLEN:
; 706  :             if (state->flags & 0x0400) {

  00407	41 f7 45 10 00
	04 00 00	 test	 DWORD PTR [r13+16], 1024 ; 00000400H
  0040f	74 6a		 je	 SHORT $LN409@inflate

; 707  :                 NEEDBITS(16);

  00411	83 fb 10	 cmp	 ebx, 16
  00414	73 20		 jae	 SHORT $LN407@inflate
$LL405@inflate:
  00416	85 f6		 test	 esi, esi
  00418	0f 84 62 04 00
	00		 je	 $LN843@inflate
  0041e	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00422	8b cb		 mov	 ecx, ebx
  00424	83 c3 08	 add	 ebx, 8
  00427	d3 e0		 shl	 eax, cl
  00429	ff ce		 dec	 esi
  0042b	49 ff c6	 inc	 r14
  0042e	44 03 f8	 add	 r15d, eax
  00431	83 fb 10	 cmp	 ebx, 16
  00434	72 e0		 jb	 SHORT $LL405@inflate
$LN407@inflate:

; 708  :                 state->length = (unsigned)(hold);
; 709  :                 if (state->head != Z_NULL)

  00436	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  0043a	45 89 7d 48	 mov	 DWORD PTR [r13+72], r15d
  0043e	48 85 c0	 test	 rax, rax
  00441	74 04		 je	 SHORT $LN399@inflate

; 710  :                     state->head->extra_len = (unsigned)hold;

  00443	44 89 78 18	 mov	 DWORD PTR [rax+24], r15d
$LN399@inflate:

; 711  :                 if (state->flags & 0x0200) CRC2(state->check, hold);

  00447	41 f7 45 10 00
	02 00 00	 test	 DWORD PTR [r13+16], 512	; 00000200H
  0044f	74 23		 je	 SHORT $LN395@inflate
  00451	44 88 7d b0	 mov	 BYTE PTR hbuf$[rbp-128], r15b
  00455	41 c1 ef 08	 shr	 r15d, 8
  00459	48 8d 55 b0	 lea	 rdx, QWORD PTR hbuf$[rbp-128]
  0045d	44 88 7d b1	 mov	 BYTE PTR hbuf$[rbp-127], r15b
  00461	41 8b 4d 18	 mov	 ecx, DWORD PTR [r13+24]
  00465	41 b8 02 00 00
	00		 mov	 r8d, 2
  0046b	e8 00 00 00 00	 call	 crc32
  00470	41 89 45 18	 mov	 DWORD PTR [r13+24], eax
$LN395@inflate:

; 712  :                 INITBITS();

  00474	44 8b ff	 mov	 r15d, edi
  00477	8b df		 mov	 ebx, edi

; 713  :             }
; 714  :             else if (state->head != Z_NULL)

  00479	eb 0d		 jmp	 SHORT $LN390@inflate
$LN409@inflate:
  0047b	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  0047f	48 85 c0	 test	 rax, rax
  00482	74 04		 je	 SHORT $LN390@inflate

; 715  :                 state->head->extra = Z_NULL;

  00484	48 89 78 10	 mov	 QWORD PTR [rax+16], rdi
$LN390@inflate:

; 716  :             state->mode = EXTRA;

  00488	41 c7 45 00 05
	00 00 00	 mov	 DWORD PTR [r13], 5
$LN389@inflate:

; 717  :         case EXTRA:
; 718  :             if (state->flags & 0x0400) {

  00490	41 f7 45 10 00
	04 00 00	 test	 DWORD PTR [r13+16], 1024 ; 00000400H
  00498	74 7b		 je	 SHORT $LN383@inflate

; 719  :                 copy = state->length;

  0049a	41 8b 4d 48	 mov	 ecx, DWORD PTR [r13+72]

; 720  :                 if (copy > have) copy = have;

  0049e	3b ce		 cmp	 ecx, esi
  004a0	8b f9		 mov	 edi, ecx
  004a2	0f 47 fe	 cmova	 edi, esi

; 721  :                 if (copy) {

  004a5	85 ff		 test	 edi, edi
  004a7	74 5f		 je	 SHORT $LN386@inflate

; 722  :                     if (state->head != Z_NULL &&
; 723  :                         state->head->extra != Z_NULL) {

  004a9	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  004ad	48 85 c0	 test	 rax, rax
  004b0	74 2e		 je	 SHORT $LN385@inflate
  004b2	4c 8b 48 10	 mov	 r9, QWORD PTR [rax+16]
  004b6	4d 85 c9	 test	 r9, r9
  004b9	74 25		 je	 SHORT $LN385@inflate

; 724  :                         len = state->head->extra_len - state->length;

  004bb	8b 50 18	 mov	 edx, DWORD PTR [rax+24]
  004be	2b d1		 sub	 edx, ecx

; 725  :                         zmemcpy(state->head->extra + len, next,
; 726  :                                 len + copy > state->head->extra_max ?
; 727  :                                 state->head->extra_max - len : copy);

  004c0	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  004c3	8d 04 17	 lea	 eax, DWORD PTR [rdi+rdx]
  004c6	3b c1		 cmp	 eax, ecx
  004c8	76 04		 jbe	 SHORT $LN510@inflate
  004ca	2b ca		 sub	 ecx, edx
  004cc	eb 02		 jmp	 SHORT $LN511@inflate
$LN510@inflate:
  004ce	8b cf		 mov	 ecx, edi
$LN511@inflate:
  004d0	44 8b c1	 mov	 r8d, ecx
  004d3	8b ca		 mov	 ecx, edx
  004d5	49 8b d6	 mov	 rdx, r14
  004d8	49 03 c9	 add	 rcx, r9
  004db	e8 00 00 00 00	 call	 memcpy
$LN385@inflate:

; 728  :                     }
; 729  :                     if (state->flags & 0x0200)

  004e0	41 f7 45 10 00
	02 00 00	 test	 DWORD PTR [r13+16], 512	; 00000200H
  004e8	74 13		 je	 SHORT $LN384@inflate

; 730  :                         state->check = crc32(state->check, next, copy);

  004ea	41 8b 4d 18	 mov	 ecx, DWORD PTR [r13+24]
  004ee	44 8b c7	 mov	 r8d, edi
  004f1	49 8b d6	 mov	 rdx, r14
  004f4	e8 00 00 00 00	 call	 crc32
  004f9	41 89 45 18	 mov	 DWORD PTR [r13+24], eax
$LN384@inflate:

; 731  :                     have -= copy;
; 732  :                     next += copy;

  004fd	8b c7		 mov	 eax, edi
  004ff	2b f7		 sub	 esi, edi
  00501	4c 03 f0	 add	 r14, rax

; 733  :                     state->length -= copy;

  00504	41 29 7d 48	 sub	 DWORD PTR [r13+72], edi
$LN386@inflate:

; 734  :                 }
; 735  :                 if (state->length) goto inf_leave;

  00508	41 83 7d 48 00	 cmp	 DWORD PTR [r13+72], 0
  0050d	0f 85 6d 03 00
	00		 jne	 $LN843@inflate
  00513	33 ff		 xor	 edi, edi
$LN383@inflate:

; 736  :             }
; 737  :             state->length = 0;

  00515	41 89 7d 48	 mov	 DWORD PTR [r13+72], edi

; 738  :             state->mode = NAME;

  00519	41 c7 45 00 06
	00 00 00	 mov	 DWORD PTR [r13], 6
$LN382@inflate:

; 739  :         case NAME:
; 740  :             if (state->flags & 0x0800) {

  00521	41 f7 45 10 00
	08 00 00	 test	 DWORD PTR [r13+16], 2048 ; 00000800H
  00529	74 7b		 je	 SHORT $LN381@inflate

; 741  :                 if (have == 0) goto inf_leave;

  0052b	85 f6		 test	 esi, esi
  0052d	0f 84 4d 03 00
	00		 je	 $LN843@inflate
  00533	66 66 66 66 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL379@inflate:

; 742  :                 copy = 0;
; 743  :                 do {
; 744  :                     len = (unsigned)(next[copy++]);

  00540	8b c7		 mov	 eax, edi
  00542	ff c7		 inc	 edi
  00544	46 0f b6 24 30	 movzx	 r12d, BYTE PTR [rax+r14]

; 745  :                     if (state->head != Z_NULL &&
; 746  :                             state->head->name != Z_NULL &&
; 747  :                             state->length < state->head->name_max)

  00549	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  0054d	48 85 c0	 test	 rax, rax
  00550	74 1a		 je	 SHORT $LN378@inflate
  00552	48 8b 50 20	 mov	 rdx, QWORD PTR [rax+32]
  00556	48 85 d2	 test	 rdx, rdx
  00559	74 11		 je	 SHORT $LN378@inflate
  0055b	41 8b 4d 48	 mov	 ecx, DWORD PTR [r13+72]
  0055f	3b 48 28	 cmp	 ecx, DWORD PTR [rax+40]
  00562	73 08		 jae	 SHORT $LN378@inflate

; 748  :                         state->head->name[state->length++] = len;

  00564	44 88 24 11	 mov	 BYTE PTR [rcx+rdx], r12b
  00568	41 ff 45 48	 inc	 DWORD PTR [r13+72]
$LN378@inflate:

; 749  :                 } while (len && copy < have);

  0056c	45 85 e4	 test	 r12d, r12d
  0056f	74 04		 je	 SHORT $LN375@inflate
  00571	3b fe		 cmp	 edi, esi
  00573	72 cb		 jb	 SHORT $LL379@inflate
$LN375@inflate:

; 750  :                 if (state->flags & 0x0200)

  00575	41 f7 45 10 00
	02 00 00	 test	 DWORD PTR [r13+16], 512	; 00000200H
  0057d	74 13		 je	 SHORT $LN374@inflate

; 751  :                     state->check = crc32(state->check, next, copy);

  0057f	41 8b 4d 18	 mov	 ecx, DWORD PTR [r13+24]
  00583	44 8b c7	 mov	 r8d, edi
  00586	49 8b d6	 mov	 rdx, r14
  00589	e8 00 00 00 00	 call	 crc32
  0058e	41 89 45 18	 mov	 DWORD PTR [r13+24], eax
$LN374@inflate:

; 752  :                 have -= copy;
; 753  :                 next += copy;

  00592	8b c7		 mov	 eax, edi
  00594	2b f7		 sub	 esi, edi
  00596	4c 03 f0	 add	 r14, rax

; 754  :                 if (len) goto inf_leave;

  00599	45 85 e4	 test	 r12d, r12d
  0059c	0f 85 de 02 00
	00		 jne	 $LN843@inflate

; 755  :             }
; 756  :             else if (state->head != Z_NULL)

  005a2	33 ff		 xor	 edi, edi
  005a4	eb 0d		 jmp	 SHORT $LN371@inflate
$LN381@inflate:
  005a6	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  005aa	48 85 c0	 test	 rax, rax
  005ad	74 04		 je	 SHORT $LN371@inflate

; 757  :                 state->head->name = Z_NULL;

  005af	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
$LN371@inflate:

; 758  :             state->length = 0;

  005b3	41 89 7d 48	 mov	 DWORD PTR [r13+72], edi

; 759  :             state->mode = COMMENT;

  005b7	41 c7 45 00 07
	00 00 00	 mov	 DWORD PTR [r13], 7
$LN370@inflate:

; 760  :         case COMMENT:
; 761  :             if (state->flags & 0x1000) {

  005bf	41 f7 45 10 00
	10 00 00	 test	 DWORD PTR [r13+16], 4096 ; 00001000H
  005c7	74 7d		 je	 SHORT $LN369@inflate

; 762  :                 if (have == 0) goto inf_leave;

  005c9	85 f6		 test	 esi, esi
  005cb	0f 84 af 02 00
	00		 je	 $LN843@inflate
  005d1	66 66 66 66 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL367@inflate:

; 763  :                 copy = 0;
; 764  :                 do {
; 765  :                     len = (unsigned)(next[copy++]);

  005e0	8b c7		 mov	 eax, edi
  005e2	ff c7		 inc	 edi
  005e4	46 0f b6 24 30	 movzx	 r12d, BYTE PTR [rax+r14]

; 766  :                     if (state->head != Z_NULL &&
; 767  :                             state->head->comment != Z_NULL &&
; 768  :                             state->length < state->head->comm_max)

  005e9	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  005ed	48 85 c0	 test	 rax, rax
  005f0	74 1a		 je	 SHORT $LN366@inflate
  005f2	48 8b 50 30	 mov	 rdx, QWORD PTR [rax+48]
  005f6	48 85 d2	 test	 rdx, rdx
  005f9	74 11		 je	 SHORT $LN366@inflate
  005fb	41 8b 4d 48	 mov	 ecx, DWORD PTR [r13+72]
  005ff	3b 48 38	 cmp	 ecx, DWORD PTR [rax+56]
  00602	73 08		 jae	 SHORT $LN366@inflate

; 769  :                         state->head->comment[state->length++] = len;

  00604	44 88 24 11	 mov	 BYTE PTR [rcx+rdx], r12b
  00608	41 ff 45 48	 inc	 DWORD PTR [r13+72]
$LN366@inflate:

; 770  :                 } while (len && copy < have);

  0060c	45 85 e4	 test	 r12d, r12d
  0060f	74 04		 je	 SHORT $LN363@inflate
  00611	3b fe		 cmp	 edi, esi
  00613	72 cb		 jb	 SHORT $LL367@inflate
$LN363@inflate:

; 771  :                 if (state->flags & 0x0200)

  00615	41 f7 45 10 00
	02 00 00	 test	 DWORD PTR [r13+16], 512	; 00000200H
  0061d	74 13		 je	 SHORT $LN362@inflate

; 772  :                     state->check = crc32(state->check, next, copy);

  0061f	41 8b 4d 18	 mov	 ecx, DWORD PTR [r13+24]
  00623	44 8b c7	 mov	 r8d, edi
  00626	49 8b d6	 mov	 rdx, r14
  00629	e8 00 00 00 00	 call	 crc32
  0062e	41 89 45 18	 mov	 DWORD PTR [r13+24], eax
$LN362@inflate:

; 773  :                 have -= copy;
; 774  :                 next += copy;

  00632	8b c7		 mov	 eax, edi
  00634	2b f7		 sub	 esi, edi
  00636	4c 03 f0	 add	 r14, rax

; 775  :                 if (len) goto inf_leave;

  00639	45 85 e4	 test	 r12d, r12d
  0063c	0f 85 3e 02 00
	00		 jne	 $LN843@inflate

; 776  :             }
; 777  :             else if (state->head != Z_NULL)

  00642	33 ff		 xor	 edi, edi
  00644	eb 0d		 jmp	 SHORT $LN359@inflate
$LN369@inflate:
  00646	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  0064a	48 85 c0	 test	 rax, rax
  0064d	74 04		 je	 SHORT $LN359@inflate

; 778  :                 state->head->comment = Z_NULL;

  0064f	48 89 78 30	 mov	 QWORD PTR [rax+48], rdi
$LN359@inflate:
  00653	4c 8b 65 20	 mov	 r12, QWORD PTR strm$[rbp-128]
  00657	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  0065b	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]

; 779  :             state->mode = HCRC;

  0065f	41 c7 45 00 08
	00 00 00	 mov	 DWORD PTR [r13], 8
$LN358@inflate:

; 780  :         case HCRC:
; 781  :             if (state->flags & 0x0200) {

  00667	41 f7 45 10 00
	02 00 00	 test	 DWORD PTR [r13+16], 512	; 00000200H
  0066f	74 4a		 je	 SHORT $LN344@inflate

; 782  :                 NEEDBITS(16);

  00671	83 fb 10	 cmp	 ebx, 16
  00674	73 20		 jae	 SHORT $LN355@inflate
$LL353@inflate:
  00676	85 f6		 test	 esi, esi
  00678	0f 84 02 02 00
	00		 je	 $LN843@inflate
  0067e	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00682	8b cb		 mov	 ecx, ebx
  00684	83 c3 08	 add	 ebx, 8
  00687	d3 e0		 shl	 eax, cl
  00689	ff ce		 dec	 esi
  0068b	49 ff c6	 inc	 r14
  0068e	44 03 f8	 add	 r15d, eax
  00691	83 fb 10	 cmp	 ebx, 16
  00694	72 e0		 jb	 SHORT $LL353@inflate
$LN355@inflate:

; 783  :                 if (hold != (state->check & 0xffff)) {

  00696	41 0f b7 45 18	 movzx	 eax, WORD PTR [r13+24]
  0069b	44 3b f8	 cmp	 r15d, eax
  0069e	74 16		 je	 SHORT $LN346@inflate

; 784  :                     strm->msg = (char *)"header crc mismatch";

  006a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
  006a7	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 785  :                     state->mode = BAD;

  006ac	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 786  :                     break;

  006b4	eb 4b		 jmp	 SHORT $LN498@inflate
$LN346@inflate:

; 787  :                 }
; 788  :                 INITBITS();

  006b6	44 8b ff	 mov	 r15d, edi
  006b9	8b df		 mov	 ebx, edi
$LN344@inflate:

; 789  :             }
; 790  :             if (state->head != Z_NULL) {

  006bb	49 8b 4d 20	 mov	 rcx, QWORD PTR [r13+32]
  006bf	48 85 c9	 test	 rcx, rcx
  006c2	74 18		 je	 SHORT $LN343@inflate

; 791  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  006c4	41 8b 45 10	 mov	 eax, DWORD PTR [r13+16]
  006c8	c1 f8 09	 sar	 eax, 9
  006cb	83 e0 01	 and	 eax, 1
  006ce	89 41 3c	 mov	 DWORD PTR [rcx+60], eax

; 792  :                 state->head->done = 1;

  006d1	49 8b 45 20	 mov	 rax, QWORD PTR [r13+32]
  006d5	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1
$LN343@inflate:

; 793  :             }
; 794  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  006dc	45 33 c0	 xor	 r8d, r8d
  006df	33 d2		 xor	 edx, edx
  006e1	33 c9		 xor	 ecx, ecx
  006e3	e8 00 00 00 00	 call	 crc32
  006e8	41 89 45 18	 mov	 DWORD PTR [r13+24], eax
  006ec	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
$LN881@inflate:

; 1045 :                 state->mode = TYPE;

  006f1	41 c7 45 00 0b
	00 00 00	 mov	 DWORD PTR [r13], 11
$LN807@inflate:
  006f9	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  006fd	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]
$LN498@inflate:

; 619  :     in = have;
; 620  :     out = left;
; 621  :     ret = Z_OK;
; 622  :     for (;;)
; 623  :         switch (state->mode) {

  00701	41 8b 45 00	 mov	 eax, DWORD PTR [r13]
  00705	83 f8 1e	 cmp	 eax, 30
  00708	0f 87 44 0f 00
	00		 ja	 $LN11@inflate
  0070e	44 8b 45 b8	 mov	 r8d, DWORD PTR out$1$[rbp-128]
  00712	8b 55 28	 mov	 edx, DWORD PTR flush$[rbp-128]
  00715	33 ff		 xor	 edi, edi
  00717	e9 92 f9 ff ff	 jmp	 $LN882@inflate
$LN341@inflate:

; 795  :             state->mode = TYPE;
; 796  :             break;
; 797  : #endif
; 798  :         case DICTID:
; 799  :             NEEDBITS(32);

  0071c	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0071f	73 20		 jae	 SHORT $LN340@inflate
$LL338@inflate:
  00721	85 f6		 test	 esi, esi
  00723	0f 84 57 01 00
	00		 je	 $LN843@inflate
  00729	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0072d	8b cb		 mov	 ecx, ebx
  0072f	83 c3 08	 add	 ebx, 8
  00732	d3 e0		 shl	 eax, cl
  00734	ff ce		 dec	 esi
  00736	49 ff c6	 inc	 r14
  00739	44 03 f8	 add	 r15d, eax
  0073c	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0073f	72 e0		 jb	 SHORT $LL338@inflate
$LN340@inflate:

; 800  :             strm->adler = state->check = REVERSE(hold);

  00741	41 8b cf	 mov	 ecx, r15d
  00744	41 8b c7	 mov	 eax, r15d

; 801  :             INITBITS();

  00747	8b df		 mov	 ebx, edi
  00749	c1 e0 10	 shl	 eax, 16
  0074c	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  00752	03 c8		 add	 ecx, eax
  00754	41 8b c7	 mov	 eax, r15d
  00757	41 c1 ef 18	 shr	 r15d, 24
  0075b	c1 e8 08	 shr	 eax, 8
  0075e	c1 e1 08	 shl	 ecx, 8
  00761	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00766	03 c1		 add	 eax, ecx
  00768	41 03 c7	 add	 eax, r15d
  0076b	44 8b ff	 mov	 r15d, edi
  0076e	41 89 45 18	 mov	 DWORD PTR [r13+24], eax
  00772	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax

; 802  :             state->mode = DICT;

  00777	41 c7 45 00 0a
	00 00 00	 mov	 DWORD PTR [r13], 10
$LN329@inflate:

; 803  :         case DICT:
; 804  :             if (state->havedict == 0) {

  0077f	41 83 7d 0c 00	 cmp	 DWORD PTR [r13+12], 0
  00784	0f 84 c5 0d 00
	00		 je	 $LN589@inflate

; 807  :             }
; 808  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  0078a	45 33 c0	 xor	 r8d, r8d
  0078d	33 d2		 xor	 edx, edx
  0078f	33 c9		 xor	 ecx, ecx
  00791	e8 00 00 00 00	 call	 adler32
  00796	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  0079a	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]
  0079e	8b 55 28	 mov	 edx, DWORD PTR flush$[rbp-128]
  007a1	41 89 45 18	 mov	 DWORD PTR [r13+24], eax
  007a5	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax

; 809  :             state->mode = TYPE;

  007aa	41 c7 45 00 0b
	00 00 00	 mov	 DWORD PTR [r13], 11
$LN324@inflate:
  007b2	8d 42 fb	 lea	 eax, DWORD PTR [rdx-5]
  007b5	83 f8 01	 cmp	 eax, 1
  007b8	0f 86 c2 00 00
	00		 jbe	 $LN843@inflate
$LN323@inflate:

; 810  :         case TYPE:
; 811  :             if (flush == Z_BLOCK || flush == Z_TREES) goto inf_leave;
; 812  :         case TYPEDO:
; 813  :             if (state->last) {

  007be	41 83 7d 04 00	 cmp	 DWORD PTR [r13+4], 0
  007c3	74 17		 je	 SHORT $LN316@inflate

; 814  :                 BYTEBITS();

  007c5	8b cb		 mov	 ecx, ebx

; 815  :                 state->mode = CHECK;

  007c7	41 c7 45 00 1a
	00 00 00	 mov	 DWORD PTR [r13], 26
  007cf	83 e1 07	 and	 ecx, 7
  007d2	41 d3 ef	 shr	 r15d, cl
  007d5	2b d9		 sub	 ebx, ecx

; 816  :                 break;

  007d7	e9 25 ff ff ff	 jmp	 $LN498@inflate
$LN316@inflate:

; 817  :             }
; 818  :             NEEDBITS(3);

  007dc	83 fb 03	 cmp	 ebx, 3
  007df	73 20		 jae	 SHORT $LN315@inflate
$LL313@inflate:
  007e1	85 f6		 test	 esi, esi
  007e3	0f 84 97 00 00
	00		 je	 $LN843@inflate
  007e9	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  007ed	8b cb		 mov	 ecx, ebx
  007ef	83 c3 08	 add	 ebx, 8
  007f2	d3 e0		 shl	 eax, cl
  007f4	ff ce		 dec	 esi
  007f6	49 ff c6	 inc	 r14
  007f9	44 03 f8	 add	 r15d, eax
  007fc	83 fb 03	 cmp	 ebx, 3
  007ff	72 e0		 jb	 SHORT $LL313@inflate
$LN315@inflate:

; 819  :             state->last = BITS(1);

  00801	41 8b c7	 mov	 eax, r15d

; 820  :             DROPBITS(1);

  00804	41 d1 ef	 shr	 r15d, 1
  00807	ff cb		 dec	 ebx
  00809	83 e0 01	 and	 eax, 1
  0080c	41 89 45 04	 mov	 DWORD PTR [r13+4], eax

; 821  :             switch (BITS(2)) {

  00810	41 8b c7	 mov	 eax, r15d
  00813	83 e0 03	 and	 eax, 3
  00816	0f 84 eb 00 00
	00		 je	 $LN302@inflate
  0081c	ff c8		 dec	 eax
  0081e	74 40		 je	 SHORT $LN301@inflate
  00820	ff c8		 dec	 eax
  00822	74 28		 je	 SHORT $LN296@inflate
  00824	ff c8		 dec	 eax
  00826	0f 85 e3 00 00
	00		 jne	 $LN294@inflate

; 834  :                     goto inf_leave;
; 835  :                 }
; 836  :                 break;
; 837  :             case 2:                             /* dynamic block */
; 838  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 839  :                         state->last ? " (last)" : ""));
; 840  :                 state->mode = TABLE;
; 841  :                 break;
; 842  :             case 3:
; 843  :                 strm->msg = (char *)"invalid block type";

  0082c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 844  :                 state->mode = BAD;
; 845  :             }
; 846  :             DROPBITS(2);

  00833	41 c1 ef 02	 shr	 r15d, 2
  00837	83 c3 fe	 add	 ebx, -2			; fffffffeH
  0083a	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax
  0083f	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 847  :             break;

  00847	e9 b5 fe ff ff	 jmp	 $LN498@inflate
$LN296@inflate:

; 844  :                 state->mode = BAD;
; 845  :             }
; 846  :             DROPBITS(2);

  0084c	41 c1 ef 02	 shr	 r15d, 2
  00850	41 c7 45 00 10
	00 00 00	 mov	 DWORD PTR [r13], 16
  00858	83 c3 fe	 add	 ebx, -2			; fffffffeH

; 847  :             break;

  0085b	e9 a1 fe ff ff	 jmp	 $LN498@inflate
$LN301@inflate:

; 826  :                 break;
; 827  :             case 1:                             /* fixed block */
; 828  :                 fixedtables(state);

  00860	49 8b cd	 mov	 rcx, r13
  00863	e8 00 00 00 00	 call	 fixedtables

; 829  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 830  :                         state->last ? " (last)" : ""));
; 831  :                 state->mode = LEN_;             /* decode codes */

  00868	41 c7 45 00 13
	00 00 00	 mov	 DWORD PTR [r13], 19

; 832  :                 if (flush == Z_TREES) {

  00870	83 fa 06	 cmp	 edx, 6
  00873	0f 85 96 00 00
	00		 jne	 $LN294@inflate

; 833  :                     DROPBITS(2);

  00879	41 c1 ef 02	 shr	 r15d, 2
  0087d	83 c3 fe	 add	 ebx, -2			; fffffffeH
$LN843@inflate:
  00880	44 8b 65 30	 mov	 r12d, DWORD PTR ret$1$[rbp-128]
$inf_leave$886:

; 1207 :         }
; 1208 : 
; 1209 :     /*
; 1210 :        Return from inflate(), updating the total counts and the check value.
; 1211 :        If there was no progress during the inflate() call, return a buffer
; 1212 :        error.  Call updatewindow() to create and/or update the window state.
; 1213 :        Note: a memory error from inflate() is non-recoverable.
; 1214 :      */
; 1215 :   inf_leave:
; 1216 :     RESTORE();

  00884	48 8b 7d 20	 mov	 rdi, QWORD PTR strm$[rbp-128]
  00888	48 8b 45 c0	 mov	 rax, QWORD PTR put$1$[rbp-128]
  0088c	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
  00890	8b 45 38	 mov	 eax, DWORD PTR left$1$[rbp-128]
  00893	4c 89 37	 mov	 QWORD PTR [rdi], r14
  00896	89 47 18	 mov	 DWORD PTR [rdi+24], eax
  00899	89 77 08	 mov	 DWORD PTR [rdi+8], esi

; 1217 :     if (state->wsize || (state->mode < CHECK && out != strm->avail_out))

  0089c	41 83 7d 2c 00	 cmp	 DWORD PTR [r13+44], 0
  008a1	41 89 5d 44	 mov	 DWORD PTR [r13+68], ebx
  008a5	8b 5d b8	 mov	 ebx, DWORD PTR out$1$[rbp-128]
  008a8	45 89 7d 40	 mov	 DWORD PTR [r13+64], r15d
  008ac	75 14		 jne	 SHORT $LN6@inflate
  008ae	41 83 7d 00 1a	 cmp	 DWORD PTR [r13], 26
  008b3	0f 8d de 0c 00
	00		 jge	 $LN5@inflate
  008b9	3b 5f 18	 cmp	 ebx, DWORD PTR [rdi+24]
  008bc	0f 84 d5 0c 00
	00		 je	 $LN5@inflate
$LN6@inflate:

; 1218 :         if (updatewindow(strm, out)) {

  008c2	8b d3		 mov	 edx, ebx
  008c4	48 8b cf	 mov	 rcx, rdi
  008c7	e8 00 00 00 00	 call	 updatewindow
  008cc	85 c0		 test	 eax, eax
  008ce	0f 84 c3 0c 00
	00		 je	 $LN5@inflate

; 1219 :             state->mode = MEM;

  008d4	41 c7 45 00 1e
	00 00 00	 mov	 DWORD PTR [r13], 30
$LN12@inflate:

; 1220 :             return Z_MEM_ERROR;

  008dc	b8 fc ff ff ff	 mov	 eax, -4
$LN877@inflate:
  008e1	4c 8b 74 24 60	 mov	 r14, QWORD PTR [rsp+96]
  008e6	48 8b 7c 24 68	 mov	 rdi, QWORD PTR [rsp+104]
  008eb	48 8b 74 24 70	 mov	 rsi, QWORD PTR [rsp+112]
  008f0	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  008f5	4c 8b 7c 24 58	 mov	 r15, QWORD PTR [rsp+88]

; 1236 : }

  008fa	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  00901	41 5d		 pop	 r13
  00903	41 5c		 pop	 r12
  00905	5d		 pop	 rbp
  00906	c3		 ret	 0
$LN302@inflate:

; 822  :             case 0:                             /* stored block */
; 823  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 824  :                         state->last ? " (last)" : ""));
; 825  :                 state->mode = STORED;

  00907	41 c7 45 00 0d
	00 00 00	 mov	 DWORD PTR [r13], 13
$LN294@inflate:

; 844  :                 state->mode = BAD;
; 845  :             }
; 846  :             DROPBITS(2);

  0090f	41 c1 ef 02	 shr	 r15d, 2
  00913	83 c3 fe	 add	 ebx, -2			; fffffffeH

; 847  :             break;

  00916	e9 e6 fd ff ff	 jmp	 $LN498@inflate
$LN290@inflate:

; 848  :         case STORED:
; 849  :             BYTEBITS();                         /* go to byte boundary */

  0091b	8b cb		 mov	 ecx, ebx
  0091d	83 e1 07	 and	 ecx, 7
  00920	2b d9		 sub	 ebx, ecx
  00922	41 d3 ef	 shr	 r15d, cl

; 850  :             NEEDBITS(32);

  00925	83 fb 20	 cmp	 ebx, 32			; 00000020H
  00928	73 26		 jae	 SHORT $LN286@inflate
  0092a	66 0f 1f 44 00
	00		 npad	 6
$LL284@inflate:
  00930	85 f6		 test	 esi, esi
  00932	0f 84 48 ff ff
	ff		 je	 $LN843@inflate
  00938	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0093c	8b cb		 mov	 ecx, ebx
  0093e	83 c3 08	 add	 ebx, 8
  00941	d3 e0		 shl	 eax, cl
  00943	ff ce		 dec	 esi
  00945	49 ff c6	 inc	 r14
  00948	44 03 f8	 add	 r15d, eax
  0094b	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0094e	72 e0		 jb	 SHORT $LL284@inflate
$LN286@inflate:

; 851  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  00950	41 8b c7	 mov	 eax, r15d
  00953	41 0f b7 cf	 movzx	 ecx, r15w
  00957	f7 d0		 not	 eax
  00959	c1 e8 10	 shr	 eax, 16
  0095c	3b c8		 cmp	 ecx, eax
  0095e	74 19		 je	 SHORT $LN278@inflate

; 852  :                 strm->msg = (char *)"invalid stored block lengths";

  00960	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  00967	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 853  :                 state->mode = BAD;

  0096c	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 854  :                 break;

  00974	e9 88 fd ff ff	 jmp	 $LN498@inflate
$LN278@inflate:

; 855  :             }
; 856  :             state->length = (unsigned)hold & 0xffff;

  00979	41 89 4d 48	 mov	 DWORD PTR [r13+72], ecx

; 857  :             Tracev((stderr, "inflate:       stored length %u\n",
; 858  :                     state->length));
; 859  :             INITBITS();

  0097d	44 8b ff	 mov	 r15d, edi
  00980	8b df		 mov	 ebx, edi

; 860  :             state->mode = COPY_;

  00982	41 c7 45 00 0e
	00 00 00	 mov	 DWORD PTR [r13], 14

; 861  :             if (flush == Z_TREES) goto inf_leave;

  0098a	83 fa 06	 cmp	 edx, 6
  0098d	0f 84 ed fe ff
	ff		 je	 $LN843@inflate
$LN274@inflate:

; 862  :         case COPY_:
; 863  :             state->mode = COPY;

  00993	41 c7 45 00 0f
	00 00 00	 mov	 DWORD PTR [r13], 15
$LN272@inflate:

; 864  :         case COPY:
; 865  :             copy = state->length;

  0099b	45 8b 65 48	 mov	 r12d, DWORD PTR [r13+72]

; 866  :             if (copy) {

  0099f	45 85 e4	 test	 r12d, r12d
  009a2	74 51		 je	 SHORT $LN271@inflate

; 867  :                 if (copy > have) copy = have;

  009a4	44 3b e6	 cmp	 r12d, esi
  009a7	44 0f 47 e6	 cmova	 r12d, esi

; 868  :                 if (copy > left) copy = left;

  009ab	45 3b e2	 cmp	 r12d, r10d
  009ae	45 0f 47 e2	 cmova	 r12d, r10d

; 869  :                 if (copy == 0) goto inf_leave;

  009b2	45 85 e4	 test	 r12d, r12d
  009b5	0f 84 c5 fe ff
	ff		 je	 $LN843@inflate

; 870  :                 zmemcpy(put, next, copy);

  009bb	45 8b c4	 mov	 r8d, r12d
  009be	49 8b d6	 mov	 rdx, r14
  009c1	49 8b c9	 mov	 rcx, r9
  009c4	41 8b fc	 mov	 edi, r12d
  009c7	e8 00 00 00 00	 call	 memcpy

; 871  :                 have -= copy;
; 872  :                 next += copy;
; 873  :                 left -= copy;

  009cc	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]

; 874  :                 put += copy;

  009d0	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  009d4	45 2b d4	 sub	 r10d, r12d
  009d7	41 2b f4	 sub	 esi, r12d
  009da	4c 03 cf	 add	 r9, rdi
  009dd	4c 03 f7	 add	 r14, rdi

; 875  :                 state->length -= copy;

  009e0	45 29 65 48	 sub	 DWORD PTR [r13+72], r12d

; 876  :                 break;

  009e4	4c 8b 65 20	 mov	 r12, QWORD PTR strm$[rbp-128]
  009e8	44 89 55 38	 mov	 DWORD PTR left$1$[rbp-128], r10d
  009ec	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9
  009f0	e9 0c fd ff ff	 jmp	 $LN498@inflate
$LN271@inflate:

; 877  :             }
; 878  :             Tracev((stderr, "inflate:       stored end\n"));
; 879  :             state->mode = TYPE;
; 880  :             break;

  009f5	4c 8b 65 20	 mov	 r12, QWORD PTR strm$[rbp-128]
  009f9	41 c7 45 00 0b
	00 00 00	 mov	 DWORD PTR [r13], 11
  00a01	e9 fb fc ff ff	 jmp	 $LN498@inflate
$LN266@inflate:

; 881  :         case TABLE:
; 882  :             NEEDBITS(14);

  00a06	83 fb 0e	 cmp	 ebx, 14
  00a09	73 25		 jae	 SHORT $LN265@inflate
  00a0b	0f 1f 44 00 00	 npad	 5
$LL263@inflate:
  00a10	85 f6		 test	 esi, esi
  00a12	0f 84 68 fe ff
	ff		 je	 $LN843@inflate
  00a18	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00a1c	8b cb		 mov	 ecx, ebx
  00a1e	83 c3 08	 add	 ebx, 8
  00a21	d3 e0		 shl	 eax, cl
  00a23	ff ce		 dec	 esi
  00a25	49 ff c6	 inc	 r14
  00a28	44 03 f8	 add	 r15d, eax
  00a2b	83 fb 0e	 cmp	 ebx, 14
  00a2e	72 e0		 jb	 SHORT $LL263@inflate
$LN265@inflate:

; 883  :             state->nlen = BITS(5) + 257;

  00a30	41 8b cf	 mov	 ecx, r15d

; 884  :             DROPBITS(5);

  00a33	41 c1 ef 05	 shr	 r15d, 5

; 885  :             state->ndist = BITS(5) + 1;
; 886  :             DROPBITS(5);
; 887  :             state->ncode = BITS(4) + 4;
; 888  :             DROPBITS(4);

  00a37	83 c3 f2	 add	 ebx, -14		; fffffff2H
  00a3a	41 8b d7	 mov	 edx, r15d
  00a3d	41 c1 ef 05	 shr	 r15d, 5
  00a41	83 e1 1f	 and	 ecx, 31
  00a44	41 8b c7	 mov	 eax, r15d
  00a47	83 e2 1f	 and	 edx, 31
  00a4a	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00a50	83 e0 0f	 and	 eax, 15
  00a53	ff c2		 inc	 edx
  00a55	41 c1 ef 04	 shr	 r15d, 4
  00a59	83 c0 04	 add	 eax, 4
  00a5c	41 89 4d 74	 mov	 DWORD PTR [r13+116], ecx
  00a60	41 89 55 78	 mov	 DWORD PTR [r13+120], edx
  00a64	41 89 45 70	 mov	 DWORD PTR [r13+112], eax

; 889  : #ifndef PKZIP_BUG_WORKAROUND
; 890  :             if (state->nlen > 286 || state->ndist > 30) {

  00a68	81 f9 1e 01 00
	00		 cmp	 ecx, 286		; 0000011eH
  00a6e	0f 87 01 01 00
	00		 ja	 $LN247@inflate
  00a74	83 fa 1e	 cmp	 edx, 30
  00a77	0f 87 f8 00 00
	00		 ja	 $LN247@inflate

; 894  :             }
; 895  : #endif
; 896  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 897  :             state->have = 0;

  00a7d	41 89 7d 7c	 mov	 DWORD PTR [r13+124], edi

; 898  :             state->mode = LENLENS;

  00a81	41 c7 45 00 11
	00 00 00	 mov	 DWORD PTR [r13], 17
$LN533@inflate:

; 899  :         case LENLENS:
; 900  :             while (state->have < state->ncode) {

  00a89	41 8b 45 70	 mov	 eax, DWORD PTR [r13+112]
  00a8d	41 39 45 7c	 cmp	 DWORD PTR [r13+124], eax
  00a91	73 58		 jae	 SHORT $LN535@inflate
$LL245@inflate:

; 901  :                 NEEDBITS(3);

  00a93	83 fb 03	 cmp	 ebx, 3
  00a96	73 20		 jae	 SHORT $LN242@inflate
$LL240@inflate:
  00a98	85 f6		 test	 esi, esi
  00a9a	0f 84 e0 fd ff
	ff		 je	 $LN843@inflate
  00aa0	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00aa4	8b cb		 mov	 ecx, ebx
  00aa6	83 c3 08	 add	 ebx, 8
  00aa9	d3 e0		 shl	 eax, cl
  00aab	ff ce		 dec	 esi
  00aad	49 ff c6	 inc	 r14
  00ab0	44 03 f8	 add	 r15d, eax
  00ab3	83 fb 03	 cmp	 ebx, 3
  00ab6	72 e0		 jb	 SHORT $LL240@inflate
$LN242@inflate:

; 902  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00ab8	41 8b 45 7c	 mov	 eax, DWORD PTR [r13+124]
  00abc	41 0f b7 cf	 movzx	 ecx, r15w

; 903  :                 DROPBITS(3);

  00ac0	83 c3 fd	 add	 ebx, -3			; fffffffdH
  00ac3	41 0f b7 84 43
	00 00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[r11+rax*2]
  00acc	66 83 e1 07	 and	 cx, 7
  00ad0	41 c1 ef 03	 shr	 r15d, 3
  00ad4	66 41 89 8c 45
	88 00 00 00	 mov	 WORD PTR [r13+rax*2+136], cx
  00add	41 ff 45 7c	 inc	 DWORD PTR [r13+124]
  00ae1	41 8b 45 7c	 mov	 eax, DWORD PTR [r13+124]
  00ae5	41 3b 45 70	 cmp	 eax, DWORD PTR [r13+112]
  00ae9	72 a8		 jb	 SHORT $LL245@inflate
$LN535@inflate:

; 904  :             }
; 905  :             while (state->have < 19)

  00aeb	41 83 7d 7c 13	 cmp	 DWORD PTR [r13+124], 19
  00af0	73 21		 jae	 SHORT $LN230@inflate
$LL231@inflate:

; 906  :                 state->lens[order[state->have++]] = 0;

  00af2	41 8b 45 7c	 mov	 eax, DWORD PTR [r13+124]
  00af6	41 0f b7 84 43
	00 00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[r11+rax*2]
  00aff	66 41 89 bc 45
	88 00 00 00	 mov	 WORD PTR [r13+rax*2+136], di
  00b08	41 ff 45 7c	 inc	 DWORD PTR [r13+124]
  00b0c	41 83 7d 7c 13	 cmp	 DWORD PTR [r13+124], 19
  00b11	72 df		 jb	 SHORT $LL231@inflate
$LN230@inflate:

; 907  :             state->next = state->codes;
; 908  :             state->lencode = (code const FAR *)(state->next);
; 909  :             state->lenbits = 7;

  00b13	49 8d 4d 68	 lea	 rcx, QWORD PTR [r13+104]
  00b17	49 8d 85 48 05
	00 00		 lea	 rax, QWORD PTR [r13+1352]
  00b1e	4d 8d 8d 80 00
	00 00		 lea	 r9, QWORD PTR [r13+128]
  00b25	49 89 01	 mov	 QWORD PTR [r9], rax
  00b28	49 89 45 58	 mov	 QWORD PTR [r13+88], rax

; 910  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 911  :                                 &(state->lenbits), state->work);

  00b2c	49 8d 85 08 03
	00 00		 lea	 rax, QWORD PTR [r13+776]
  00b33	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  00b38	c7 01 07 00 00
	00		 mov	 DWORD PTR [rcx], 7
  00b3e	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00b43	33 c9		 xor	 ecx, ecx
  00b45	49 8d 95 88 00
	00 00		 lea	 rdx, QWORD PTR [r13+136]
  00b4c	44 8d 41 13	 lea	 r8d, QWORD PTR [rcx+19]
  00b50	e8 00 00 00 00	 call	 inflate_table
  00b55	89 45 30	 mov	 DWORD PTR ret$1$[rbp-128], eax

; 912  :             if (ret) {

  00b58	85 c0		 test	 eax, eax
  00b5a	74 32		 je	 SHORT $LN229@inflate

; 913  :                 strm->msg = (char *)"invalid code lengths set";

  00b5c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
  00b63	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 914  :                 state->mode = BAD;

  00b68	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 915  :                 break;

  00b70	e9 84 fb ff ff	 jmp	 $LN807@inflate
$LN247@inflate:

; 891  :                 strm->msg = (char *)"too many length or distance symbols";

  00b75	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
  00b7c	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 892  :                 state->mode = BAD;

  00b81	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 893  :                 break;

  00b89	e9 73 fb ff ff	 jmp	 $LN498@inflate
$LN229@inflate:

; 916  :             }
; 917  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 918  :             state->have = 0;

  00b8e	41 89 7d 7c	 mov	 DWORD PTR [r13+124], edi

; 919  :             state->mode = CODELENS;

  00b92	41 c7 45 00 12
	00 00 00	 mov	 DWORD PTR [r13], 18
$LN536@inflate:

; 920  :         case CODELENS:
; 921  :             while (state->have < state->nlen + state->ndist) {

  00b9a	41 8b 45 78	 mov	 eax, DWORD PTR [r13+120]
  00b9e	45 8b 55 7c	 mov	 r10d, DWORD PTR [r13+124]
  00ba2	41 03 45 74	 add	 eax, DWORD PTR [r13+116]
  00ba6	44 3b d0	 cmp	 r10d, eax
  00ba9	0f 83 0b 02 00
	00		 jae	 $LN226@inflate
  00baf	90		 npad	 1
$LL227@inflate:

; 922  :                 for (;;) {
; 923  :                     here = state->lencode[BITS(state->lenbits)];

  00bb0	41 8b 4d 68	 mov	 ecx, DWORD PTR [r13+104]
  00bb4	4d 8b 45 58	 mov	 r8, QWORD PTR [r13+88]
  00bb8	ba 01 00 00 00	 mov	 edx, 1
  00bbd	d3 e2		 shl	 edx, cl
  00bbf	41 8b c7	 mov	 eax, r15d
  00bc2	ff ca		 dec	 edx
  00bc4	48 23 c2	 and	 rax, rdx
  00bc7	41 8b 04 80	 mov	 eax, DWORD PTR [r8+rax*4]

; 924  :                     if ((unsigned)(here.bits) <= bits) break;

  00bcb	8b c8		 mov	 ecx, eax
  00bcd	89 45 b4	 mov	 DWORD PTR here$[rbp-128], eax
  00bd0	c1 e9 08	 shr	 ecx, 8
  00bd3	0f b6 c9	 movzx	 ecx, cl
  00bd6	3b cb		 cmp	 ecx, ebx
  00bd8	76 3a		 jbe	 SHORT $LN564@inflate
  00bda	66 0f 1f 44 00
	00		 npad	 6
$LL225@inflate:

; 925  :                     PULLBYTE();

  00be0	85 f6		 test	 esi, esi
  00be2	0f 84 98 fc ff
	ff		 je	 $LN843@inflate
  00be8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00bec	8b cb		 mov	 ecx, ebx
  00bee	83 c3 08	 add	 ebx, 8
  00bf1	d3 e0		 shl	 eax, cl
  00bf3	ff ce		 dec	 esi
  00bf5	49 ff c6	 inc	 r14
  00bf8	44 03 f8	 add	 r15d, eax
  00bfb	41 8b c7	 mov	 eax, r15d
  00bfe	48 23 c2	 and	 rax, rdx
  00c01	41 8b 04 80	 mov	 eax, DWORD PTR [r8+rax*4]
  00c05	8b c8		 mov	 ecx, eax
  00c07	89 45 b4	 mov	 DWORD PTR here$[rbp-128], eax
  00c0a	c1 e9 08	 shr	 ecx, 8
  00c0d	0f b6 c9	 movzx	 ecx, cl
  00c10	3b cb		 cmp	 ecx, ebx
  00c12	77 cc		 ja	 SHORT $LL225@inflate
$LN564@inflate:

; 926  :                 }
; 927  :                 if (here.val < 16) {

  00c14	8b c8		 mov	 ecx, eax
  00c16	c1 e9 10	 shr	 ecx, 16
  00c19	66 83 f9 10	 cmp	 cx, 16
  00c1d	73 52		 jae	 SHORT $LN218@inflate

; 928  :                     NEEDBITS(here.bits);

  00c1f	c1 e8 08	 shr	 eax, 8
  00c22	0f b6 d0	 movzx	 edx, al
  00c25	3b da		 cmp	 ebx, edx
  00c27	73 26		 jae	 SHORT $LN216@inflate
  00c29	0f 1f 80 00 00
	00 00		 npad	 7
$LL214@inflate:
  00c30	85 f6		 test	 esi, esi
  00c32	0f 84 48 fc ff
	ff		 je	 $LN843@inflate
  00c38	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00c3c	8b cb		 mov	 ecx, ebx
  00c3e	83 c3 08	 add	 ebx, 8
  00c41	d3 e0		 shl	 eax, cl
  00c43	ff ce		 dec	 esi
  00c45	49 ff c6	 inc	 r14
  00c48	44 03 f8	 add	 r15d, eax
  00c4b	3b da		 cmp	 ebx, edx
  00c4d	72 e1		 jb	 SHORT $LL214@inflate
$LN216@inflate:

; 929  :                     DROPBITS(here.bits);

  00c4f	0f b6 4d b5	 movzx	 ecx, BYTE PTR here$[rbp-127]

; 930  :                     state->lens[state->have++] = here.val;

  00c53	0f b7 45 b6	 movzx	 eax, WORD PTR here$[rbp-126]
  00c57	41 d3 ef	 shr	 r15d, cl
  00c5a	2b d9		 sub	 ebx, ecx
  00c5c	41 8b ca	 mov	 ecx, r10d
  00c5f	66 41 89 84 4d
	88 00 00 00	 mov	 WORD PTR [r13+rcx*2+136], ax
  00c68	41 ff 45 7c	 inc	 DWORD PTR [r13+124]

; 931  :                 }
; 932  :                 else {

  00c6c	e9 34 01 00 00	 jmp	 $LN614@inflate
$LN218@inflate:

; 933  :                     if (here.val == 16) {

  00c71	0f b7 45 b6	 movzx	 eax, WORD PTR here$[rbp-126]
  00c75	66 83 f8 10	 cmp	 ax, 16
  00c79	75 60		 jne	 SHORT $LN204@inflate

; 934  :                         NEEDBITS(here.bits + 2);

  00c7b	44 0f b6 45 b5	 movzx	 r8d, BYTE PTR here$[rbp-127]
  00c80	41 8d 50 02	 lea	 edx, DWORD PTR [r8+2]
  00c84	3b da		 cmp	 ebx, edx
  00c86	73 1f		 jae	 SHORT $LN202@inflate
$LL200@inflate:
  00c88	85 f6		 test	 esi, esi
  00c8a	0f 84 f0 fb ff
	ff		 je	 $LN843@inflate
  00c90	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00c94	8b cb		 mov	 ecx, ebx
  00c96	83 c3 08	 add	 ebx, 8
  00c99	d3 e0		 shl	 eax, cl
  00c9b	ff ce		 dec	 esi
  00c9d	49 ff c6	 inc	 r14
  00ca0	44 03 f8	 add	 r15d, eax
  00ca3	3b da		 cmp	 ebx, edx
  00ca5	72 e1		 jb	 SHORT $LL200@inflate
$LN202@inflate:

; 935  :                         DROPBITS(here.bits);

  00ca7	41 8b c8	 mov	 ecx, r8d
  00caa	41 2b d8	 sub	 ebx, r8d
  00cad	41 d3 ef	 shr	 r15d, cl

; 936  :                         if (state->have == 0) {

  00cb0	45 85 d2	 test	 r10d, r10d
  00cb3	0f 84 30 01 00
	00		 je	 $LN570@inflate

; 940  :                         }
; 941  :                         len = state->lens[state->have - 1];
; 942  :                         copy = 3 + BITS(2);

  00cb9	41 8b d7	 mov	 edx, r15d
  00cbc	41 8d 42 ff	 lea	 eax, DWORD PTR [r10-1]

; 943  :                         DROPBITS(2);

  00cc0	41 c1 ef 02	 shr	 r15d, 2
  00cc4	45 0f b7 84 45
	88 00 00 00	 movzx	 r8d, WORD PTR [r13+rax*2+136]
  00ccd	83 e2 03	 and	 edx, 3
  00cd0	83 c2 03	 add	 edx, 3
  00cd3	83 c3 fe	 add	 ebx, -2			; fffffffeH

; 944  :                     }
; 945  :                     else if (here.val == 17) {

  00cd6	e9 95 00 00 00	 jmp	 $LN155@inflate
$LN204@inflate:
  00cdb	44 0f b6 4d b5	 movzx	 r9d, BYTE PTR here$[rbp-127]
  00ce0	66 83 f8 11	 cmp	 ax, 17
  00ce4	75 43		 jne	 SHORT $LN169@inflate

; 946  :                         NEEDBITS(here.bits + 3);

  00ce6	41 8d 51 03	 lea	 edx, DWORD PTR [r9+3]
  00cea	3b da		 cmp	 ebx, edx
  00cec	73 21		 jae	 SHORT $LN184@inflate
  00cee	66 90		 npad	 2
$LL182@inflate:
  00cf0	85 f6		 test	 esi, esi
  00cf2	0f 84 88 fb ff
	ff		 je	 $LN843@inflate
  00cf8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00cfc	8b cb		 mov	 ecx, ebx
  00cfe	83 c3 08	 add	 ebx, 8
  00d01	d3 e0		 shl	 eax, cl
  00d03	ff ce		 dec	 esi
  00d05	49 ff c6	 inc	 r14
  00d08	44 03 f8	 add	 r15d, eax
  00d0b	3b da		 cmp	 ebx, edx
  00d0d	72 e1		 jb	 SHORT $LL182@inflate
$LN184@inflate:

; 947  :                         DROPBITS(here.bits);

  00d0f	41 8b c9	 mov	 ecx, r9d

; 948  :                         len = 0;
; 949  :                         copy = 3 + BITS(3);
; 950  :                         DROPBITS(3);

  00d12	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00d17	41 d3 ef	 shr	 r15d, cl
  00d1a	41 8b d7	 mov	 edx, r15d
  00d1d	83 e2 07	 and	 edx, 7
  00d20	83 c2 03	 add	 edx, 3
  00d23	41 c1 ef 03	 shr	 r15d, 3

; 951  :                     }
; 952  :                     else {

  00d27	eb 3f		 jmp	 SHORT $LN878@inflate
$LN169@inflate:

; 953  :                         NEEDBITS(here.bits + 7);

  00d29	41 8d 51 07	 lea	 edx, DWORD PTR [r9+7]
  00d2d	3b da		 cmp	 ebx, edx
  00d2f	73 1f		 jae	 SHORT $LN168@inflate
$LL166@inflate:
  00d31	85 f6		 test	 esi, esi
  00d33	0f 84 47 fb ff
	ff		 je	 $LN843@inflate
  00d39	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00d3d	8b cb		 mov	 ecx, ebx
  00d3f	83 c3 08	 add	 ebx, 8
  00d42	d3 e0		 shl	 eax, cl
  00d44	ff ce		 dec	 esi
  00d46	49 ff c6	 inc	 r14
  00d49	44 03 f8	 add	 r15d, eax
  00d4c	3b da		 cmp	 ebx, edx
  00d4e	72 e1		 jb	 SHORT $LL166@inflate
$LN168@inflate:

; 954  :                         DROPBITS(here.bits);

  00d50	41 8b c9	 mov	 ecx, r9d

; 955  :                         len = 0;
; 956  :                         copy = 11 + BITS(7);
; 957  :                         DROPBITS(7);

  00d53	b8 f9 ff ff ff	 mov	 eax, -7			; fffffff9H
  00d58	41 d3 ef	 shr	 r15d, cl
  00d5b	41 8b d7	 mov	 edx, r15d
  00d5e	83 e2 7f	 and	 edx, 127		; 0000007fH
  00d61	83 c2 0b	 add	 edx, 11
  00d64	41 c1 ef 07	 shr	 r15d, 7
$LN878@inflate:
  00d68	41 2b c1	 sub	 eax, r9d
  00d6b	44 8b c7	 mov	 r8d, edi
  00d6e	03 d8		 add	 ebx, eax
$LN155@inflate:

; 958  :                     }
; 959  :                     if (state->have + copy > state->nlen + state->ndist) {

  00d70	41 8b 45 78	 mov	 eax, DWORD PTR [r13+120]
  00d74	41 8d 0c 12	 lea	 ecx, DWORD PTR [r10+rdx]
  00d78	41 03 45 74	 add	 eax, DWORD PTR [r13+116]
  00d7c	3b c8		 cmp	 ecx, eax
  00d7e	77 69		 ja	 SHORT $LN570@inflate

; 960  :                         strm->msg = (char *)"invalid bit length repeat";
; 961  :                         state->mode = BAD;
; 962  :                         break;
; 963  :                     }
; 964  :                     while (copy--)

  00d80	85 d2		 test	 edx, edx
  00d82	74 21		 je	 SHORT $LN614@inflate
  00d84	66 66 66 66 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL153@inflate:

; 965  :                         state->lens[state->have++] = (unsigned short)len;

  00d90	41 8b 45 7c	 mov	 eax, DWORD PTR [r13+124]
  00d94	66 45 89 84 45
	88 00 00 00	 mov	 WORD PTR [r13+rax*2+136], r8w
  00d9d	41 ff 45 7c	 inc	 DWORD PTR [r13+124]
  00da1	ff ca		 dec	 edx
  00da3	75 eb		 jne	 SHORT $LL153@inflate
$LN614@inflate:

; 920  :         case CODELENS:
; 921  :             while (state->have < state->nlen + state->ndist) {

  00da5	41 8b 45 78	 mov	 eax, DWORD PTR [r13+120]
  00da9	45 8b 55 7c	 mov	 r10d, DWORD PTR [r13+124]
  00dad	41 03 45 74	 add	 eax, DWORD PTR [r13+116]
  00db1	44 3b d0	 cmp	 r10d, eax
  00db4	0f 82 f6 fd ff
	ff		 jb	 $LL227@inflate
$LN226@inflate:

; 966  :                 }
; 967  :             }
; 968  : 
; 969  :             /* handle error breaks in while */
; 970  :             if (state->mode == BAD) break;

  00dba	41 83 7d 00 1d	 cmp	 DWORD PTR [r13], 29
  00dbf	0f 84 34 f9 ff
	ff		 je	 $LN807@inflate

; 971  : 
; 972  :             /* check for end-of-block code (better have one) */
; 973  :             if (state->lens[256] == 0) {

  00dc5	66 41 83 bd 88
	02 00 00 00	 cmp	 WORD PTR [r13+648], 0
  00dce	75 32		 jne	 SHORT $LN150@inflate

; 974  :                 strm->msg = (char *)"invalid code -- missing end-of-block";

  00dd0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CF@DGDMADCD@invalid?5code?5?9?9?5missing?5end?9of?9b@
  00dd7	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 975  :                 state->mode = BAD;

  00ddc	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 976  :                 break;

  00de4	e9 10 f9 ff ff	 jmp	 $LN807@inflate
$LN570@inflate:

; 937  :                             strm->msg = (char *)"invalid bit length repeat";

  00de9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00df0	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 938  :                             state->mode = BAD;

  00df5	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 939  :                             break;

  00dfd	e9 f7 f8 ff ff	 jmp	 $LN807@inflate
$LN150@inflate:

; 977  :             }
; 978  : 
; 979  :             /* build code tables -- note: do not change the lenbits or distbits
; 980  :                values here (9 and 6) without reading the comments in inftrees.h
; 981  :                concerning the ENOUGH constants, which depend on those values */
; 982  :             state->next = state->codes;
; 983  :             state->lencode = (code const FAR *)(state->next);
; 984  :             state->lenbits = 9;
; 985  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 986  :                                 &(state->lenbits), state->work);

  00e02	45 8b 45 74	 mov	 r8d, DWORD PTR [r13+116]
  00e06	49 8d 85 48 05
	00 00		 lea	 rax, QWORD PTR [r13+1352]
  00e0d	4d 8d a5 08 03
	00 00		 lea	 r12, QWORD PTR [r13+776]
  00e14	49 89 85 80 00
	00 00		 mov	 QWORD PTR [r13+128], rax
  00e1b	49 89 45 58	 mov	 QWORD PTR [r13+88], rax
  00e1f	49 8d 45 68	 lea	 rax, QWORD PTR [r13+104]
  00e23	49 8d 95 88 00
	00 00		 lea	 rdx, QWORD PTR [r13+136]
  00e2a	4d 8d 8d 80 00
	00 00		 lea	 r9, QWORD PTR [r13+128]
  00e31	b9 01 00 00 00	 mov	 ecx, 1
  00e36	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  00e3b	c7 00 09 00 00
	00		 mov	 DWORD PTR [rax], 9
  00e41	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00e46	e8 00 00 00 00	 call	 inflate_table
  00e4b	89 45 30	 mov	 DWORD PTR ret$1$[rbp-128], eax

; 987  :             if (ret) {

  00e4e	85 c0		 test	 eax, eax
  00e50	74 1d		 je	 SHORT $LN149@inflate

; 988  :                 strm->msg = (char *)"invalid literal/lengths set";

  00e52	4c 8b 65 20	 mov	 r12, QWORD PTR strm$[rbp-128]
  00e56	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
  00e5d	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 989  :                 state->mode = BAD;

  00e62	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 990  :                 break;

  00e6a	e9 8a f8 ff ff	 jmp	 $LN807@inflate
$LN149@inflate:

; 991  :             }
; 992  :             state->distcode = (code const FAR *)(state->next);

  00e6f	49 8b 85 80 00
	00 00		 mov	 rax, QWORD PTR [r13+128]

; 993  :             state->distbits = 6;
; 994  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 995  :                             &(state->next), &(state->distbits), state->work);

  00e76	45 8b 45 78	 mov	 r8d, DWORD PTR [r13+120]
  00e7a	49 8d 4d 6c	 lea	 rcx, QWORD PTR [r13+108]
  00e7e	49 89 45 60	 mov	 QWORD PTR [r13+96], rax
  00e82	41 8b 45 74	 mov	 eax, DWORD PTR [r13+116]
  00e86	c7 01 06 00 00
	00		 mov	 DWORD PTR [rcx], 6
  00e8c	48 8d 14 45 88
	00 00 00	 lea	 rdx, QWORD PTR [rax*2+136]
  00e94	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  00e99	48 89 4c 24 20	 mov	 QWORD PTR [rsp+32], rcx
  00e9e	4d 8d 8d 80 00
	00 00		 lea	 r9, QWORD PTR [r13+128]
  00ea5	b9 02 00 00 00	 mov	 ecx, 2
  00eaa	49 03 d5	 add	 rdx, r13
  00ead	e8 00 00 00 00	 call	 inflate_table
  00eb2	44 8b e0	 mov	 r12d, eax
  00eb5	89 45 30	 mov	 DWORD PTR ret$1$[rbp-128], eax

; 996  :             if (ret) {

  00eb8	85 c0		 test	 eax, eax
  00eba	74 1d		 je	 SHORT $LN148@inflate

; 997  :                 strm->msg = (char *)"invalid distances set";

  00ebc	4c 8b 65 20	 mov	 r12, QWORD PTR strm$[rbp-128]
  00ec0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
  00ec7	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 998  :                 state->mode = BAD;

  00ecc	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 999  :                 break;

  00ed4	e9 20 f8 ff ff	 jmp	 $LN807@inflate
$LN148@inflate:

; 1000 :             }
; 1001 :             Tracev((stderr, "inflate:       codes ok\n"));
; 1002 :             state->mode = LEN_;
; 1003 :             if (flush == Z_TREES) goto inf_leave;

  00ed9	83 7d 28 06	 cmp	 DWORD PTR flush$[rbp-128], 6
  00edd	41 c7 45 00 13
	00 00 00	 mov	 DWORD PTR [r13], 19
  00ee5	0f 84 99 f9 ff
	ff		 je	 $inf_leave$886
  00eeb	4c 8b 65 20	 mov	 r12, QWORD PTR strm$[rbp-128]
  00eef	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  00ef3	44 8b 45 b8	 mov	 r8d, DWORD PTR out$1$[rbp-128]
  00ef7	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]
  00efb	33 ff		 xor	 edi, edi
$LN147@inflate:

; 1004 :         case LEN_:
; 1005 :             state->mode = LEN;

  00efd	41 c7 45 00 14
	00 00 00	 mov	 DWORD PTR [r13], 20
$LN145@inflate:

; 1006 :         case LEN:
; 1007 :             if (have >= 6 && left >= 258) {

  00f05	83 fe 06	 cmp	 esi, 6
  00f08	72 6d		 jb	 SHORT $LN144@inflate
  00f0a	41 81 fa 02 01
	00 00		 cmp	 r10d, 258		; 00000102H
  00f11	72 64		 jb	 SHORT $LN144@inflate

; 1008 :                 RESTORE();

  00f13	4d 89 4c 24 10	 mov	 QWORD PTR [r12+16], r9
  00f18	45 89 54 24 18	 mov	 DWORD PTR [r12+24], r10d
  00f1d	4d 89 34 24	 mov	 QWORD PTR [r12], r14
  00f21	41 89 74 24 08	 mov	 DWORD PTR [r12+8], esi

; 1009 :                 inflate_fast(strm, out);

  00f26	41 8b d0	 mov	 edx, r8d
  00f29	49 8b cc	 mov	 rcx, r12
  00f2c	45 89 7d 40	 mov	 DWORD PTR [r13+64], r15d
  00f30	41 89 5d 44	 mov	 DWORD PTR [r13+68], ebx
  00f34	e8 00 00 00 00	 call	 inflate_fast

; 1010 :                 LOAD();
; 1011 :                 if (state->mode == TYPE)

  00f39	41 83 7d 00 0b	 cmp	 DWORD PTR [r13], 11
  00f3e	4d 8b 4c 24 10	 mov	 r9, QWORD PTR [r12+16]
  00f43	45 8b 54 24 18	 mov	 r10d, DWORD PTR [r12+24]
  00f48	4d 8b 34 24	 mov	 r14, QWORD PTR [r12]
  00f4c	41 8b 74 24 08	 mov	 esi, DWORD PTR [r12+8]
  00f51	45 8b 7d 40	 mov	 r15d, DWORD PTR [r13+64]
  00f55	41 8b 5d 44	 mov	 ebx, DWORD PTR [r13+68]
  00f59	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9
  00f5d	44 89 55 38	 mov	 DWORD PTR left$1$[rbp-128], r10d
  00f61	0f 85 9a f7 ff
	ff		 jne	 $LN498@inflate

; 1012 :                     state->back = -1;

  00f67	41 c7 85 dc 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r13+7132], -1

; 1013 :                 break;

  00f72	e9 8a f7 ff ff	 jmp	 $LN498@inflate
$LN144@inflate:

; 1014 :             }
; 1015 :             state->back = 0;
; 1016 :             for (;;) {
; 1017 :                 here = state->lencode[BITS(state->lenbits)];

  00f77	41 8b 4d 68	 mov	 ecx, DWORD PTR [r13+104]
  00f7b	4d 8b 5d 58	 mov	 r11, QWORD PTR [r13+88]
  00f7f	ba 01 00 00 00	 mov	 edx, 1
  00f84	d3 e2		 shl	 edx, cl
  00f86	41 8b c7	 mov	 eax, r15d
  00f89	41 89 bd dc 1b
	00 00		 mov	 DWORD PTR [r13+7132], edi
  00f90	ff ca		 dec	 edx
  00f92	48 23 c2	 and	 rax, rdx
  00f95	41 8b 04 83	 mov	 eax, DWORD PTR [r11+rax*4]

; 1018 :                 if ((unsigned)(here.bits) <= bits) break;

  00f99	8b c8		 mov	 ecx, eax
  00f9b	c1 e9 08	 shr	 ecx, 8
  00f9e	0f b6 c9	 movzx	 ecx, cl
  00fa1	3b cb		 cmp	 ecx, ebx
  00fa3	76 31		 jbe	 SHORT $LN572@inflate
$LL136@inflate:

; 1019 :                 PULLBYTE();

  00fa5	85 f6		 test	 esi, esi
  00fa7	0f 84 d3 f8 ff
	ff		 je	 $LN843@inflate
  00fad	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  00fb1	8b cb		 mov	 ecx, ebx
  00fb3	83 c3 08	 add	 ebx, 8
  00fb6	d3 e0		 shl	 eax, cl
  00fb8	ff ce		 dec	 esi
  00fba	49 ff c6	 inc	 r14
  00fbd	44 03 f8	 add	 r15d, eax
  00fc0	41 8b c7	 mov	 eax, r15d
  00fc3	48 23 c2	 and	 rax, rdx
  00fc6	41 8b 04 83	 mov	 eax, DWORD PTR [r11+rax*4]
  00fca	8b c8		 mov	 ecx, eax
  00fcc	c1 e9 08	 shr	 ecx, 8
  00fcf	0f b6 c9	 movzx	 ecx, cl
  00fd2	3b cb		 cmp	 ecx, ebx
  00fd4	77 cf		 ja	 SHORT $LL136@inflate
$LN572@inflate:

; 1020 :             }
; 1021 :             if (here.op && (here.op & 0xf0) == 0) {

  00fd6	84 c0		 test	 al, al
  00fd8	0f 84 c8 00 00
	00		 je	 $LN118@inflate
  00fde	a8 f0		 test	 al, 240			; 000000f0H
  00fe0	0f 85 c0 00 00
	00		 jne	 $LN118@inflate

; 1022 :                 last = here;
; 1023 :                 for (;;) {
; 1024 :                     here = state->lencode[last.val +
; 1025 :                             (BITS(last.bits + last.op) >> last.bits)];

  00fe6	44 8b d0	 mov	 r10d, eax
  00fe9	0f b6 c8	 movzx	 ecx, al
  00fec	89 45 b4	 mov	 DWORD PTR last$[rbp-128], eax

; 1026 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  00fef	0f b6 7d b5	 movzx	 edi, BYTE PTR last$[rbp-127]
  00ff3	41 c1 ea 08	 shr	 r10d, 8
  00ff7	41 b9 01 00 00
	00		 mov	 r9d, 1
  00ffd	45 0f b6 c2	 movzx	 r8d, r10b
  01001	8b d0		 mov	 edx, eax
  01003	c1 e8 10	 shr	 eax, 16
  01006	41 03 c8	 add	 ecx, r8d
  01009	41 d3 e1	 shl	 r9d, cl
  0100c	41 8b c8	 mov	 ecx, r8d
  0100f	41 ff c9	 dec	 r9d
  01012	45 23 cf	 and	 r9d, r15d
  01015	41 d3 e9	 shr	 r9d, cl
  01018	44 03 c8	 add	 r9d, eax
  0101b	43 8b 04 8b	 mov	 eax, DWORD PTR [r11+r9*4]
  0101f	8b c8		 mov	 ecx, eax
  01021	c1 e9 08	 shr	 ecx, 8
  01024	44 0f b6 c1	 movzx	 r8d, cl
  01028	41 0f b6 ca	 movzx	 ecx, r10b
  0102c	44 03 c1	 add	 r8d, ecx
  0102f	44 3b c3	 cmp	 r8d, ebx
  01032	76 62		 jbe	 SHORT $LN121@inflate
  01034	44 0f b7 55 b6	 movzx	 r10d, WORD PTR last$[rbp-126]
  01039	0f 1f 80 00 00
	00 00		 npad	 7
$LL128@inflate:

; 1027 :                     PULLBYTE();

  01040	85 f6		 test	 esi, esi
  01042	0f 84 38 f8 ff
	ff		 je	 $LN843@inflate
  01048	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0104c	8b cb		 mov	 ecx, ebx
  0104e	44 0f b6 cf	 movzx	 r9d, dil
  01052	d3 e0		 shl	 eax, cl
  01054	41 b8 01 00 00
	00		 mov	 r8d, 1
  0105a	0f b6 ca	 movzx	 ecx, dl
  0105d	41 03 c9	 add	 ecx, r9d
  01060	44 03 f8	 add	 r15d, eax
  01063	41 0f b7 c2	 movzx	 eax, r10w
  01067	41 d3 e0	 shl	 r8d, cl
  0106a	41 8b c9	 mov	 ecx, r9d
  0106d	83 c3 08	 add	 ebx, 8
  01070	41 ff c8	 dec	 r8d
  01073	ff ce		 dec	 esi
  01075	49 ff c6	 inc	 r14
  01078	45 23 c7	 and	 r8d, r15d
  0107b	41 d3 e8	 shr	 r8d, cl
  0107e	44 03 c0	 add	 r8d, eax
  01081	43 8b 04 83	 mov	 eax, DWORD PTR [r11+r8*4]
  01085	8b c8		 mov	 ecx, eax
  01087	c1 e9 08	 shr	 ecx, 8
  0108a	44 0f b6 c1	 movzx	 r8d, cl
  0108e	45 03 c1	 add	 r8d, r9d
  01091	44 3b c3	 cmp	 r8d, ebx
  01094	77 aa		 ja	 SHORT $LL128@inflate
$LN121@inflate:

; 1028 :                 }
; 1029 :                 DROPBITS(last.bits);

  01096	40 0f b6 cf	 movzx	 ecx, dil
  0109a	41 d3 ef	 shr	 r15d, cl
  0109d	2b d9		 sub	 ebx, ecx

; 1030 :                 state->back += last.bits;

  0109f	41 89 8d dc 1b
	00 00		 mov	 DWORD PTR [r13+7132], ecx
$LN118@inflate:

; 1031 :             }
; 1032 :             DROPBITS(here.bits);

  010a6	8b c8		 mov	 ecx, eax
  010a8	c1 e9 08	 shr	 ecx, 8
  010ab	0f b6 c9	 movzx	 ecx, cl

; 1033 :             state->back += here.bits;

  010ae	41 01 8d dc 1b
	00 00		 add	 DWORD PTR [r13+7132], ecx
  010b5	41 d3 ef	 shr	 r15d, cl
  010b8	2b d9		 sub	 ebx, ecx

; 1034 :             state->length = (unsigned)here.val;

  010ba	8b c8		 mov	 ecx, eax
  010bc	c1 e9 10	 shr	 ecx, 16
  010bf	41 89 4d 48	 mov	 DWORD PTR [r13+72], ecx

; 1035 :             if ((int)(here.op) == 0) {

  010c3	84 c0		 test	 al, al
  010c5	75 0d		 jne	 SHORT $LN115@inflate

; 1036 :                 Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
; 1037 :                         "inflate:         literal '%c'\n" :
; 1038 :                         "inflate:         literal 0x%02x\n", here.val));
; 1039 :                 state->mode = LIT;

  010c7	41 c7 45 00 19
	00 00 00	 mov	 DWORD PTR [r13], 25

; 1040 :                 break;

  010cf	e9 25 f6 ff ff	 jmp	 $LN807@inflate
$LN115@inflate:

; 1041 :             }
; 1042 :             if (here.op & 32) {

  010d4	a8 20		 test	 al, 32			; 00000020H
  010d6	74 10		 je	 SHORT $LN114@inflate

; 1043 :                 Tracevv((stderr, "inflate:         end of block\n"));
; 1044 :                 state->back = -1;

  010d8	41 c7 85 dc 1b
	00 00 ff ff ff
	ff		 mov	 DWORD PTR [r13+7132], -1

; 1046 :                 break;

  010e3	e9 09 f6 ff ff	 jmp	 $LN881@inflate
$LN114@inflate:

; 1047 :             }
; 1048 :             if (here.op & 64) {

  010e8	a8 40		 test	 al, 64			; 00000040H
  010ea	74 19		 je	 SHORT $LN113@inflate

; 1049 :                 strm->msg = (char *)"invalid literal/length code";

  010ec	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  010f3	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1050 :                 state->mode = BAD;

  010f8	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 1051 :                 break;

  01100	e9 f4 f5 ff ff	 jmp	 $LN807@inflate
$LN113@inflate:

; 1052 :             }
; 1053 :             state->extra = (unsigned)(here.op) & 15;

  01105	0f b6 c8	 movzx	 ecx, al

; 1054 :             state->mode = LENEXT;

  01108	41 c7 45 00 15
	00 00 00	 mov	 DWORD PTR [r13], 21
  01110	83 e1 0f	 and	 ecx, 15
  01113	41 89 4d 50	 mov	 DWORD PTR [r13+80], ecx
$LN112@inflate:

; 1055 :         case LENEXT:
; 1056 :             if (state->extra) {

  01117	41 8b 55 50	 mov	 edx, DWORD PTR [r13+80]
  0111b	85 d2		 test	 edx, edx
  0111d	74 41		 je	 SHORT $LN111@inflate

; 1057 :                 NEEDBITS(state->extra);

  0111f	3b da		 cmp	 ebx, edx
  01121	73 1f		 jae	 SHORT $LN109@inflate
$LL107@inflate:
  01123	85 f6		 test	 esi, esi
  01125	0f 84 55 f7 ff
	ff		 je	 $LN843@inflate
  0112b	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0112f	8b cb		 mov	 ecx, ebx
  01131	83 c3 08	 add	 ebx, 8
  01134	d3 e0		 shl	 eax, cl
  01136	ff ce		 dec	 esi
  01138	49 ff c6	 inc	 r14
  0113b	44 03 f8	 add	 r15d, eax
  0113e	3b da		 cmp	 ebx, edx
  01140	72 e1		 jb	 SHORT $LL107@inflate
$LN109@inflate:

; 1058 :                 state->length += BITS(state->extra);

  01142	8b ca		 mov	 ecx, edx
  01144	b8 01 00 00 00	 mov	 eax, 1

; 1059 :                 DROPBITS(state->extra);

  01149	2b da		 sub	 ebx, edx
  0114b	d3 e0		 shl	 eax, cl
  0114d	ff c8		 dec	 eax
  0114f	41 23 c7	 and	 eax, r15d
  01152	41 d3 ef	 shr	 r15d, cl
  01155	41 01 45 48	 add	 DWORD PTR [r13+72], eax

; 1060 :                 state->back += state->extra;

  01159	41 01 95 dc 1b
	00 00		 add	 DWORD PTR [r13+7132], edx
$LN111@inflate:

; 1061 :             }
; 1062 :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1063 :             state->was = state->length;

  01160	41 8b 45 48	 mov	 eax, DWORD PTR [r13+72]

; 1064 :             state->mode = DIST;

  01164	41 c7 45 00 16
	00 00 00	 mov	 DWORD PTR [r13], 22
  0116c	41 89 85 e0 1b
	00 00		 mov	 DWORD PTR [r13+7136], eax
$LN546@inflate:

; 1065 :         case DIST:
; 1066 :             for (;;) {
; 1067 :                 here = state->distcode[BITS(state->distbits)];

  01173	41 8b 4d 6c	 mov	 ecx, DWORD PTR [r13+108]
  01177	4d 8b 5d 60	 mov	 r11, QWORD PTR [r13+96]
  0117b	ba 01 00 00 00	 mov	 edx, 1
  01180	d3 e2		 shl	 edx, cl
  01182	41 8b c7	 mov	 eax, r15d
  01185	ff ca		 dec	 edx
  01187	48 23 c2	 and	 rax, rdx
  0118a	41 8b 04 83	 mov	 eax, DWORD PTR [r11+rax*4]

; 1068 :                 if ((unsigned)(here.bits) <= bits) break;

  0118e	8b c8		 mov	 ecx, eax
  01190	c1 e9 08	 shr	 ecx, 8
  01193	0f b6 c9	 movzx	 ecx, cl
  01196	3b cb		 cmp	 ecx, ebx
  01198	76 37		 jbe	 SHORT $LN577@inflate
  0119a	66 0f 1f 44 00
	00		 npad	 6
$LL97@inflate:

; 1069 :                 PULLBYTE();

  011a0	85 f6		 test	 esi, esi
  011a2	0f 84 d8 f6 ff
	ff		 je	 $LN843@inflate
  011a8	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  011ac	8b cb		 mov	 ecx, ebx
  011ae	83 c3 08	 add	 ebx, 8
  011b1	d3 e0		 shl	 eax, cl
  011b3	ff ce		 dec	 esi
  011b5	49 ff c6	 inc	 r14
  011b8	44 03 f8	 add	 r15d, eax
  011bb	41 8b c7	 mov	 eax, r15d
  011be	48 23 c2	 and	 rax, rdx
  011c1	41 8b 04 83	 mov	 eax, DWORD PTR [r11+rax*4]
  011c5	8b c8		 mov	 ecx, eax
  011c7	c1 e9 08	 shr	 ecx, 8
  011ca	0f b6 c9	 movzx	 ecx, cl
  011cd	3b cb		 cmp	 ecx, ebx
  011cf	77 cf		 ja	 SHORT $LL97@inflate
$LN577@inflate:

; 1070 :             }
; 1071 :             if ((here.op & 0xf0) == 0) {

  011d1	a8 f0		 test	 al, 240			; 000000f0H
  011d3	0f 85 bd 00 00
	00		 jne	 $LN79@inflate

; 1072 :                 last = here;
; 1073 :                 for (;;) {
; 1074 :                     here = state->distcode[last.val +
; 1075 :                             (BITS(last.bits + last.op) >> last.bits)];

  011d9	44 8b d0	 mov	 r10d, eax
  011dc	0f b6 c8	 movzx	 ecx, al
  011df	89 45 b4	 mov	 DWORD PTR last$[rbp-128], eax

; 1076 :                     if ((unsigned)(last.bits + here.bits) <= bits) break;

  011e2	0f b6 7d b5	 movzx	 edi, BYTE PTR last$[rbp-127]
  011e6	41 c1 ea 08	 shr	 r10d, 8
  011ea	41 b9 01 00 00
	00		 mov	 r9d, 1
  011f0	45 0f b6 c2	 movzx	 r8d, r10b
  011f4	8b d0		 mov	 edx, eax
  011f6	c1 e8 10	 shr	 eax, 16
  011f9	41 03 c8	 add	 ecx, r8d
  011fc	41 d3 e1	 shl	 r9d, cl
  011ff	41 8b c8	 mov	 ecx, r8d
  01202	41 ff c9	 dec	 r9d
  01205	45 23 cf	 and	 r9d, r15d
  01208	41 d3 e9	 shr	 r9d, cl
  0120b	44 03 c8	 add	 r9d, eax
  0120e	43 8b 04 8b	 mov	 eax, DWORD PTR [r11+r9*4]
  01212	8b c8		 mov	 ecx, eax
  01214	c1 e9 08	 shr	 ecx, 8
  01217	44 0f b6 c1	 movzx	 r8d, cl
  0121b	41 0f b6 ca	 movzx	 ecx, r10b
  0121f	44 03 c1	 add	 r8d, ecx
  01222	44 3b c3	 cmp	 r8d, ebx
  01225	76 5f		 jbe	 SHORT $LN82@inflate
  01227	44 0f b7 55 b6	 movzx	 r10d, WORD PTR last$[rbp-126]
  0122c	0f 1f 40 00	 npad	 4
$LL89@inflate:

; 1077 :                     PULLBYTE();

  01230	85 f6		 test	 esi, esi
  01232	0f 84 48 f6 ff
	ff		 je	 $LN843@inflate
  01238	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0123c	8b cb		 mov	 ecx, ebx
  0123e	44 0f b6 cf	 movzx	 r9d, dil
  01242	d3 e0		 shl	 eax, cl
  01244	41 b8 01 00 00
	00		 mov	 r8d, 1
  0124a	0f b6 ca	 movzx	 ecx, dl
  0124d	41 03 c9	 add	 ecx, r9d
  01250	44 03 f8	 add	 r15d, eax
  01253	41 0f b7 c2	 movzx	 eax, r10w
  01257	41 d3 e0	 shl	 r8d, cl
  0125a	41 8b c9	 mov	 ecx, r9d
  0125d	83 c3 08	 add	 ebx, 8
  01260	41 ff c8	 dec	 r8d
  01263	ff ce		 dec	 esi
  01265	49 ff c6	 inc	 r14
  01268	45 23 c7	 and	 r8d, r15d
  0126b	41 d3 e8	 shr	 r8d, cl
  0126e	44 03 c0	 add	 r8d, eax
  01271	43 8b 04 83	 mov	 eax, DWORD PTR [r11+r8*4]
  01275	8b c8		 mov	 ecx, eax
  01277	c1 e9 08	 shr	 ecx, 8
  0127a	44 0f b6 c1	 movzx	 r8d, cl
  0127e	45 03 c1	 add	 r8d, r9d
  01281	44 3b c3	 cmp	 r8d, ebx
  01284	77 aa		 ja	 SHORT $LL89@inflate
$LN82@inflate:

; 1078 :                 }
; 1079 :                 DROPBITS(last.bits);

  01286	40 0f b6 cf	 movzx	 ecx, dil
  0128a	41 d3 ef	 shr	 r15d, cl
  0128d	2b d9		 sub	 ebx, ecx

; 1080 :                 state->back += last.bits;

  0128f	41 01 8d dc 1b
	00 00		 add	 DWORD PTR [r13+7132], ecx
$LN79@inflate:

; 1087 :                 break;

  01296	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  0129a	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]
  0129e	8b c8		 mov	 ecx, eax
  012a0	c1 e9 08	 shr	 ecx, 8
  012a3	0f b6 c9	 movzx	 ecx, cl
  012a6	41 01 8d dc 1b
	00 00		 add	 DWORD PTR [r13+7132], ecx
  012ad	41 d3 ef	 shr	 r15d, cl
  012b0	2b d9		 sub	 ebx, ecx
  012b2	a8 40		 test	 al, 64			; 00000040H
  012b4	74 19		 je	 SHORT $LN76@inflate

; 1081 :             }
; 1082 :             DROPBITS(here.bits);
; 1083 :             state->back += here.bits;
; 1084 :             if (here.op & 64) {
; 1085 :                 strm->msg = (char *)"invalid distance code";

  012b6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  012bd	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1086 :                 state->mode = BAD;

  012c2	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 1087 :                 break;

  012ca	e9 32 f4 ff ff	 jmp	 $LN498@inflate
$LN76@inflate:
  012cf	44 8b 45 b8	 mov	 r8d, DWORD PTR out$1$[rbp-128]

; 1088 :             }
; 1089 :             state->offset = (unsigned)here.val;

  012d3	8b c8		 mov	 ecx, eax

; 1090 :             state->extra = (unsigned)(here.op) & 15;
; 1091 :             state->mode = DISTEXT;

  012d5	41 c7 45 00 17
	00 00 00	 mov	 DWORD PTR [r13], 23
  012dd	c1 e9 10	 shr	 ecx, 16
  012e0	41 89 4d 4c	 mov	 DWORD PTR [r13+76], ecx
  012e4	0f b6 c8	 movzx	 ecx, al
  012e7	83 e1 0f	 and	 ecx, 15
  012ea	41 89 4d 50	 mov	 DWORD PTR [r13+80], ecx
$LN75@inflate:

; 1092 :         case DISTEXT:
; 1093 :             if (state->extra) {

  012ee	41 8b 55 50	 mov	 edx, DWORD PTR [r13+80]
  012f2	85 d2		 test	 edx, edx
  012f4	74 47		 je	 SHORT $LN74@inflate

; 1094 :                 NEEDBITS(state->extra);

  012f6	3b da		 cmp	 ebx, edx
  012f8	73 25		 jae	 SHORT $LN72@inflate
  012fa	66 0f 1f 44 00
	00		 npad	 6
$LL70@inflate:
  01300	85 f6		 test	 esi, esi
  01302	0f 84 78 f5 ff
	ff		 je	 $LN843@inflate
  01308	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0130c	8b cb		 mov	 ecx, ebx
  0130e	83 c3 08	 add	 ebx, 8
  01311	d3 e0		 shl	 eax, cl
  01313	ff ce		 dec	 esi
  01315	49 ff c6	 inc	 r14
  01318	44 03 f8	 add	 r15d, eax
  0131b	3b da		 cmp	 ebx, edx
  0131d	72 e1		 jb	 SHORT $LL70@inflate
$LN72@inflate:

; 1095 :                 state->offset += BITS(state->extra);

  0131f	8b ca		 mov	 ecx, edx
  01321	b8 01 00 00 00	 mov	 eax, 1

; 1096 :                 DROPBITS(state->extra);

  01326	2b da		 sub	 ebx, edx
  01328	d3 e0		 shl	 eax, cl
  0132a	ff c8		 dec	 eax
  0132c	41 23 c7	 and	 eax, r15d
  0132f	41 d3 ef	 shr	 r15d, cl
  01332	41 01 45 4c	 add	 DWORD PTR [r13+76], eax

; 1097 :                 state->back += state->extra;

  01336	41 01 95 dc 1b
	00 00		 add	 DWORD PTR [r13+7132], edx
$LN74@inflate:

; 1098 :             }
; 1099 : #ifdef INFLATE_STRICT
; 1100 :             if (state->offset > state->dmax) {
; 1101 :                 strm->msg = (char *)"invalid distance too far back";
; 1102 :                 state->mode = BAD;
; 1103 :                 break;
; 1104 :             }
; 1105 : #endif
; 1106 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1107 :             state->mode = MATCH;

  0133d	41 c7 45 00 18
	00 00 00	 mov	 DWORD PTR [r13], 24
$LN61@inflate:

; 1108 :         case MATCH:
; 1109 :             if (left == 0) goto inf_leave;

  01345	45 85 d2	 test	 r10d, r10d
  01348	0f 84 32 f5 ff
	ff		 je	 $LN843@inflate

; 1110 :             copy = out - left;
; 1111 :             if (state->offset > copy) {         /* copy from window */

  0134e	41 8b 4d 4c	 mov	 ecx, DWORD PTR [r13+76]
  01352	41 8b c0	 mov	 eax, r8d
  01355	41 2b c2	 sub	 eax, r10d
  01358	3b c8		 cmp	 ecx, eax
  0135a	76 4f		 jbe	 SHORT $LN59@inflate

; 1112 :                 copy = state->offset - copy;

  0135c	2b c8		 sub	 ecx, eax

; 1113 :                 if (copy > state->whave) {

  0135e	41 3b 4d 30	 cmp	 ecx, DWORD PTR [r13+48]
  01362	76 23		 jbe	 SHORT $LN57@inflate

; 1114 :                     if (state->sane) {

  01364	41 83 bd d8 1b
	00 00 00	 cmp	 DWORD PTR [r13+7128], 0
  0136c	74 19		 je	 SHORT $LN57@inflate

; 1115 :                         strm->msg = (char *)"invalid distance too far back";

  0136e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  01375	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1116 :                         state->mode = BAD;

  0137a	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 1117 :                         break;

  01382	e9 7a f3 ff ff	 jmp	 $LN498@inflate
$LN57@inflate:

; 1118 :                     }
; 1119 : #ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
; 1120 :                     Trace((stderr, "inflate.c too far\n"));
; 1121 :                     copy -= state->whave;
; 1122 :                     if (copy > state->length) copy = state->length;
; 1123 :                     if (copy > left) copy = left;
; 1124 :                     left -= copy;
; 1125 :                     state->length -= copy;
; 1126 :                     do {
; 1127 :                         *put++ = 0;
; 1128 :                     } while (--copy);
; 1129 :                     if (state->length == 0) state->mode = LEN;
; 1130 :                     break;
; 1131 : #endif
; 1132 :                 }
; 1133 :                 if (copy > state->wnext) {

  01387	41 8b 45 34	 mov	 eax, DWORD PTR [r13+52]
  0138b	3b c8		 cmp	 ecx, eax
  0138d	76 0a		 jbe	 SHORT $LN56@inflate

; 1134 :                     copy -= state->wnext;
; 1135 :                     from = state->window + (state->wsize - copy);

  0138f	41 8b 55 2c	 mov	 edx, DWORD PTR [r13+44]
  01393	2b c8		 sub	 ecx, eax
  01395	2b d1		 sub	 edx, ecx

; 1136 :                 }
; 1137 :                 else

  01397	eb 04		 jmp	 SHORT $LN879@inflate
$LN56@inflate:

; 1138 :                     from = state->window + (state->wnext - copy);

  01399	2b c1		 sub	 eax, ecx
  0139b	8b d0		 mov	 edx, eax
$LN879@inflate:

; 1139 :                 if (copy > state->length) copy = state->length;

  0139d	41 8b 45 48	 mov	 eax, DWORD PTR [r13+72]
  013a1	49 03 55 38	 add	 rdx, QWORD PTR [r13+56]
  013a5	3b c8		 cmp	 ecx, eax
  013a7	76 0e		 jbe	 SHORT $LN53@inflate

; 1140 :             }
; 1141 :             else {                              /* copy from output */

  013a9	eb 0a		 jmp	 SHORT $LN880@inflate
$LN59@inflate:

; 1142 :                 from = put - state->offset;
; 1143 :                 copy = state->length;

  013ab	41 8b 45 48	 mov	 eax, DWORD PTR [r13+72]
  013af	49 8b d1	 mov	 rdx, r9
  013b2	48 2b d1	 sub	 rdx, rcx
$LN880@inflate:
  013b5	8b c8		 mov	 ecx, eax
$LN53@inflate:

; 1144 :             }
; 1145 :             if (copy > left) copy = left;

  013b7	41 3b ca	 cmp	 ecx, r10d
  013ba	41 0f 47 ca	 cmova	 ecx, r10d

; 1146 :             left -= copy;

  013be	44 2b d1	 sub	 r10d, ecx

; 1147 :             state->length -= copy;

  013c1	2b c1		 sub	 eax, ecx

; 1150 :             } while (--copy);

  013c3	49 2b d1	 sub	 rdx, r9
  013c6	44 89 55 38	 mov	 DWORD PTR left$1$[rbp-128], r10d
  013ca	41 89 45 48	 mov	 DWORD PTR [r13+72], eax
  013ce	66 90		 npad	 2
$LL51@inflate:

; 1148 :             do {
; 1149 :                 *put++ = *from++;

  013d0	42 0f b6 04 0a	 movzx	 eax, BYTE PTR [rdx+r9]
  013d5	49 ff c1	 inc	 r9
  013d8	41 88 41 ff	 mov	 BYTE PTR [r9-1], al

; 1150 :             } while (--copy);

  013dc	ff c9		 dec	 ecx
  013de	75 f0		 jne	 SHORT $LL51@inflate

; 1151 :             if (state->length == 0) state->mode = LEN;

  013e0	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9
  013e4	41 39 4d 48	 cmp	 DWORD PTR [r13+72], ecx
  013e8	0f 85 13 f3 ff
	ff		 jne	 $LN498@inflate
  013ee	41 c7 45 00 14
	00 00 00	 mov	 DWORD PTR [r13], 20

; 1152 :             break;

  013f6	e9 06 f3 ff ff	 jmp	 $LN498@inflate
$LN47@inflate:

; 1153 :         case LIT:
; 1154 :             if (left == 0) goto inf_leave;

  013fb	45 85 d2	 test	 r10d, r10d
  013fe	0f 84 7c f4 ff
	ff		 je	 $LN843@inflate

; 1155 :             *put++ = (unsigned char)(state->length);

  01404	41 0f b6 45 48	 movzx	 eax, BYTE PTR [r13+72]
  01409	49 ff c1	 inc	 r9

; 1156 :             left--;

  0140c	41 ff ca	 dec	 r10d
  0140f	41 88 41 ff	 mov	 BYTE PTR [r9-1], al
  01413	44 89 55 38	 mov	 DWORD PTR left$1$[rbp-128], r10d
  01417	4c 89 4d c0	 mov	 QWORD PTR put$1$[rbp-128], r9

; 1157 :             state->mode = LEN;

  0141b	41 c7 45 00 14
	00 00 00	 mov	 DWORD PTR [r13], 20

; 1158 :             break;

  01423	e9 d9 f2 ff ff	 jmp	 $LN498@inflate
$LN45@inflate:

; 1159 :         case CHECK:
; 1160 :             if (state->wrap) {

  01428	41 83 7d 08 00	 cmp	 DWORD PTR [r13+8], 0
  0142d	0f 84 bf 00 00
	00		 je	 $LN30@inflate

; 1161 :                 NEEDBITS(32);

  01433	83 fb 20	 cmp	 ebx, 32			; 00000020H
  01436	73 20		 jae	 SHORT $LN42@inflate
$LL40@inflate:
  01438	85 f6		 test	 esi, esi
  0143a	0f 84 40 f4 ff
	ff		 je	 $LN843@inflate
  01440	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  01444	8b cb		 mov	 ecx, ebx
  01446	83 c3 08	 add	 ebx, 8
  01449	d3 e0		 shl	 eax, cl
  0144b	ff ce		 dec	 esi
  0144d	49 ff c6	 inc	 r14
  01450	44 03 f8	 add	 r15d, eax
  01453	83 fb 20	 cmp	 ebx, 32			; 00000020H
  01456	72 e0		 jb	 SHORT $LL40@inflate
$LN42@inflate:

; 1162 :                 out -= left;

  01458	45 2b c2	 sub	 r8d, r10d

; 1163 :                 strm->total_out += out;

  0145b	45 01 44 24 1c	 add	 DWORD PTR [r12+28], r8d

; 1164 :                 state->total += out;

  01460	45 01 45 1c	 add	 DWORD PTR [r13+28], r8d

; 1165 :                 if (out)

  01464	45 85 c0	 test	 r8d, r8d
  01467	74 31		 je	 SHORT $LN34@inflate

; 1166 :                     strm->adler = state->check =
; 1167 :                         UPDATE(state->check, put - out, out);

  01469	41 8b 4d 18	 mov	 ecx, DWORD PTR [r13+24]
  0146d	41 8b c0	 mov	 eax, r8d
  01470	49 8b d1	 mov	 rdx, r9
  01473	48 2b d0	 sub	 rdx, rax
  01476	41 83 7d 10 00	 cmp	 DWORD PTR [r13+16], 0
  0147b	74 07		 je	 SHORT $LN512@inflate
  0147d	e8 00 00 00 00	 call	 crc32
  01482	eb 05		 jmp	 SHORT $LN513@inflate
$LN512@inflate:
  01484	e8 00 00 00 00	 call	 adler32
$LN513@inflate:
  01489	4c 8b 4d c0	 mov	 r9, QWORD PTR put$1$[rbp-128]
  0148d	44 8b 55 38	 mov	 r10d, DWORD PTR left$1$[rbp-128]
  01491	41 89 45 18	 mov	 DWORD PTR [r13+24], eax
  01495	41 89 44 24 4c	 mov	 DWORD PTR [r12+76], eax
$LN34@inflate:

; 1168 :                 out = left;
; 1169 :                 if ((
; 1170 : #ifdef GUNZIP
; 1171 :                      state->flags ? hold :
; 1172 : #endif
; 1173 :                      REVERSE(hold)) != state->check) {

  0149a	41 83 7d 10 00	 cmp	 DWORD PTR [r13+16], 0
  0149f	44 89 55 b8	 mov	 DWORD PTR out$1$[rbp-128], r10d
  014a3	41 8b cf	 mov	 ecx, r15d
  014a6	75 26		 jne	 SHORT $LN515@inflate
  014a8	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  014ae	41 8b c7	 mov	 eax, r15d
  014b1	c1 e0 10	 shl	 eax, 16
  014b4	03 c8		 add	 ecx, eax
  014b6	41 8b c7	 mov	 eax, r15d
  014b9	c1 e8 08	 shr	 eax, 8
  014bc	c1 e1 08	 shl	 ecx, 8
  014bf	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  014c4	03 c8		 add	 ecx, eax
  014c6	41 8b c7	 mov	 eax, r15d
  014c9	c1 e8 18	 shr	 eax, 24
  014cc	03 c8		 add	 ecx, eax
$LN515@inflate:
  014ce	41 3b 4d 18	 cmp	 ecx, DWORD PTR [r13+24]
  014d2	74 19		 je	 SHORT $LN32@inflate

; 1174 :                     strm->msg = (char *)"incorrect data check";

  014d4	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
  014db	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1175 :                     state->mode = BAD;

  014e0	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29

; 1176 :                     break;

  014e8	e9 14 f2 ff ff	 jmp	 $LN498@inflate
$LN32@inflate:

; 1177 :                 }
; 1178 :                 INITBITS();

  014ed	44 8b ff	 mov	 r15d, edi
  014f0	8b df		 mov	 ebx, edi
$LN30@inflate:

; 1179 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1180 :             }
; 1181 : #ifdef GUNZIP
; 1182 :             state->mode = LENGTH;

  014f2	41 c7 45 00 1b
	00 00 00	 mov	 DWORD PTR [r13], 27
$LN29@inflate:

; 1183 :         case LENGTH:
; 1184 :             if (state->wrap && state->flags) {

  014fa	41 83 7d 08 00	 cmp	 DWORD PTR [r13+8], 0
  014ff	74 78		 je	 SHORT $LN15@inflate
  01501	41 83 7d 10 00	 cmp	 DWORD PTR [r13+16], 0
  01506	74 71		 je	 SHORT $LN15@inflate

; 1185 :                 NEEDBITS(32);

  01508	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0150b	73 23		 jae	 SHORT $LN26@inflate
  0150d	0f 1f 00	 npad	 3
$LL24@inflate:
  01510	85 f6		 test	 esi, esi
  01512	0f 84 68 f3 ff
	ff		 je	 $LN843@inflate
  01518	41 0f b6 06	 movzx	 eax, BYTE PTR [r14]
  0151c	8b cb		 mov	 ecx, ebx
  0151e	83 c3 08	 add	 ebx, 8
  01521	d3 e0		 shl	 eax, cl
  01523	ff ce		 dec	 esi
  01525	49 ff c6	 inc	 r14
  01528	44 03 f8	 add	 r15d, eax
  0152b	83 fb 20	 cmp	 ebx, 32			; 00000020H
  0152e	72 e0		 jb	 SHORT $LL24@inflate
$LN26@inflate:

; 1186 :                 if (hold != (state->total & 0xffffffffUL)) {

  01530	45 3b 7d 1c	 cmp	 r15d, DWORD PTR [r13+28]
  01534	74 3e		 je	 SHORT $LN17@inflate

; 1187 :                     strm->msg = (char *)"incorrect length check";

  01536	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
  0153d	49 89 44 24 20	 mov	 QWORD PTR [r12+32], rax

; 1188 :                     state->mode = BAD;

  01542	41 c7 45 00 1d
	00 00 00	 mov	 DWORD PTR [r13], 29
  0154a	e9 b2 f1 ff ff	 jmp	 $LN498@inflate
$LN589@inflate:

; 805  :                 RESTORE();

  0154f	4d 89 4c 24 10	 mov	 QWORD PTR [r12+16], r9
  01554	45 89 54 24 18	 mov	 DWORD PTR [r12+24], r10d
  01559	4d 89 34 24	 mov	 QWORD PTR [r12], r14
  0155d	41 89 74 24 08	 mov	 DWORD PTR [r12+8], esi

; 806  :                 return Z_NEED_DICT;

  01562	b8 02 00 00 00	 mov	 eax, 2
  01567	45 89 7d 40	 mov	 DWORD PTR [r13+64], r15d
  0156b	41 89 5d 44	 mov	 DWORD PTR [r13+68], ebx
  0156f	e9 6d f3 ff ff	 jmp	 $LN877@inflate
$LN17@inflate:

; 1189 :                     break;
; 1190 :                 }
; 1191 :                 INITBITS();

  01574	44 8b ff	 mov	 r15d, edi
  01577	8b df		 mov	 ebx, edi
$LN15@inflate:

; 1192 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1193 :             }
; 1194 : #endif
; 1195 :             state->mode = DONE;

  01579	41 c7 45 00 1c
	00 00 00	 mov	 DWORD PTR [r13], 28
$LN14@inflate:

; 1196 :         case DONE:
; 1197 :             ret = Z_STREAM_END;

  01581	41 bc 01 00 00
	00		 mov	 r12d, 1

; 1198 :             goto inf_leave;

  01587	e9 f8 f2 ff ff	 jmp	 $inf_leave$886
$LN13@inflate:

; 1199 :         case BAD:
; 1200 :             ret = Z_DATA_ERROR;

  0158c	41 bc fd ff ff
	ff		 mov	 r12d, -3
  01592	e9 ed f2 ff ff	 jmp	 $inf_leave$886
$LN5@inflate:

; 1221 :         }
; 1222 :     in -= strm->avail_in;
; 1223 :     out -= strm->avail_out;

  01597	2b 5f 18	 sub	 ebx, DWORD PTR [rdi+24]
  0159a	44 8b 55 bc	 mov	 r10d, DWORD PTR in$1$[rbp-128]
  0159e	44 2b 57 08	 sub	 r10d, DWORD PTR [rdi+8]

; 1224 :     strm->total_in += in;
; 1225 :     strm->total_out += out;

  015a2	01 5f 1c	 add	 DWORD PTR [rdi+28], ebx
  015a5	44 01 57 0c	 add	 DWORD PTR [rdi+12], r10d

; 1226 :     state->total += out;

  015a9	41 01 5d 1c	 add	 DWORD PTR [r13+28], ebx

; 1227 :     if (state->wrap && out)

  015ad	41 83 7d 08 00	 cmp	 DWORD PTR [r13+8], 0
  015b2	44 89 55 bc	 mov	 DWORD PTR in$1$[rbp-128], r10d
  015b6	74 32		 je	 SHORT $LN4@inflate
  015b8	85 db		 test	 ebx, ebx
  015ba	74 2e		 je	 SHORT $LN4@inflate

; 1228 :         strm->adler = state->check =
; 1229 :             UPDATE(state->check, strm->next_out - out, out);

  015bc	48 8b 57 10	 mov	 rdx, QWORD PTR [rdi+16]
  015c0	41 8b 4d 18	 mov	 ecx, DWORD PTR [r13+24]
  015c4	8b c3		 mov	 eax, ebx
  015c6	48 2b d0	 sub	 rdx, rax
  015c9	41 83 7d 10 00	 cmp	 DWORD PTR [r13+16], 0
  015ce	44 8b c3	 mov	 r8d, ebx
  015d1	74 07		 je	 SHORT $LN516@inflate
  015d3	e8 00 00 00 00	 call	 crc32
  015d8	eb 05		 jmp	 SHORT $LN517@inflate
$LN516@inflate:
  015da	e8 00 00 00 00	 call	 adler32
$LN517@inflate:
  015df	44 8b 55 bc	 mov	 r10d, DWORD PTR in$1$[rbp-128]
  015e3	41 89 45 18	 mov	 DWORD PTR [r13+24], eax
  015e7	89 47 4c	 mov	 DWORD PTR [rdi+76], eax
$LN4@inflate:

; 1230 :     strm->data_type = state->bits + (state->last ? 64 : 0) +
; 1231 :                       (state->mode == TYPE ? 128 : 0) +
; 1232 :                       (state->mode == LEN_ || state->mode == COPY_ ? 256 : 0);

  015ea	41 8b 55 00	 mov	 edx, DWORD PTR [r13]
  015ee	83 fa 13	 cmp	 edx, 19
  015f1	74 0d		 je	 SHORT $LN518@inflate
  015f3	83 fa 0e	 cmp	 edx, 14
  015f6	74 08		 je	 SHORT $LN518@inflate
  015f8	45 33 c9	 xor	 r9d, r9d
  015fb	45 8b c1	 mov	 r8d, r9d
  015fe	eb 09		 jmp	 SHORT $LN519@inflate
$LN518@inflate:
  01600	41 b8 00 01 00
	00		 mov	 r8d, 256		; 00000100H
  01606	45 33 c9	 xor	 r9d, r9d
$LN519@inflate:
  01609	41 8b 45 04	 mov	 eax, DWORD PTR [r13+4]
  0160d	f7 d8		 neg	 eax
  0160f	b8 80 00 00 00	 mov	 eax, 128		; 00000080H
  01614	1b c9		 sbb	 ecx, ecx
  01616	83 e1 40	 and	 ecx, 64			; 00000040H
  01619	83 fa 0b	 cmp	 edx, 11
  0161c	44 0f 44 c8	 cmove	 r9d, eax
  01620	41 8d 04 08	 lea	 eax, DWORD PTR [r8+rcx]
  01624	44 03 c8	 add	 r9d, eax
  01627	45 03 4d 44	 add	 r9d, DWORD PTR [r13+68]
  0162b	44 89 4f 48	 mov	 DWORD PTR [rdi+72], r9d

; 1233 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  0162f	45 85 d2	 test	 r10d, r10d
  01632	75 04		 jne	 SHORT $LN1@inflate
  01634	85 db		 test	 ebx, ebx
  01636	74 06		 je	 SHORT $LN2@inflate
$LN1@inflate:
  01638	83 7d 28 04	 cmp	 DWORD PTR flush$[rbp-128], 4
  0163c	75 0c		 jne	 SHORT $LN3@inflate
$LN2@inflate:
  0163e	b8 fb ff ff ff	 mov	 eax, -5
  01643	45 85 e4	 test	 r12d, r12d
  01646	44 0f 44 e0	 cmove	 r12d, eax
$LN3@inflate:

; 1234 :         ret = Z_BUF_ERROR;
; 1235 :     return ret;

  0164a	41 8b c4	 mov	 eax, r12d
  0164d	e9 8f f2 ff ff	 jmp	 $LN877@inflate
$LN11@inflate:

; 1201 :             goto inf_leave;
; 1202 :         case MEM:
; 1203 :             return Z_MEM_ERROR;
; 1204 :         case SYNC:
; 1205 :         default:
; 1206 :             return Z_STREAM_ERROR;

  01652	b8 fe ff ff ff	 mov	 eax, -2
  01657	e9 85 f2 ff ff	 jmp	 $LN877@inflate
$LN506@inflate:

; 614  :         return Z_STREAM_ERROR;

  0165c	b8 fe ff ff ff	 mov	 eax, -2

; 1236 : }

  01661	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  01668	41 5d		 pop	 r13
  0166a	41 5c		 pop	 r12
  0166c	5d		 pop	 rbp
  0166d	c3		 ret	 0
  0166e	66 90		 npad	 2
$LN746@inflate:
  01670	00 00 00 00	 DD	 $LN497@inflate
  01674	00 00 00 00	 DD	 $LN465@inflate
  01678	00 00 00 00	 DD	 $LN445@inflate
  0167c	00 00 00 00	 DD	 $LN427@inflate
  01680	00 00 00 00	 DD	 $LN410@inflate
  01684	00 00 00 00	 DD	 $LN389@inflate
  01688	00 00 00 00	 DD	 $LN382@inflate
  0168c	00 00 00 00	 DD	 $LN370@inflate
  01690	00 00 00 00	 DD	 $LN358@inflate
  01694	00 00 00 00	 DD	 $LN341@inflate
  01698	00 00 00 00	 DD	 $LN329@inflate
  0169c	00 00 00 00	 DD	 $LN324@inflate
  016a0	00 00 00 00	 DD	 $LN323@inflate
  016a4	00 00 00 00	 DD	 $LN290@inflate
  016a8	00 00 00 00	 DD	 $LN274@inflate
  016ac	00 00 00 00	 DD	 $LN272@inflate
  016b0	00 00 00 00	 DD	 $LN266@inflate
  016b4	00 00 00 00	 DD	 $LN533@inflate
  016b8	00 00 00 00	 DD	 $LN536@inflate
  016bc	00 00 00 00	 DD	 $LN147@inflate
  016c0	00 00 00 00	 DD	 $LN145@inflate
  016c4	00 00 00 00	 DD	 $LN112@inflate
  016c8	00 00 00 00	 DD	 $LN546@inflate
  016cc	00 00 00 00	 DD	 $LN75@inflate
  016d0	00 00 00 00	 DD	 $LN61@inflate
  016d4	00 00 00 00	 DD	 $LN47@inflate
  016d8	00 00 00 00	 DD	 $LN45@inflate
  016dc	00 00 00 00	 DD	 $LN29@inflate
  016e0	00 00 00 00	 DD	 $LN14@inflate
  016e4	00 00 00 00	 DD	 $LN13@inflate
  016e8	00 00 00 00	 DD	 $LN12@inflate
inflate	ENDP
_TEXT	ENDS
END
